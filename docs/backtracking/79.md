# [79. Word Search](https://leetcode.com/problems/word-search/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> if <code>word</code> exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" style="width: 322px; height: 242px;">

```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" style="width: 322px; height: 242px;">

```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
```

**Example 3:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" style="width: 322px; height: 242px;">

```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false
```

**Constraints:** 

- <code>m == board.length</code>
- <code>n = board[i].length</code>
- <code>1 <= m, n <= 6</code>
- <code>1 <= word.length <= 15</code>
- <code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.

**Follow up:**  Could you use search pruning to make your solution faster with a larger <code>board</code>?

## ðŸ’¡ Approach: Backtracking (DFS)

### Intuition

This is a classic **backtracking with DFS** problem. We need to search for a word in a 2D grid by exploring all possible paths from each cell. The key is to use DFS with backtracking to navigate through the grid while avoiding revisiting the same cell.

**Key Points:**
- Use DFS to explore all 4 directions (up, down, left, right)
- Keep track of visited cells to avoid cycles
- Backtrack when the current path doesn't lead to the word
- Return immediately when word is found

### Algorithm

1. **For each cell** in the board, start DFS search
2. **During DFS**:
   - Check if position is valid and character matches
   - Mark current cell as visited
   - Explore all 4 directions recursively
   - If current path forms the complete word, return true
   - Backtrack: unmark cell as visited
3. **Return false** if no path found starting from any cell

### Key Points

- Use backtracking with visited tracking to avoid revisiting cells
- Check bounds and character matching at each step
- Early termination when word is found
- Proper backtracking to restore grid state

## Code

::: code-group

```typescript [TypeScript]
function exist(board: string[][], word: string): boolean {
    if (board.length === 0 || board[0].length === 0) return false;
    
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    
    function dfs(index: number, row: number, col: number): boolean {
        // Base case: found the complete word
        if (index === word.length) return true;
        
        // Check bounds and character match
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length ||
            board[row][col] !== word[index]) {
            return false;
        }
        
        // Mark current cell as visited
        const originalChar = board[row][col];
        board[row][col] = '#';
        
        // Explore all 4 directions
        for (const [dr, dc] of directions) {
            if (dfs(index + 1, row + dr, col + dc)) {
                return true;
            }
        }
        
        // Backtrack: restore the original character
        board[row][col] = originalChar;
        return false;
    }
    
    // Try starting from each cell
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[0].length; j++) {
            if (dfs(0, i, j)) {
                return true;
            }
        }
    }
    
    return false;
}
```

```kotlin [Kotlin]
class Solution {
    private val directions = arrayOf(
        intArrayOf(0, 1), intArrayOf(0, -1),
        intArrayOf(1, 0), intArrayOf(-1, 0)
    )
    
    fun exist(board: Array<CharArray>, word: String): Boolean {
        if (board.isEmpty() || board[0].isEmpty()) return false
        
        for (i in board.indices) {
            for (j in board[0].indices) {
                if (dfs(board, word, 0, i, j)) {
                    return true
                }
            }
        }
        return false
    }
    
    private fun dfs(board: Array<CharArray>, word: String, index: Int, row: Int, col: Int): Boolean {
        // Base case: found the complete word
        if (index == word.length) return true
        
        // Check bounds and character match
        if (row < 0 || row >= board.size || col < 0 || col >= board[0].size ||
            board[row][col] != word[index]) {
            return false
        }
        
        // Mark current cell as visited
        val originalChar = board[row][col]
        board[row][col] = '#'
        
        // Explore all 4 directions
        for (direction in directions) {
            if (dfs(board, word, index + 1, row + direction[0], col + direction[1])) {
                return true
            }
        }
        
        // Backtrack: restore the original character
        board[row][col] = originalChar
        return false
    }
}
```

```java [Java]
class Solution {
    private int[][] directions = {â€‹{0, 1}, {0, -1}, {1, 0}, {-1, 0}â€‹};
    
    public boolean exist(char[][] board, String word) {
        if (board.length == 0 || board[0].length == 0) return false;
        
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (dfs(board, word, 0, i, j)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    private boolean dfs(char[][] board, String word, int index, int row, int col) {
        // Base case: found the complete word
        if (index == word.length()) return true;
        
        // Check bounds and character match
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length ||
            board[row][col] != word.charAt(index)) {
            return false;
        }
        
        // Mark current cell as visited
        char originalChar = board[row][col];
        board[row][col] = '#';
        
        // Explore all 4 directions
        for (int[] direction : directions) {
            if (dfs(board, word, index + 1, row + direction[0], col + direction[1])) {
                return true;
            }
        }
        
        // Backtrack: restore the original character
        board[row][col] = originalChar;
        return false;
    }
}
```

```swift [Swift]
class Solution {
    func exist(_ board: [[Character]], _ word: String) -> Bool {
        if board.isEmpty || board[0].isEmpty { return false }
        let rows = board.count
        let cols = board[0].count
        var grid = board
        let target = Array(word)

        func dfs(_ r: Int, _ c: Int, _ index: Int) -> Bool {
            if index == target.count {
                return true
            }
            if r < 0 || c < 0 || r >= rows || c >= cols {
                return false
            }
            if grid[r][c] != target[index] {
                return false
            }

            let temp = grid[r][c]
            grid[r][c] = "#"

            let found = dfs(r + 1, c, index + 1) ||
                dfs(r - 1, c, index + 1) ||
                dfs(r, c + 1, index + 1) ||
                dfs(r, c - 1, index + 1)

            grid[r][c] = temp
            return found
        }

        for r in 0..<rows {
            for c in 0..<cols {
                if dfs(r, c, 0) {
                    return true
                }
            }
        }

        return false
    }
}
```

```python [Python]
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        if not board or not board[0]:
            return False
        
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        rows, cols = len(board), len(board[0])
        
        def dfs(index: int, row: int, col: int) -> bool:
            # Base case: found the complete word
            if index == len(word):
                return True
            
            # Check bounds and character match
            if (row < 0 or row >= rows or col < 0 or col >= cols or 
                board[row][col] != word[index]):
                return False
            
            # Mark current cell as visited
            original_char = board[row][col]
            board[row][col] = '#'
            
            # Explore all 4 directions
            for dr, dc in directions:
                if dfs(index + 1, row + dr, col + dc):
                    return True
            
            # Backtrack: restore the original character
            board[row][col] = original_char
            return False
        
        # Try starting from each cell
        for i in range(rows):
            for j in range(cols):
                if dfs(0, i, j):
                    return True
        
        return False
```

:::
## Complexity

- **Time Complexity:** O(M Ã— N Ã— 4^L) where MÃ—N is the board size and L is the length of the word. In worst case, we explore 4 directions for each cell up to L depth
- **Space Complexity:** O(L) for the recursion stack during DFS