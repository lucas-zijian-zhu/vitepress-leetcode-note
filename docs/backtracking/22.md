# [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-interview-150)

Given <code>n</code> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

**Example 1:** 

```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
```

**Example 2:** 

```
Input: n = 1
Output: ["()"]
```

**Constraints:** 

- <code>1 <= n <= 8</code>

## ðŸ’¡ Approach: Backtracking

### Intuition

This is a classic **backtracking** problem where we need to generate all valid parentheses combinations. The key insight is to use backtracking to build valid parentheses strings while maintaining the balance constraint.

**Key Rules for valid parentheses:**
- At any point, `open_count >= close_count`
- Total `open_count = close_count = n`
- We can add `(` if `open_count < n`
- We can add `)` if `close_count < open_count`

### Algorithm

1. **Start with empty string** and counts (open=0, close=0)
2. **For each step**:
   - Add `(` if we still have open brackets left
   - Add `)` if it won't make the string invalid (close < open)
   - Recurse with updated counts and string
   - Backtrack to try the other option
3. **When both counts reach n**, we have a valid combination

### Key Points

- Use backtracking with open/close count tracking
- Prune invalid branches early (when close > open)
- Ensure we never have more closing than opening brackets anywhere

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun generateParenthesis(n: Int): List<String> {
        val result = mutableListOf<String>()
        backtrack("", 0, 0, n, result)
        return result
    }
    
    private fun backtrack(
        current: String,
        open: Int,
        close: Int,
        n: Int,
        result: MutableList<String>
    ) {
        // Base case: we have used all brackets
        if (open == n && close == n) {
            result.add(current)
            return
        }
        
        // Add opening bracket if we still have some left
        if (open < n) {
            backtrack(current + "(", open + 1, close, n, result)
        }
        
        // Add closing bracket if it won't make the string invalid
        if (close < open) {
            backtrack(current + ")", open, close + 1, n, result)
        }
    }
}
```

```typescript [TypeScript]
function generateParenthesis(n: number): string[] {
    const result: string[] = [];
    backtrack("", 0, 0, n, result);
    return result;
}

function backtrack(
    current: string,
    open: number,
    close: number,
    n: number,
    result: string[]
): void {
    // Base case: we have used all brackets
    if (open === n && close === n) {
        result.push(current);
        return;
    }
    
    // Add opening bracket if we still have some left
    if (open < n) {
        backtrack(current + "(", open + 1, close, n, result);
    }
    
    // Add closing bracket if it won't make the string invalid
    if (close < open) {
        backtrack(current + ")", open, close + 1, n, result);
    }
}
```

```java [Java]
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        backtrack("", 0, 0, n, result);
        return result;
    }
    
    private void backtrack(
        String current,
        int open,
        int close,
        int n,
        List<String> result
    ) {
        // Base case: we have used all brackets
        if (open == n && close == n) {
            result.add(current);
            return;
        }
        
        // Add opening bracket if we still have some left
        if (open < n) {
            backtrack(current + "(", open + 1, close, n, result);
        }
        
        // Add closing bracket if it won't make the string invalid
        if (close < open) {
            backtrack(current + ")", open, close + 1, n, result);
        }
    }
}
```

```python [Python]
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        result = []
        self.backtrack("", 0, 0, n, result)
        return result
    
    def backtrack(self, current: str, open_count: int, close_count: int, n: int, result: List[str]) -> None:
        # Base case: we have used all brackets
        if open_count == n and close_count == n:
            result.append(current)
            return
        
        # Add opening bracket if we still have some left
        if open_count < n:
            self.backtrack(current + "(", open_count + 1, close_count, n, result)
        
        # Add closing bracket if it won't make the string invalid
        if close_count < open_count:
            self.backtrack(current + ")", open_count, close_count + 1, n, result)
```

:::

## Complexity

- **Time Complexity:** O(C(n)) where C(n) is the nth Catalan number â‰ˆ O(4^n / âˆšn)
- **Space Complexity:** O(C(n)) for storing all valid combinations, plus O(n) for recursion stack

**Note:** C(n) is the nth Catalan number â‰ˆ 4^n / (âˆšÏ€ Ã— n^(3/2)), which grows exponentially but slower than 4^n due to the âˆšn factor.