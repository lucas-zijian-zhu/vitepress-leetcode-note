# [46. Permutations](https://leetcode.com/problems/permutations/description/?envType=study-plan-v2&envId=top-interview-150)

Given an array <code>nums</code> of distinct integers, return all the possible <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1n:" data-state="closed" class="">permutations</button>. You can return the answer in **any order** .

**Example 1:** 

```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**Example 2:** 

```
Input: nums = [0,1]
Output: [[0,1],[1,0]]
```

**Example 3:** 

```
Input: nums = [1]
Output: [[1]]
```

**Constraints:** 

- <code>1 <= nums.length <= 6</code>
- <code>-10 <= nums[i] <= 10</code>
- All the integers of <code>nums</code> are **unique** .

## ðŸ’¡ Approach: Backtracking

### Intuition

This is a classic **backtracking** problem where we need to generate all possible permutations of the given array. Since we need to generate all permutations, we use backtracking to systematically explore all possible arrangements.

**Key Points:**
- Use a `used` array or set to track which elements are already included in current permutation
- For each position, try all unused elements
- Backtrack when we need to explore other possibilities

### Algorithm

1. **Start with empty permutation** and empty used set
2. **For each position in the permutation**:
   - Try each unused element from nums
   - Add to current permutation and mark as used
   - Recurse to fill next position
   - Backtrack: remove from permutation and mark as unused
3. **When permutation is complete**, add to result

### Key Points

- Use backtracking with visited tracking to avoid using same element twice
- Ensure we explore all possible arrangements
- The number of permutations is n! for n distinct elements

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun permute(nums: IntArray): List<List<Int>> {
        val result = mutableListOf<List<Int>>()
        val current = mutableListOf<Int>()
        val used = BooleanArray(nums.size)
        backtrack(nums, current, used, result)
        return result
    }
    
    private fun backtrack(
        nums: IntArray,
        current: MutableList<Int>,
        used: BooleanArray,
        result: MutableList<List<Int>>
    ) {
        // Base case: current permutation is complete
        if (current.size == nums.size) {
            result.add(ArrayList(current))
            return
        }
        
        for (i in nums.indices) {
            if (!used[i]) {
                // Choose
                current.add(nums[i])
                used[i] = true
                
                // Explore
                backtrack(nums, current, used, result)
                
                // Backtrack
                current.removeAt(current.size - 1)
                used[i] = false
            }
        }
    }
}
```

```typescript [TypeScript]
function permute(nums: number[]): number[][] {
    const result: number[][] = [];
    const current: number[] = [];
    const used: boolean[] = new Array(nums.length).fill(false);
    
    backtrack(nums, current, used, result);
    return result;
}

function backtrack(
    nums: number[],
    current: number[],
    used: boolean[],
    result: number[][]
): void {
    // Base case: current permutation is complete
    if (current.length === nums.length) {
        result.push([...current]);
        return;
    }
    
    for (let i = 0; i < nums.length; i++) {
        if (!used[i]) {
            // Choose
            current.push(nums[i]);
            used[i] = true;
            
            // Explore
            backtrack(nums, current, used, result);
            
            // Backtrack
            current.pop();
            used[i] = false;
        }
    }
}
```

```java [Java]
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> current = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        backtrack(nums, current, used, result);
        return result;
    }
    
    private void backtrack(
        int[] nums,
        List<Integer> current,
        boolean[] used,
        List<List<Integer>> result
    ) {
        // Base case: current permutation is complete
        if (current.size() == nums.length) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (!used[i]) {
                // Choose
                current.add(nums[i]);
                used[i] = true;
                
                // Explore
                backtrack(nums, current, used, result);
                
                // Backtrack
                current.remove(current.size() - 1);
                used[i] = false;
            }
        }
    }
}
```

```python [Python]
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        result = []
        current = []
        used = [False] * len(nums)
        self.backtrack(nums, current, used, result)
        return result
    
    def backtrack(self, nums: List[int], current: List[int], used: List[bool], result: List[List[int]]) -> None:
        # Base case: current permutation is complete
        if len(current) == len(nums):
            result.append(current[:])
            return
        
        for i in range(len(nums)):
            if not used[i]:
                # Choose
                current.append(nums[i])
                used[i] = True
                
                # Explore
                self.backtrack(nums, current, used, result)
                
                # Backtrack
                current.pop()
                used[i] = False
```

:::

## Complexity

- **Time Complexity:** O(n! Ã— n) where n is the number of elements. There are n! permutations and each takes O(n) time to copy to result
- **Space Complexity:** O(n! Ã— n) for storing all permutations, plus O(n) for recursion stack and tracking arrays