# [77. Combinations](https://leetcode.com/problems/combinations/description/?envType=study-plan-v2&envId=top-interview-150)

Given two integers <code>n</code> and <code>k</code>, return all possible combinations of <code>k</code> numbers chosen from the range <code>[1, n]</code>.

You may return the answer in **any order** .

**Example 1:** 

```
Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.
```

**Example 2:** 

```
Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
```

**Constraints:** 

- <code>1 <= n <= 20</code>
- <code>1 <= k <= n</code>

## ðŸ’¡ Approach: Backtracking

### Intuition

This is a classic **backtracking** problem where we need to generate all possible combinations of k numbers from the range [1, n]. Since we need combinations (not permutations), order doesn't matter, so we can avoid duplicates by ensuring we always choose numbers in ascending order.

**Key Points:**
- Use backtracking to build combinations one element at a time
- Start from current index to avoid duplicates (only consider numbers >= current choice)
- Stop when we have selected k elements

### Algorithm

1. **Start with empty combination** and current number = 1
2. **For each position**:
   - Try each number from current to n
   - Add to current combination
   - Recurse to build next element (starting from next number)
   - Backtrack: remove current number and try next
3. **When combination has k elements**, add to result

### Key Points

- Use index parameter to ensure ascending order (avoid duplicates)
- Prune early when remaining numbers cannot complete the combination
- Backtrack properly to explore all possibilities

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun combine(n: Int, k: Int): List<List<Int>> {
        val result = mutableListOf<List<Int>>()
        val current = mutableListOf<Int>()
        backtrack(n, k, 1, current, result)
        return result
    }
    
    private fun backtrack(
        n: Int,
        k: Int,
        start: Int,
        current: MutableList<Int>,
        result: MutableList<List<Int>>
    ) {
        // Base case: we have k elements in our combination
        if (current.size == k) {
            result.add(ArrayList(current))
            return
        }
        
        // Try each number from start to n
        for (i in start..n) {
            // Pruning: if we can't complete the combination with remaining numbers
            if (current.size + (n - i + 1) < k) break
            
            current.add(i)
            backtrack(n, k, i + 1, current, result) // Use i + 1 to avoid duplicates
            current.removeAt(current.size - 1) // Backtrack
        }
    }
}
```

```typescript [TypeScript]
function combine(n: number, k: number): number[][] {
    const result: number[][] = [];
    const current: number[] = [];
    backtrack(n, k, 1, current, result);
    return result;
}

function backtrack(
    n: number,
    k: number,
    start: number,
    current: number[],
    result: number[][]
): void {
    // Base case: we have k elements in our combination
    if (current.length === k) {
        result.push([...current]);
        return;
    }
    
    // Try each number from start to n
    for (let i = start; i <= n; i++) {
        // Pruning: if we can't complete the combination with remaining numbers
        if (current.length + (n - i + 1) < k) break;
        
        current.push(i);
        backtrack(n, k, i + 1, current, result); // Use i + 1 to avoid duplicates
        current.pop(); // Backtrack
    }
}
```

```java [Java]
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> current = new ArrayList<>();
        backtrack(n, k, 1, current, result);
        return result;
    }
    
    private void backtrack(
        int n,
        int k,
        int start,
        List<Integer> current,
        List<List<Integer>> result
    ) {
        // Base case: we have k elements in our combination
        if (current.size() == k) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        // Try each number from start to n
        for (int i = start; i <= n; i++) {
            // Pruning: if we can't complete the combination with remaining numbers
            if (current.size() + (n - i + 1) < k) break;
            
            current.add(i);
            backtrack(n, k, i + 1, current, result); // Use i + 1 to avoid duplicates
            current.remove(current.size() - 1); // Backtrack
        }
    }
}
```

```python [Python]
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        current = []
        self.backtrack(n, k, 1, current, result)
        return result
    
    def backtrack(self, n: int, k: int, start: int, current: List[int], result: List[List[int]]) -> None:
        # Base case: we have k elements in our combination
        if len(current) == k:
            result.append(current[:])
            return
        
        # Try each number from start to n
        for i in range(start, n + 1):
            # Pruning: if we can't complete the combination with remaining numbers
            if len(current) + (n - i + 1) < k:
                break
            
            current.append(i)
            self.backtrack(n, k, i + 1, current, result)  # Use i + 1 to avoid duplicates
            current.pop()  # Backtrack
```

:::

## Complexity

- **Time Complexity:** O(C(n, k) Ã— k) where C(n, k) is the binomial coefficient "n choose k". There are C(n, k) combinations and each takes O(k) time to copy to result
- **Space Complexity:** O(C(n, k) Ã— k) for storing all combinations, plus O(k) for recursion stack