# [39. Combination Sum](https://leetcode.com/problems/combination-sum/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given an array of **distinct**  integers <code>candidates</code> and a target integer <code>target</code>, return a list of all **unique combinations**  of <code>candidates</code> where the chosen numbers sum to <code>target</code>. You may return the combinations in **any order** .

The **same**  number may be chosen from <code>candidates</code> an **unlimited number of times** . Two combinations are unique if the <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1n:" data-state="closed" class="">frequency</button> of at least one of the chosen numbers is different.

The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.

**Example 1:**

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
```

**Example 2:**

```
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
```

**Example 3:**

```
Input: candidates = [2], target = 1
Output: []
```

**Constraints:**

- <code>1 <= candidates.length <= 30</code>
- <code>2 <= candidates[i] <= 40</code>
- All elements of <code>candidates</code> are **distinct** .
- <code>1 <= target <= 40</code>

## ðŸš€ Approach: Backtracking

### Intuition

This is a classic **backtracking** problem where we need to explore all possible combinations that sum to the target. The key insight is that we can reuse the same number multiple times.

**Key Points:**
1. **Backtracking** - Try adding each candidate, recurse, then backtrack
2. **Reuse allowed** - Same number can be used unlimited times
3. **Avoid duplicates** - Start from current index to avoid permutations
4. **Pruning** - Stop early if current sum exceeds target

### Algorithm

1. **Start with empty combination** and sum = 0
2. **For each candidate** (from current index):
   - Add candidate to current combination
   - Recursively explore with updated sum
   - If sum equals target, add to result
   - If sum exceeds target, stop (pruning)
   - Backtrack: remove candidate
3. **Return all valid combinations**

---

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun combinationSum(candidates: IntArray, target: Int): List<List<Int>> {
        val result = mutableListOf<List<Int>>()
        val current = mutableListOf<Int>()
        backtrack(candidates, target, 0, 0, current, result)
        return result
    }
    
    private fun backtrack(
        candidates: IntArray,
        target: Int,
        start: Int,
        sum: Int,
        current: MutableList<Int>,
        result: MutableList<List<Int>>
    ) {
        if (sum == target) {
            result.add(ArrayList(current))
            return
        }
        
        if (sum > target) return // Pruning
        
        for (i in start until candidates.size) {
            current.add(candidates[i])
            // Can reuse same element, so pass i (not i+1)
            backtrack(candidates, target, i, sum + candidates[i], current, result)
            current.removeAt(current.size - 1) // Backtrack
        }
    }
}
```

```typescript [TypeScript]
function combinationSum(candidates: number[], target: number): number[][] {
    const result: number[][] = [];
    const current: number[] = [];
    backtrack(candidates, target, 0, 0, current, result);
    return result;
}

function backtrack(
    candidates: number[],
    target: number,
    start: number,
    sum: number,
    current: number[],
    result: number[][]
): void {
    if (sum === target) {
        result.push([...current]);
        return;
    }
    
    if (sum > target) return; // Pruning
    
    for (let i = start; i < candidates.length; i++) {
        current.push(candidates[i]);
        // Can reuse same element, so pass i (not i+1)
        backtrack(candidates, target, i, sum + candidates[i], current, result);
        current.pop(); // Backtrack
    }
}
```

```java [Java]
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> current = new ArrayList<>();
        backtrack(candidates, target, 0, 0, current, result);
        return result;
    }
    
    private void backtrack(
        int[] candidates,
        int target,
        int start,
        int sum,
        List<Integer> current,
        List<List<Integer>> result
    ) {
        if (sum == target) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        if (sum > target) return; // Pruning
        
        for (int i = start; i < candidates.length; i++) {
            current.add(candidates[i]);
            // Can reuse same element, so pass i (not i+1)
            backtrack(candidates, target, i, sum + candidates[i], current, result);
            current.remove(current.size() - 1); // Backtrack
        }
    }
}
```

```swift [Swift]
class Solution {
    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {
        let nums = candidates.sorted()
        var result: [[Int]] = []
        var path: [Int] = []

        func backtrack(_ index: Int, _ remaining: Int) {
            if remaining == 0 {
                result.append(path)
                return
            }
            if index == nums.count || remaining < 0 {
                return
            }

            path.append(nums[index])
            backtrack(index, remaining - nums[index])
            path.removeLast()
            backtrack(index + 1, remaining)
        }

        backtrack(0, target)
        return result
    }
}
```

```python [Python]
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        current = []
        self.backtrack(candidates, target, 0, 0, current, result)
        return result
    
    def backtrack(self, candidates: List[int], target: int, start: int, current_sum: int, current: List[int], result: List[List[int]]) -> None:
        if current_sum == target:
            result.append(current[:])
            return
        
        if current_sum > target:
            return  # Pruning
        
        for i in range(start, len(candidates)):
            current.append(candidates[i])
            # Can reuse same element, so pass i (not i+1)
            self.backtrack(candidates, target, i, current_sum + candidates[i], current, result)
            current.pop()  # Backtrack
```

:::

## Complexity Analysis

**Notation:**
- **n** = Length of candidates array
- **t** = Target value
- **m** = Minimum value in candidates

- **Time Complexity:** O(n^(t/m))
  - In worst case, we explore a tree of depth t/m
  - At each level, we have n choices
  - Exponential complexity due to exploring all combinations
- **Space Complexity:** O(t/m)
  - Recursion depth: O(t/m) - maximum depth of recursion tree
  - Current combination: O(t/m) - maximum length of a valid combination