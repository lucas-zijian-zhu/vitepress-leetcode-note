# [52. N-Queens II](https://leetcode.com/problems/n-queens-ii/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="danger" text="Hard" />

The **n-queens**  puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.

Given an integer <code>n</code>, return the number of distinct solutions to the**n-queens puzzle** .

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" style="width: 600px; height: 268px;">

```
Input: n = 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown.
```

**Example 2:** 

```
Input: n = 1
Output: 1
```

**Constraints:** 

- <code>1 <= n <= 9</code>

## ðŸ’¡ Approach: Backtracking with Constraint Satisfaction

### Intuition

This is a classic **backtracking** problem where we need to count the number of valid solutions for the N-Queens puzzle. Unlike the N-Queens I problem that returns all solutions, this problem only needs the count, which allows for some optimizations.

**Key Rules for N-Queens:**
- Place one queen per row
- No two queens can be in the same column
- No two queens can be in the same diagonal (both main and anti-diagonal)

### Algorithm

1. **Use backtracking** to place queens row by row
2. **Track constraints** efficiently:
   - `cols` array to track used columns
   - `diag1` array for main diagonal (row - col = constant)
   - `diag2` array for anti-diagonal (row + col = constant)
3. **For each row**, try placing queen in each column
4. **If placement is valid**, recurse to next row
5. **Count all valid solutions**

### Key Points

- Use arrays to track column and diagonal conflicts for O(1) checking
- Main diagonal: row - col = constant (can be negative, offset by n)
- Anti-diagonal: row + col = constant
- Only count solutions, don't store them

## Code

::: code-group

```typescript [TypeScript]
function totalNQueens(n: number): number {
    const cols: boolean[] = new Array(n).fill(false);
    const diag1: boolean[] = new Array(2 * n - 1).fill(false); // main diagonal
    const diag2: boolean[] = new Array(2 * n - 1).fill(false); // anti-diagonal
    
    return backtrack(0, n, cols, diag1, diag2);
}

function backtrack(
    row: number,
    n: number,
    cols: boolean[],
    diag1: boolean[],
    diag2: boolean[]
): number {
    // Base case: all queens placed
    if (row === n) {
        return 1;
    }
    
    let count = 0;
    
    // Try placing queen in each column of current row
    for (let col = 0; col < n; col++) {
        const d1 = row - col + n - 1; // offset to avoid negative index
        const d2 = row + col;
        
        if (!cols[col] && !diag1[d1] && !diag2[d2]) {
            // Place queen
            cols[col] = true;
            diag1[d1] = true;
            diag2[d2] = true;
            
            // Recurse to next row
            count += backtrack(row + 1, n, cols, diag1, diag2);
            
            // Backtrack
            cols[col] = false;
            diag1[d1] = false;
            diag2[d2] = false;
        }
    }
    
    return count;
}
```

```kotlin [Kotlin]
class Solution {
    fun totalNQueens(n: Int): Int {
        val cols = BooleanArray(n)
        val diag1 = BooleanArray(2 * n - 1) // main diagonal
        val diag2 = BooleanArray(2 * n - 1) // anti-diagonal
        
        return backtrack(0, n, cols, diag1, diag2)
    }
    
    private fun backtrack(
        row: Int,
        n: Int,
        cols: BooleanArray,
        diag1: BooleanArray,
        diag2: BooleanArray
    ): Int {
        // Base case: all queens placed
        if (row == n) {
            return 1
        }
        
        var count = 0
        
        // Try placing queen in each column of current row
        for (col in 0 until n) {
            val d1 = row - col + n - 1 // offset to avoid negative index
            val d2 = row + col
            
            if (!cols[col] && !diag1[d1] && !diag2[d2]) {
                // Place queen
                cols[col] = true
                diag1[d1] = true
                diag2[d2] = true
                
                // Recurse to next row
                count += backtrack(row + 1, n, cols, diag1, diag2)
                
                // Backtrack
                cols[col] = false
                diag1[d1] = false
                diag2[d2] = false
            }
        }
        
        return count
    }
}
```

```java [Java]
class Solution {
    public int totalNQueens(int n) {
        boolean[] cols = new boolean[n];
        boolean[] diag1 = new boolean[2 * n - 1]; // main diagonal
        boolean[] diag2 = new boolean[2 * n - 1]; // anti-diagonal
        
        return backtrack(0, n, cols, diag1, diag2);
    }
    
    private int backtrack(
        int row,
        int n,
        boolean[] cols,
        boolean[] diag1,
        boolean[] diag2
    ) {
        // Base case: all queens placed
        if (row == n) {
            return 1;
        }
        
        int count = 0;
        
        // Try placing queen in each column of current row
        for (int col = 0; col < n; col++) {
            int d1 = row - col + n - 1; // offset to avoid negative index
            int d2 = row + col;
            
            if (!cols[col] && !diag1[d1] && !diag2[d2]) {
                // Place queen
                cols[col] = true;
                diag1[d1] = true;
                diag2[d2] = true;
                
                // Recurse to next row
                count += backtrack(row + 1, n, cols, diag1, diag2);
                
                // Backtrack
                cols[col] = false;
                diag1[d1] = false;
                diag2[d2] = false;
            }
        }
        
        return count;
    }
}
```

```swift [Swift]
class Solution {
    func totalNQueens(_ n: Int) -> Int {
        var columns = Set<Int>()
        var diag1 = Set<Int>() // row - col
        var diag2 = Set<Int>() // row + col
        var count = 0

        func backtrack(_ row: Int) {
            if row == n {
                count += 1
                return
            }

            for col in 0..<n {
                if columns.contains(col) || diag1.contains(row - col) || diag2.contains(row + col) {
                    continue
                }
                columns.insert(col)
                diag1.insert(row - col)
                diag2.insert(row + col)

                backtrack(row + 1)

                columns.remove(col)
                diag1.remove(row - col)
                diag2.remove(row + col)
            }
        }

        backtrack(0)
        return count
    }
}
```

```python [Python]
class Solution:
    def totalNQueens(self, n: int) -> int:
        cols = [False] * n
        diag1 = [False] * (2 * n - 1)  # main diagonal
        diag2 = [False] * (2 * n - 1)  # anti-diagonal
        
        return self.backtrack(0, n, cols, diag1, diag2)
    
    def backtrack(self, row: int, n: int, cols: List[bool], diag1: List[bool], diag2: List[bool]) -> int:
        # Base case: all queens placed
        if row == n:
            return 1
        
        count = 0
        
        # Try placing queen in each column of current row
        for col in range(n):
            d1 = row - col + n - 1  # offset to avoid negative index
            d2 = row + col
            
            if not cols[col] and not diag1[d1] and not diag2[d2]:
                # Place queen
                cols[col] = True
                diag1[d1] = True
                diag2[d2] = True
                
                # Recurse to next row
                count += self.backtrack(row + 1, n, cols, diag1, diag2)
                
                # Backtrack
                cols[col] = False
                diag1[d1] = False
                diag2[d2] = False
        
        return count
```

:::
## Complexity

- **Time Complexity:** O(N!) - In worst case, we explore all N! permutations of placing queens, but with pruning it's much better in practice
- **Space Complexity:** O(N) - For the constraint tracking arrays and recursion stack depth