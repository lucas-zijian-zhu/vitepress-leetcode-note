# [435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given an array of intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

**Example 1:**

```
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: Remove [1,3] and the rest are non-overlapping.
```

**Example 2:**

```
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: Remove two intervals so only one remains.
```

**Example 3:**

```
Input: intervals = [[1,2],[2,3]]
Output: 0
```

**Constraints:**

- <code>1 <= intervals.length <= 10^5</code>
- <code>intervals[i].length == 2</code>
- <code>-5 * 10^4 <= start<sub>i</sub> < end<sub>i</sub> <= 5 * 10^4</code>

## Approach

We want to keep as many non-overlapping intervals as possible, which is the classic interval scheduling problem:

1. **Sort by end time**  
   - Always pick the interval that ends earliest.
2. **Greedy selection**  
   - Keep the first interval, then for each next interval:
     - If it overlaps (start < currentEnd), we must remove it.
     - Otherwise, keep it and update `currentEnd`.

The answer is the number of removed intervals.

## Code

:::: code-group

```kotlin [Kotlin]
class Solution {
    fun eraseOverlapIntervals(intervals: Array<IntArray>): Int {
        if (intervals.isEmpty()) return 0

        intervals.sortBy { it[1] } // sort by end time
        var removed = 0
        var currentEnd = intervals[0][1]

        for (i in 1 until intervals.size) {
            val start = intervals[i][0]
            val end = intervals[i][1]
            if (start < currentEnd) {
                removed++
            } else {
                currentEnd = end
            }
        }

        return removed
    }
}
```

```typescript [TypeScript]
function eraseOverlapIntervals(intervals: number[][]): number {
    if (intervals.length === 0) return 0;

    intervals.sort((a, b) => a[1] - b[1]); // sort by end time
    let removed = 0;
    let currentEnd = intervals[0][1];

    for (let i = 1; i < intervals.length; i++) {
        const [start, end] = intervals[i];
        if (start < currentEnd) {
            removed++;
        } else {
            currentEnd = end;
        }
    }

    return removed;
}
```

```java [Java]
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) return 0;

        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));
        int removed = 0;
        int currentEnd = intervals[0][1];

        for (int i = 1; i < intervals.length; i++) {
            int start = intervals[i][0];
            int end = intervals[i][1];
            if (start < currentEnd) {
                removed++;
            } else {
                currentEnd = end;
            }
        }

        return removed;
    }
}
```

```python [Python]
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0

        intervals.sort(key=lambda x: x[1])  # sort by end time
        removed = 0
        current_end = intervals[0][1]

        for start, end in intervals[1:]:
            if start < current_end:
                removed += 1
            else:
                current_end = end

        return removed
```

::::

## Complexity

- **Sorting**: `O(n log n)`
- **Greedy scan**: `O(n)`
- **Total Time Complexity**: **`O(n log n)`**
- **Space Complexity**: **`O(1)`** (ignoring sorting overhead)
