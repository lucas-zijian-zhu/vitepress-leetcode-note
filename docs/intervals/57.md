# [57. Insert Interval](https://leetcode.com/problems/insert-interval/description/?envType=study-plan-v2&envId=top-interview-150)

You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i^th</code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.

Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return <code>intervals</code> after the insertion.

**Note**  that you don't need to modify <code>intervals</code> in-place. You can make a new array and return it.

**Example 1:** 

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:** 

```
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

**Constraints:** 

- <code>0 <= intervals.length <= 10^4</code>
- <code>intervals[i].length == 2</code>
- <code>0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10^5</code>
- <code>intervals</code> is sorted by <code>start<sub>i</sub></code> in **ascending**  order.
- <code>newInterval.length == 2</code>
- <code>0 <= start <= end <= 10^5</code>

## Approach

The key is to find the correct position for the `newInterval` and then merge it with any overlapping intervals. We can iterate through the existing intervals and handle three distinct cases:

1.  **Non-overlapping intervals before `newInterval`:**
    - If the current interval ends before `newInterval` starts, it means there's no overlap. Add the current interval to the result list directly.
2.  **Overlapping intervals:**
    - If the current interval overlaps with `newInterval` (i.e., they intersect), we need to merge them. Update the `newInterval`'s start to the minimum of the two starts, and its end to the maximum of the two ends. We don't add anything to the result list yet.
3.  **Non-overlapping intervals after `newInterval`:**
    - If the current interval starts after the `newInterval` ends, it means we have finished merging. Add the (potentially merged) `newInterval` to the result list, then add all remaining intervals from the original list.

---

## Kotlin Code

```kotlin
class Solution {
    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {
        val merged = mutableListOf<IntArray>()
        var i = 0
        val n = intervals.size

        // Case 1: Add all intervals that end before the newInterval starts
        while (i < n && intervals[i][1] < newInterval[0]) {
            merged.add(intervals[i])
            i++
        }

        // Case 2: Merge overlapping intervals
        var tempInterval = newInterval
        while (i < n && intervals[i][0] <= tempInterval[1]) {
            tempInterval[0] = minOf(tempInterval[0], intervals[i][0])
            tempInterval[1] = maxOf(tempInterval[1], intervals[i][1])
            i++
        }
        merged.add(tempInterval)

        // Case 3: Add all remaining intervals
        while (i < n) {
            merged.add(intervals[i])
            i++
        }

        return merged.toTypedArray()
    }
}
```

## Complexity

- **Time Complexity**: **`O(n)`**. We iterate through the list of intervals only once. The time complexity is linear with respect to the number of intervals.
- **Space Complexity**: **`O(n)`**. The space used is for storing the result list, which in the worst-case scenario (no overlaps) can contain up to `n + 1` intervals.