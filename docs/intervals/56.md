# [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-interview-150)

Given an arrayof <code>intervals</code>where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

**Example 1:** 

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:** 

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Constraints:** 

- <code>1 <= intervals.length <= 10^4</code>
- <code>intervals[i].length == 2</code>
- <code>0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10^4</code>

## Approach

1. **Sort the intervals**  
   - Sort all intervals by their starting point.  
   - This ensures that we can handle them in the correct order for merging.

2. **Merge overlapping intervals**  
   - Initialize an empty list `merged`.  
   - Iterate through each interval:
     - If `merged` is empty, or the current interval does not overlap with the last one in `merged`, add it directly.  
     - Otherwise, update the `end` of the last interval in `merged` with the maximum end value between the two.

3. **Return the merged result**  
   - After iteration, `merged` contains the final merged intervals.

## Kotlin Code

```kotlin
class Solution {
    fun merge(intervals: Array<IntArray>): Array<IntArray> {
        if (intervals.isEmpty()) return arrayOf()

        // Step 1: Sort by the start value
        intervals.sortBy { it[0] }

        val merged = mutableListOf<IntArray>()

        for (interval in intervals) {
            if (merged.isEmpty() || merged.last()[1] < interval[0]) {
                // No overlap, add the interval
                merged.add(interval)
            } else {
                // Overlap exists, merge with the last interval
                merged.last()[1] = maxOf(merged.last()[1], interval[1])
            }
        }

        return merged.toTypedArray()
    }
}
```

## Complexity

- **Sorting**: `O(n log n)`  
- **Merging**: `O(n)`  
- **Total Time Complexity**: **`O(n log n)`**  
- **Space Complexity**:  
  - Sorting requires `O(log n)` space (depending on the sorting algorithm).  
  - The result list holds at most `n` intervals.  
  - **Overall: O(n)**

