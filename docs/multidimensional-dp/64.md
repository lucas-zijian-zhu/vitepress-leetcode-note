# [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

**Note:**  You can only move either down or right at any point in time.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" style="width: 242px; height: 242px;">

```
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 ‚Üí 3 ‚Üí 1 ‚Üí 1 ‚Üí 1 minimizes the sum.
```

**Example 2:** 

```
Input: grid = [[1,2,3],[4,5,6]]
Output: 12
```

**Constraints:** 

- <code>m == grid.length</code>
- <code>n == grid[i].length</code>
- <code>1 <= m, n <= 200</code>
- <code>0 <= grid[i][j] <= 200</code>

## üí° Approach: 2D Dynamic Programming

### Idea
- Define `dp[i][j]` as the **minimum path sum to reach cell (i, j)**.
- Transition:
  ```
  dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
  ```
since you can only come from the cell above or from the left.
- Boundary:
- First row: can only come from the left.
- First column: can only come from the top.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
  fun minPathSum(grid: Array<IntArray>): Int {
      val m = grid.size
      val n = grid[0].size

      val dp = Array(m) { IntArray(n) }
      dp[0][0] = grid[0][0]

      // Initialize first row
      for (j in 1 until n) {
          dp[0][j] = dp[0][j - 1] + grid[0][j]
      }

      // Initialize first column
      for (i in 1 until m) {
          dp[i][0] = dp[i - 1][0] + grid[i][0]
      }

      // Fill in the rest of dp table
      for (i in 1 until m) {
          for (j in 1 until n) {
              dp[i][j] = grid[i][j] + minOf(dp[i - 1][j], dp[i][j - 1])
          }
      }

      return dp[m - 1][n - 1]
  }
}
```

```typescript [TypeScript]
function minPathSum(grid: number[][]): number {
    const m = grid.length;
    const n = grid[0].length;

    const dp: number[][] = Array(m).fill(null).map(() => Array(n).fill(0));
    dp[0][0] = grid[0][0];

    // Initialize first row
    for (let j = 1; j < n; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }

    // Initialize first column
    for (let i = 1; i < m; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }

    // Fill in the rest of dp table
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
        }
    }

    return dp[m - 1][n - 1];
}
```

```java [Java]
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];

        // Initialize first row
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        // Initialize first column
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        // Fill in the rest of dp table
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
            }
        }

        return dp[m - 1][n - 1];
    }
}
```

```python [Python]
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        dp = [[0] * n for _ in range(m)]
        dp[0][0] = grid[0][0]

        # Initialize first row
        for j in range(1, n):
            dp[0][j] = dp[0][j - 1] + grid[0][j]

        # Initialize first column
        for i in range(1, m):
            dp[i][0] = dp[i - 1][0] + grid[i][0]

        # Fill in the rest of dp table
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])

        return dp[m - 1][n - 1]
```

:::

# ‚è±Ô∏è Time & Space Complexity

| Complexity Type | Big-O         | Explanation                               |
|-----------------|---------------|-------------------------------------------|
| **Time**        | `O(m √ó n)`    | Each cell in the `m √ó n` grid is visited exactly once |
| **Space**       | `O(m √ó n)`    | A separate `dp` table of size `m √ó n` is used |

### Notes:
- If you overwrite the input `grid` in-place, the extra space can be reduced to `O(1)`.
- If you only keep one row or column at a time, the space can also be optimized to `O(n)`.