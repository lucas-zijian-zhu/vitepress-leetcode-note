# [221. Maximal Square](https://leetcode.com/problems/maximal-square/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

Given an <code>m x n</code> binary <code>matrix</code> filled with <code>0</code>'s and <code>1</code>'s, find the largest square containing only <code>1</code>'s and return its area.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" style="width: 400px; height: 319px;">

```
Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 4
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg" style="width: 165px; height: 165px;">

```
Input: matrix = [["0","1"],["1","0"]]
Output: 1
```

**Example 3:** 

```
Input: matrix = [["0"]]
Output: 0
```

**Constraints:** 

- <code>m == matrix.length</code>
- <code>n == matrix[i].length</code>
- <code>1 <= m, n <= 300</code>
- <code>matrix[i][j]</code> is <code>'0'</code> or <code>'1'</code>.

## üöÄ Approach: Dynamic Programming

We use a `dp` table where `dp[i][j]` represents the **side length of the largest square**  
whose bottom-right corner is at `(i, j)`.

### State Transition

If `matrix[i][j] == '1'`, then:
- We can extend the square only if the top, left, and top-left cells also form a square.

```
Formula:
dp[i][j] = min(
‚ÄÉ‚ÄÉdp[i-1][j],      // top  
‚ÄÉ‚ÄÉdp[i][j-1],      // left  
‚ÄÉ‚ÄÉdp[i-1][j-1]     // top-left  
) + 1
```

If `matrix[i][j] == '0'`, then `dp[i][j] = 0`.

## üìù Base Case

On the first row or column, `dp[i][j] = 1` if `matrix[i][j] == '1'`.

## üéØ Final Answer

The area of the largest square is the square of the maximum value in `dp`.


## Code

::: code-group

```typescript [TypeScript]
class Solution {
    maximalSquare(matrix: string[][]): number {
        if (matrix.length === 0 || matrix[0].length === 0) return 0;
        const m = matrix.length;
        const n = matrix[0].length;
        const dp = Array(m).fill(null).map(() => Array(n).fill(0));

        let maxSide = 0;

        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                if (matrix[i][j] === '1') {
                    dp[i][j] = (i === 0 || j === 0) ? 1 : 
                        Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1;
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }

        return maxSide * maxSide;
    }
}
```

```kotlin [Kotlin]
class Solution {
    fun maximalSquare(matrix: Array<CharArray>): Int {
        if (matrix.isEmpty() || matrix[0].isEmpty()) return 0
        val m = matrix.size
        val n = matrix[0].size
        val dp = Array(m) { IntArray(n) }

        var maxSide = 0

        for (i in 0 until m) {
            for (j in 0 until n) {
                if (matrix[i][j] == '1') {
                    dp[i][j] = if (i == 0 || j == 0) {
                        1
                    } else {
                        minOf(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                    }
                    maxSide = maxOf(maxSide, dp[i][j])
                }
            }
        }

        return maxSide * maxSide
    }
}
```

```java [Java]
class Solution {
    public int maximalSquare(char[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) return 0;
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] dp = new int[m][n];

        int maxSide = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    dp[i][j] = (i == 0 || j == 0) ? 1 : 
                        Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }

        return maxSide * maxSide;
    }
}
```

```swift [Swift]
class Solution {
    func maximalSquare(_ matrix: [[Character]]) -> Int {
        guard !matrix.isEmpty, !matrix[0].isEmpty else { return 0 }
        let m = matrix.count
        let n = matrix[0].count
        var dp = Array(repeating: Array(repeating: 0, count: n), count: m)
        var maxSide = 0
        for i in 0..<m {
            for j in 0..<n where matrix[i][j] == "1" {
                dp[i][j] = (i == 0 || j == 0) ? 1 : min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                maxSide = max(maxSide, dp[i][j])
            }
        }
        return maxSide * maxSide
    }
}
```

```python [Python]
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0] * n for _ in range(m)]

        max_side = 0

        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    dp[i][j] = 1 if (i == 0 or j == 0) else \
                        min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                    max_side = max(max_side, dp[i][j])

        return max_side * max_side
```

:::
## ‚è≥ Complexity

| Metric   | Value |
|----------|-------|
| **Time** | O(m √ó n) ‚Äî We iterate over each cell of the matrix exactly once. |
| **Space** | O(m √ó n) ‚Äî for the `dp` table. |
|          | Can be optimized to O(n) ‚Äî by reusing one row at a time. |