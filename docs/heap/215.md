# [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>k^th</code> largest element in the array.

Note that it is the <code>k^th</code> largest element in the sorted order, not the <code>k^th</code> distinct element.

Can you solve it without sorting?

**Example 1:**

```
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
```

**Example 2:**

```
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
```

**Constraints:**

- <code>1 <= k <= nums.length <= 10^5</code>
- <code>-10^4 <= nums[i] <= 10^4</code>

## ðŸš€ Approach: Min Heap (Priority Queue)

### Intuition

This problem can be solved efficiently using a **Min Heap** (Priority Queue). The key insight is to maintain a heap of size `k` that contains the k largest elements seen so far.

**Key Insight:** 
- Use a min heap of size `k`
- The root of the heap will always be the kth largest element
- When heap size > k, remove the smallest element
- After processing all elements, the root contains the kth largest element

### Algorithm

1. **Create a min heap** with capacity `k`
2. **Iterate through the array**:
   - Add current element to heap
   - If heap size > k, remove the minimum element
3. **Return the root** of the heap (kth largest element)

**Alternative Approach - Quick Select:**
- Uses partitioning logic from Quick Sort
- Average O(n) time complexity, but O(nÂ²) worst case

---

## Code

### Method 1: Min Heap (Recommended)

::: code-group

```kotlin [Kotlin]
import java.util.PriorityQueue

class Solution {
    fun findKthLargest(nums: IntArray, k: Int): Int {
        val minHeap = PriorityQueue<Int>()
        
        for (num in nums) {
            minHeap.offer(num)
            if (minHeap.size > k) {
                minHeap.poll() // Remove the smallest element
            }
        }
        
        return minHeap.peek() // The root is the kth largest
    }
}
```

```typescript [TypeScript]
function findKthLargest(nums: number[], k: number): number {
    const minHeap = new MinPriorityQueue();
    
    for (const num of nums) {
        minHeap.enqueue(num);
        if (minHeap.size() > k) {
            minHeap.dequeue(); // Remove the smallest element
        }
    }
    
    return minHeap.front().element; // The root is the kth largest
}
```

```java [Java]
import java.util.PriorityQueue;

class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        
        for (int num : nums) {
            minHeap.offer(num);
            if (minHeap.size() > k) {
                minHeap.poll(); // Remove the smallest element
            }
        }
        
        return minHeap.peek(); // The root is the kth largest
    }
}
```

```swift [Swift]
class Solution {
    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {
        var heap = MinHeap()

        for num in nums {
            heap.push(num)
            if heap.count > k {
                _ = heap.pop()
            }
        }

        return heap.peek() ?? 0
    }
}

private struct MinHeap {
    private var data: [Int] = []

    var count: Int { data.count }

    mutating func push(_ value: Int) {
        data.append(value)
        siftUp(from: data.count - 1)
    }

    mutating func pop() -> Int? {
        guard !data.isEmpty else { return nil }
        data.swapAt(0, data.count - 1)
        let value = data.removeLast()
        siftDown(from: 0)
        return value
    }

    func peek() -> Int? {
        data.first
    }

    private mutating func siftUp(from index: Int) {
        var child = index
        while child > 0 {
            let parent = (child - 1) / 2
            if data[child] < data[parent] {
                data.swapAt(child, parent)
                child = parent
            } else {
                break
            }
        }
    }

    private mutating func siftDown(from index: Int) {
        var parent = index
        while true {
            let left = parent * 2 + 1
            let right = left + 1
            var smallest = parent

            if left < data.count && data[left] < data[smallest] {
                smallest = left
            }
            if right < data.count && data[right] < data[smallest] {
                smallest = right
            }
            if smallest == parent {
                break
            }

            data.swapAt(parent, smallest)
            parent = smallest
        }
    }
}
```

```python [Python]
import heapq

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        min_heap = []
        
        for num in nums:
            heapq.heappush(min_heap, num)
            if len(min_heap) > k:
                heapq.heappop(min_heap)  # Remove the smallest element
        
        return min_heap[0]  # The root is the kth largest
```

:::

### Method 2: Quick Select (Alternative)

::: code-group

```kotlin [Kotlin]
class Solution {
    fun findKthLargest(nums: IntArray, k: Int): Int {
        return quickSelect(nums, 0, nums.size - 1, k)
    }
    
    private fun quickSelect(nums: IntArray, left: Int, right: Int, k: Int): Int {
        if (left == right) return nums[left]
        
        val pivotIndex = partition(nums, left, right)
        
        return when {
            pivotIndex == k - 1 -> nums[pivotIndex]
            pivotIndex < k - 1 -> quickSelect(nums, pivotIndex + 1, right, k)
            else -> quickSelect(nums, left, pivotIndex - 1, k)
        }
    }
    
    private fun partition(nums: IntArray, left: Int, right: Int): Int {
        val pivot = nums[right]
        var i = left
        
        for (j in left until right) {
            if (nums[j] >= pivot) {
                swap(nums, i, j)
                i++
            }
        }
        swap(nums, i, right)
        return i
    }
    
    private fun swap(nums: IntArray, i: Int, j: Int) {
        val temp = nums[i]
        nums[i] = nums[j]
        nums[j] = temp
    }
}
```

```typescript [TypeScript]
function findKthLargest(nums: number[], k: number): number {
    return quickSelect(nums, 0, nums.length - 1, k);
}

function quickSelect(nums: number[], left: number, right: number, k: number): number {
    if (left === right) return nums[left];
    
    const pivotIndex = partition(nums, left, right);
    
    if (pivotIndex === k - 1) {
        return nums[pivotIndex];
    } else if (pivotIndex < k - 1) {
        return quickSelect(nums, pivotIndex + 1, right, k);
    } else {
        return quickSelect(nums, left, pivotIndex - 1, k);
    }
}

function partition(nums: number[], left: number, right: number): number {
    const pivot = nums[right];
    let i = left;
    
    for (let j = left; j < right; j++) {
        if (nums[j] >= pivot) {
            [nums[i], nums[j]] = [nums[j], nums[i]];
            i++;
        }
    }
    [nums[i], nums[right]] = [nums[right], nums[i]];
    return i;
}
```

```java [Java]
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length - 1, k);
    }
    
    private int quickSelect(int[] nums, int left, int right, int k) {
        if (left == right) return nums[left];
        
        int pivotIndex = partition(nums, left, right);
        
        if (pivotIndex == k - 1) {
            return nums[pivotIndex];
        } else if (pivotIndex < k - 1) {
            return quickSelect(nums, pivotIndex + 1, right, k);
        } else {
            return quickSelect(nums, left, pivotIndex - 1, k);
        }
    }
    
    private int partition(int[] nums, int left, int right) {
        int pivot = nums[right];
        int i = left;
        
        for (int j = left; j < right; j++) {
            if (nums[j] >= pivot) {
                swap(nums, i, j);
                i++;
            }
        }
        swap(nums, i, right);
        return i;
    }
    
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

```swift [Swift]
class Solution {
    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {
        var arr = nums
        return quickSelect(&arr, 0, arr.count - 1, k)
    }

    private func quickSelect(_ nums: inout [Int], _ left: Int, _ right: Int, _ k: Int) -> Int {
        if left == right {
            return nums[left]
        }

        let pivotIndex = partition(&nums, left, right)
        if pivotIndex == k - 1 {
            return nums[pivotIndex]
        } else if pivotIndex < k - 1 {
            return quickSelect(&nums, pivotIndex + 1, right, k)
        } else {
            return quickSelect(&nums, left, pivotIndex - 1, k)
        }
    }

    private func partition(_ nums: inout [Int], _ left: Int, _ right: Int) -> Int {
        let pivot = nums[right]
        var i = left

        for j in left..<right {
            if nums[j] >= pivot {
                nums.swapAt(i, j)
                i += 1
            }
        }

        nums.swapAt(i, right)
        return i
    }
}
```

```python [Python]
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return self.quick_select(nums, 0, len(nums) - 1, k)
    
    def quick_select(self, nums: List[int], left: int, right: int, k: int) -> int:
        if left == right:
            return nums[left]
        
        pivot_index = self.partition(nums, left, right)
        
        if pivot_index == k - 1:
            return nums[pivot_index]
        elif pivot_index < k - 1:
            return self.quick_select(nums, pivot_index + 1, right, k)
        else:
            return self.quick_select(nums, left, pivot_index - 1, k)
    
    def partition(self, nums: List[int], left: int, right: int) -> int:
        pivot = nums[right]
        i = left
        
        for j in range(left, right):
            if nums[j] >= pivot:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        
        nums[i], nums[right] = nums[right], nums[i]
        return i
```

:::

## Complexity

### Method 1: Min Heap
- **Time Complexity:** O(n log k), where n is the array size and k is the kth largest position
- **Space Complexity:** O(k) for the heap

### Method 2: Quick Select  
- **Time Complexity:** O(n) average case, O(nÂ²) worst case
- **Space Complexity:** O(log n) for the recursion stack in average case, O(n) in worst case