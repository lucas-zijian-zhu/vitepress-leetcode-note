# [373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

You are given two integer arrays <code>nums1</code> and <code>nums2</code> sorted in **non-decreasingorder**  and an integer <code>k</code>.

Define a pair <code>(u, v)</code> which consists of one element from the first array and one element from the second array.

Return the <code>k</code> pairs <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> with the smallest sums.

**Example 1:** 

```
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

**Example 2:** 

```
Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [[1,1],[1,1]]
Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```

**Constraints:** 

- <code>1 <= nums1.length, nums2.length <= 10^5</code>
- <code>-10^9 <= nums1[i], nums2[i] <= 10^9</code>
- <code>nums1</code> and <code>nums2</code> both are sorted in **non-decreasing order** .
- <code>1 <= k <= 10^4</code>
- <code>k <=nums1.length *nums2.length</code>

## ðŸ’¡ Approach: Min Heap (Priority Queue)

### Intuition

Since both arrays are sorted, we can use a **min heap** to efficiently find the k pairs with smallest sums. The key insight is to process pairs incrementally:

1. Start with pairs of `nums1[0]` with all elements of `nums2`
2. Use a min heap to always get the pair with the smallest sum
3. When we extract a pair `(i, j)`, add the next potential pair `(i+1, j)` to the heap
4. Repeat k times

**Key Insight:**
- We don't need to generate all pairs upfront (would be O(m*n))
- Instead, we generate pairs on-demand using a heap
- This reduces time complexity significantly

### Algorithm

1. **Initialize a min heap** with pairs `(sum, i, j)` where `i` is index in `nums1` and `j` is index in `nums2`
2. **Start with all pairs** of `nums1[0]` with elements from `nums2`: `(nums1[0] + nums2[j], 0, j)` for all `j`
3. **Extract k times:**
   - Pop the smallest sum pair from heap
   - Add to result
   - If `i+1 < nums1.length`, push `(nums1[i+1] + nums2[j], i+1, j)` to heap
4. **Return the result**

### Key Points

- Use min heap to always get the smallest sum pair
- Only process pairs incrementally, not all at once
- Avoid duplicates by tracking indices carefully
- Time complexity: O(k log k) if k is small compared to m*n

## Code

::: code-group

```kotlin [Kotlin]
import java.util.PriorityQueue

class Solution {
    fun kSmallestPairs(nums1: IntArray, nums2: IntArray, k: Int): List<List<Int>> {
        val result = mutableListOf<List<Int>>()
        val heap = PriorityQueue<IntArray> { a, b -> a[0] - b[0] }
        
        // Initialize: add all pairs with nums1[0]
        for (j in nums2.indices) {
            heap.offer(intArrayOf(nums1[0] + nums2[j], 0, j))
        }
        
        // Extract k smallest pairs
        repeat(k) {
            if (heap.isEmpty()) return@repeat
            
            val current = heap.poll()
            val i = current[1]
            val j = current[2]
            
            result.add(listOf(nums1[i], nums2[j]))
            
            // Add next pair from nums1 if available
            if (i + 1 < nums1.size) {
                heap.offer(intArrayOf(nums1[i + 1] + nums2[j], i + 1, j))
            }
        }
        
        return result
    }
}
```

```typescript [TypeScript]
function kSmallestPairs(nums1: number[], nums2: number[], k: number): number[][] {
    const result: number[][] = [];
    const heap = new MinPriorityQueue({ priority: (pair: [number, number, number]) => pair[0] });
    
    // Initialize: add all pairs with nums1[0]
    for (let j = 0; j < nums2.length; j++) {
        heap.enqueue([nums1[0] + nums2[j], 0, j]);
    }
    
    // Extract k smallest pairs
    for (let count = 0; count < k && !heap.isEmpty(); count++) {
        const [sum, i, j] = heap.dequeue().element;
        result.push([nums1[i], nums2[j]]);
        
        // Add next pair from nums1 if available
        if (i + 1 < nums1.length) {
            heap.enqueue([nums1[i + 1] + nums2[j], i + 1, j]);
        }
    }
    
    return result;
}
```

```java [Java]
import java.util.*;

class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<List<Integer>> result = new ArrayList<>();
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        
        // Initialize: add all pairs with nums1[0]
        for (int j = 0; j < nums2.length; j++) {
            heap.offer(new int[]{nums1[0] + nums2[j], 0, j});
        }
        
        // Extract k smallest pairs
        for (int count = 0; count < k && !heap.isEmpty(); count++) {
            int[] current = heap.poll();
            int i = current[1];
            int j = current[2];
            
            result.add(Arrays.asList(nums1[i], nums2[j]));
            
            // Add next pair from nums1 if available
            if (i + 1 < nums1.length) {
                heap.offer(new int[]{nums1[i + 1] + nums2[j], i + 1, j});
            }
        }
        
        return result;
    }
}
```

```swift [Swift]
class Solution {
    func kSmallestPairs(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [[Int]] {
        guard !nums1.isEmpty, !nums2.isEmpty, k > 0 else { return [] }

        var heap = PairMinHeap()
        var result: [[Int]] = []

        for j in 0..<min(nums2.count, k) {
            let sum = nums1[0] + nums2[j]
            heap.push(Pair(sum: sum, i: 0, j: j))
        }

        while result.count < k, let top = heap.pop() {
            result.append([nums1[top.i], nums2[top.j]])

            let nextI = top.i + 1
            if nextI < nums1.count {
                let sum = nums1[nextI] + nums2[top.j]
                heap.push(Pair(sum: sum, i: nextI, j: top.j))
            }
        }

        return result
    }
}

private struct Pair: Comparable {
    let sum: Int
    let i: Int
    let j: Int

    static func < (lhs: Pair, rhs: Pair) -> Bool {
        lhs.sum < rhs.sum
    }
}

private struct PairMinHeap {
    private var data: [Pair] = []

    var isEmpty: Bool { data.isEmpty }

    mutating func push(_ value: Pair) {
        data.append(value)
        siftUp(from: data.count - 1)
    }

    mutating func pop() -> Pair? {
        guard !data.isEmpty else { return nil }
        data.swapAt(0, data.count - 1)
        let value = data.removeLast()
        siftDown(from: 0)
        return value
    }

    private mutating func siftUp(from index: Int) {
        var child = index
        while child > 0 {
            let parent = (child - 1) / 2
            if data[child] < data[parent] {
                data.swapAt(child, parent)
                child = parent
            } else {
                break
            }
        }
    }

    private mutating func siftDown(from index: Int) {
        var parent = index
        while true {
            let left = parent * 2 + 1
            let right = left + 1
            var smallest = parent

            if left < data.count && data[left] < data[smallest] {
                smallest = left
            }
            if right < data.count && data[right] < data[smallest] {
                smallest = right
            }
            if smallest == parent {
                break
            }

            data.swapAt(parent, smallest)
            parent = smallest
        }
    }
}
```

```python [Python]
import heapq

class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        result = []
        heap = []
        
        # Initialize: add all pairs with nums1[0]
        for j in range(len(nums2)):
            heapq.heappush(heap, (nums1[0] + nums2[j], 0, j))
        
        # Extract k smallest pairs
        for _ in range(k):
            if not heap:
                break
            
            sum_val, i, j = heapq.heappop(heap)
            result.append([nums1[i], nums2[j]])
            
            # Add next pair from nums1 if available
            if i + 1 < len(nums1):
                heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))
        
        return result
```

:::

## Complexity

- **Time Complexity:** O(k log k), where k is the number of pairs we need and k â‰¤ m*n. We process k pairs, each heap operation is O(log k).
- **Space Complexity:** O(k), for the heap storing at most k elements