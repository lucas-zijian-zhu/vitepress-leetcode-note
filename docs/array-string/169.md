# [169. Majority Element](https://leetcode.com/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150)

Given an array <code>nums</code> of size <code>n</code>, return the majority element.

The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.

**Example 1:** 

```
Input: nums = [3,2,3]
Output: 3
```

**Example 2:** 

```
Input: nums = [2,2,1,1,1,2,2]
Output: 2
```

**Constraints:** 

- <code>n == nums.length</code>
- <code>1 <= n <= 5 * 10^4</code>
- <code>-10^9 <= nums[i] <= 10^9</code>

**Follow-up:**  Could you solve the problem in linear time and in <code>O(1)</code> space?

## Approach — Boyer-Moore Voting Algorithm
- The array is traversed only once.
- Maintain:
  - A candidate for the majority element.
  - A counter for the candidate.
- Initially, the counter is `0`.
- For each number in the array:
  - If the counter is `0`, set the current number as the candidate.
  - If the current number equals the candidate, increment the counter.
  - Otherwise, decrement the counter.
- After one pass, the candidate is guaranteed to be the majority element.

---

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun majorityElement(nums: IntArray): Int {
        var count = 0
        var candidate = 0

        for (num in nums) {
            if (count == 0) {
                candidate = num
            }

            if (num == candidate) {
                count++
            } else {
                count--
            }
        }

        return candidate
    }
}
```

```typescript [TypeScript]
function majorityElement(nums: number[]): number {
    let count = 0;
    let candidate = 0;

    for (const num of nums) {
        if (count === 0) {
            candidate = num;
        }

        if (num === candidate) {
            count++;
        } else {
            count--;
        }
    }

    return candidate;
}
```

```java [Java]
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        int candidate = 0;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }

            if (num == candidate) {
                count++;
            } else {
                count--;
            }
        }

        return candidate;
    }
}
```

```python [Python]
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = 0

        for num in nums:
            if count == 0:
                candidate = num

            if num == candidate:
                count += 1
            else:
                count -= 1

        return candidate
```

:::

## Complexity Analysis

| Type               | Complexity     |
|--------------------|----------------|
| **Time Complexity** | `O(n)` |
| **Space Complexity** | `O(1)` |

### Explanation:
- **Time Complexity:**  
We iterate through the entire array exactly once to determine the majority element → linear time, `O(n)`.

- **Space Complexity:**  
We only use two extra variables (`count` and `candidate`) regardless of input size → constant space, `O(1)`.