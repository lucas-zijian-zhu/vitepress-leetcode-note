# [406. Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

You are given an array of people, <code>people</code>, which are the attributes of some people in a queue (not necessarily in order). Each <code>people[i] = [h<sub>i</sub>, k<sub>i</sub>]</code> represents the <code>i<sup>th</sup></code> person of height <code>h<sub>i</sub></code> with exactly <code>k<sub>i</sub></code> other people in front who have a height greater than or equal to <code>h<sub>i</sub></code>.

Reconstruct and return the queue that is represented by the input array <code>people</code>. The returned queue should be formatted as an array <code>queue</code>, where <code>queue[j] = [h<sub>j</sub>, k<sub>j</sub>]</code> is the attributes of the <code>j<sup>th</sup></code> person in the queue (<code>queue[0]</code> is the person at the front of the queue).

**Example 1:**

```
Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
Explanation:
Person 0 has height 5 with no one taller or the same height in front.
Person 1 has height 7 with no one taller or the same height in front.
Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
Person 3 has height 6 with one person taller or the same height in front, which is person 1.
Person 4 has height 4 with four people taller or the same height in front, which are persons 0, 1, 2, and 3.
Person 5 has height 7 with one person taller or the same height in front, which is person 1.
Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.
```

**Example 2:**

```
Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

**Constraints:**

- <code>1 <= people.length <= 2000</code>
- <code>0 <= h<sub>i</sub> <= 10<sup>6</sup></code>
- <code>0 <= k<sub>i</sub> < people.length</code>
- It is guaranteed that the queue can be reconstructed.

## ðŸ’¡ Approach: Greedy with Sorting

### Intuition

Sort people by height in descending order, and for people with the same height, sort by k in ascending order. Then insert each person at position k in the result list.

**Key Insight:**
- Taller people don't care about shorter people in front of them
- By processing taller people first, we can insert shorter people at the correct position (their k value) without affecting taller people's positions

### Algorithm

1. **Sort** people: descending by height, ascending by k for same height
2. **Insert** each person at index `k` in the result list
3. The insertion automatically maintains the correct order because taller people are already placed

### Key Points

- Processing taller people first ensures shorter people can be inserted at their k position without affecting taller people
- Using list insertion (like `list.add(index, element)`) maintains the relative order

## Code

:::: code-group

```typescript [TypeScript]
function reconstructQueue(people: number[][]): number[][] {
    people.sort((a, b) => {
        if (a[0] !== b[0]) {
            return b[0] - a[0]; // descending by height
        }
        return a[1] - b[1]; // ascending by k
    });
    
    const result: number[][] = [];
    for (const person of people) {
        result.splice(person[1], 0, person);
    }
    
    return result;
}
```

```kotlin [Kotlin]
class Solution {
    fun reconstructQueue(people: Array<IntArray>): Array<IntArray> {
        people.sortWith(compareBy<IntArray> { -it[0] }.thenBy { it[1] })
        
        val result = mutableListOf<IntArray>()
        for (person in people) {
            result.add(person[1], person)
        }
        
        return result.toTypedArray()
    }
}
```

```java [Java]
import java.util.*;

class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(b[0], a[0]); // descending by height
            }
            return Integer.compare(a[1], b[1]); // ascending by k
        });
        
        List<int[]> result = new ArrayList<>();
        for (int[] person : people) {
            result.add(person[1], person);
        }
        
        return result.toArray(new int[result.size()][]);
    }
}
```

```swift [Swift]
class Solution {
    func reconstructQueue(_ people: [[Int]]) -> [[Int]] {
        let sorted = people.sorted {
            if $0[0] == $1[0] {
                return $0[1] < $1[1]
            }
            return $0[0] > $1[0]
        }

        var result: [[Int]] = []
        for person in sorted {
            let index = person[1]
            if index <= result.count {
                result.insert(person, at: index)
            }
        }

        return result
    }
}
```

```python [Python]
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (-x[0], x[1]))
        
        result = []
        for person in people:
            result.insert(person[1], person)
        
        return result
```

::::
## Complexity

- **Time Complexity:** O(nÂ²), where n is the number of people. Sorting is O(n log n), but each insertion can be O(n) in worst case.
- **Space Complexity:** O(n) for the result array.
