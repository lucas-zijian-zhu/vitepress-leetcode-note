# [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150)

Given an integer array <code>nums</code> sorted in **non-decreasing order** , remove some duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">**in-place** </a> such that each unique element appears **at most twice** . The **relative order**  of the elements should be kept the **same** .

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the **first part**  of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code>should hold the final result. It does not matter what you leave beyond the first<code>k</code>elements.

Return <code>k</code> after placing the final result in the first <code>k</code> slots of <code>nums</code>.

Do **not**  allocate extra space for another array. You must do this by **modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in-place</a>**  with O(1) extra memory.

**Custom Judge:** 

The judge will test your solution with the following code:

```
int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

If all assertions pass, then your solution will be **accepted** .

**Example 1:** 

```
Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

**Example 2:** 

```
Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

**Constraints:** 

- <code>1 <= nums.length <= 3 * 10^4</code>
- <code>-10^4 <= nums[i] <= 10^4</code>
- <code>nums</code> is sorted in **non-decreasing**  order.

## Approach
- Since the array is sorted, duplicates are adjacent.
- We want to keep **at most two occurrences** of each number.
- Use a pointer `index` to track the position to write the next valid element.
- Iterate from the third element onward and compare it with the element at `index - 2`.
  - If `nums[i] != nums[index-2]`, then it is valid to keep this number.

---

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun removeDuplicates(nums: IntArray): Int {
        if (nums.size <= 2) return nums.size

        var index = 2

        for (i in 2 until nums.size) {
            if (nums[i] != nums[index - 2]) {
                nums[index] = nums[i]
                index++
            }
        }

        return index
    }
}
```

```typescript [TypeScript]
function removeDuplicates(nums: number[]): number {
    if (nums.length <= 2) return nums.length;

    let index = 2;

    for (let i = 2; i < nums.length; i++) {
        if (nums[i] !== nums[index - 2]) {
            nums[index] = nums[i];
            index++;
        }
    }

    return index;
}
```

```java [Java]
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length <= 2) return nums.length;

        int index = 2;

        for (int i = 2; i < nums.length; i++) {
            if (nums[i] != nums[index - 2]) {
                nums[index] = nums[i];
                index++;
            }
        }

        return index;
    }
}
```

```python [Python]
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)

        index = 2

        for i in range(2, len(nums)):
            if nums[i] != nums[index - 2]:
                nums[index] = nums[i]
                index += 1

        return index
```

:::

## Complexity Analysis

| Type               | Complexity     |
|--------------------|----------------|
| **Time Complexity** | `O(n)` |
| **Space Complexity** | `O(1)` |

### Explanation:
- **Time Complexity:**  
We iterate through the array exactly once, performing constant work for each element → linear time, **O(n)**.

- **Space Complexity:**  
We only use a few pointers (`index`, `i`), and modify the array in place without any extra data structures → constant space, **O(1)**.