# [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)

Given an integer array <code>nums</code>, find the <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1n:" data-state="closed" class="">subarray</button> with the largest sum, and return its sum.

**Example 1:** 

```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.
```

**Example 2:** 

```
Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.
```

**Example 3:** 

```
Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
```

**Constraints:** 

- <code>1 <= nums.length <= 10^5</code>
- <code>-10^4 <= nums[i] <= 10^4</code>

**Follow up:**  If you have figured out the <code>O(n)</code> solution, try coding another solution using the **divide and conquer**  approach, which is more subtle.

## ðŸ’¡ Approach: Kadane's Algorithm (Dynamic Programming)

### Intuition

This is a classic **dynamic programming** problem. The key insight is that at each position, we need to decide whether to:
1. **Start a new subarray** from the current element
2. **Extend the existing subarray** by including the current element

### Strategy

Use **Kadane's Algorithm**:
- Keep track of the **maximum sum ending at current position**
- Keep track of the **global maximum sum** seen so far
- At each element, decide whether to start fresh or extend the previous subarray

### Algorithm Steps

1. **Initialize**: `maxSoFar = nums[0]`, `maxEndingHere = nums[0]`
2. **For each element** from index 1:
   - `maxEndingHere = max(nums[i], maxEndingHere + nums[i])`
   - `maxSoFar = max(maxSoFar, maxEndingHere)`
3. **Return** `maxSoFar`

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun maxSubArray(nums: IntArray): Int {
        var maxSoFar = nums[0]
        var maxEndingHere = nums[0]
        
        for (i in 1 until nums.size) {
            // Either start new subarray or extend existing one
            maxEndingHere = maxOf(nums[i], maxEndingHere + nums[i])
            // Update global maximum
            maxSoFar = maxOf(maxSoFar, maxEndingHere)
        }
        
        return maxSoFar
    }
}
```

```typescript [TypeScript]
function maxSubArray(nums: number[]): number {
    let maxSoFar = nums[0];
    let maxEndingHere = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        // Either start new subarray or extend existing one
        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
        // Update global maximum
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }
    
    return maxSoFar;
}
```

```java [Java]
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSoFar = nums[0];
        int maxEndingHere = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            // Either start new subarray or extend existing one
            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
            // Update global maximum
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
}
```

```python [Python]
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_so_far = nums[0]
        max_ending_here = nums[0]
        
        for i in range(1, len(nums)):
            # Either start new subarray or extend existing one
            max_ending_here = max(nums[i], max_ending_here + nums[i])
            # Update global maximum
            max_so_far = max(max_so_far, max_ending_here)
        
        return max_so_far
```

:::

## Complexity

- **Time Complexity:** O(N) where N is the length of the array
- **Space Complexity:** O(1) using only constant extra space