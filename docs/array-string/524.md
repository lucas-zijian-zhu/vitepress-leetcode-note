# [524. Longest Word in Dictionary through Deleting](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/) <Badge type="warning" text="Medium" />

Given a string <code>s</code> and a string array <code>dictionary</code>, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.

**Example 1:**

```
Input: s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]
Output: "apple"
```

**Example 2:**

```
Input: s = "abpcplea", dictionary = ["a","b","c"]
Output: "a"
```

**Constraints:**

- <code>1 <= s.length <= 1000</code>
- <code>1 <= dictionary.length <= 1000</code>
- <code>1 <= dictionary[i].length <= 1000</code>
- <code>s</code> and <code>dictionary[i]</code> consist of lowercase English letters.

## Approach: Two Pointers (Subsequence Check)

A word in the dictionary can be formed from <code>s</code> iff the word is a **subsequence** of <code>s</code> (characters appear in order, not necessarily consecutive).

1. For each word in the dictionary, check if it is a subsequence of <code>s</code> using two pointers: one on <code>s</code>, one on <code>word</code>. If all characters of <code>word</code> are matched in order in <code>s</code>, the word is valid.
2. Among valid words, keep the one that is longest; if tied, keep the lexicographically smallest (e.g. compare with current best when updating).

**Optional:** Sort <code>dictionary</code> by length descending, then lexicographically ascending. Then the first word that is a subsequence of <code>s</code> is the answer (early exit).

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun findLongestWord(s: String, dictionary: List<String>): String {
        var result = ""
        for (word in dictionary) {
            if (!isSubsequence(s, word)) continue
            if (word.length > result.length || (word.length == result.length && word < result)) {
                result = word
            }
        }
        return result
    }

    private fun isSubsequence(s: String, word: String): Boolean {
        var j = 0
        for (c in s) {
            if (j < word.length && word[j] == c) j++
        }
        return j == word.length
    }
}
```

```typescript [TypeScript]
function findLongestWord(s: string, dictionary: string[]): string {
    let result = "";
    for (const word of dictionary) {
        if (!isSubsequence(s, word)) continue;
        if (word.length > result.length || (word.length === result.length && word < result)) {
            result = word;
        }
    }
    return result;
}

function isSubsequence(s: string, word: string): boolean {
    let j = 0;
    for (let i = 0; i < s.length && j < word.length; i++) {
        if (s[i] === word[j]) j++;
    }
    return j === word.length;
}
```

```java [Java]
class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        String result = "";
        for (String word : dictionary) {
            if (!isSubsequence(s, word)) continue;
            if (word.length() > result.length() || (word.length() == result.length() && word.compareTo(result) < 0)) {
                result = word;
            }
        }
        return result;
    }

    private boolean isSubsequence(String s, String word) {
        int j = 0;
        for (int i = 0; i < s.length() && j < word.length(); i++) {
            if (s.charAt(i) == word.charAt(j)) j++;
        }
        return j == word.length();
    }
}
```

```swift [Swift]
class Solution {
    func findLongestWord(_ s: String, _ dictionary: [String]) -> String {
        var best = ""
        let source = Array(s)

        for word in dictionary {
            if isSubsequence(word, source) {
                if word.count > best.count || (word.count == best.count && word < best) {
                    best = word
                }
            }
        }

        return best
    }

    private func isSubsequence(_ word: String, _ source: [Character]) -> Bool {
        let target = Array(word)
        var i = 0
        for ch in source {
            if i < target.count && ch == target[i] {
                i += 1
            }
        }
        return i == target.count
    }
}
```

```python [Python]
class Solution:
    def findLongestWord(self, s: str, dictionary: list[str]) -> str:
        result = ""
        for word in dictionary:
            if not self._is_subsequence(s, word):
                continue
            if len(word) > len(result) or (len(word) == len(result) and word < result):
                result = word
        return result

    def _is_subsequence(self, s: str, word: str) -> bool:
        j = 0
        for c in s:
            if j < len(word) and word[j] == c:
                j += 1
        return j == len(word)
```

:::

## Complexity

- **Time Complexity:** O(n 路 m + n 路 k), where n = |s|, m = total length of dictionary words, k = |dictionary| (or O(n 路 k 路 L) with L = max word length).
- **Space Complexity:** O(1) excluding input.
