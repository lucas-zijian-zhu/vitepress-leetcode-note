# [665. Non-decreasing Array](https://leetcode.com/problems/non-decreasing-array/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given an array <code>nums</code> with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying **at most one element**.

We define an array is non-decreasing if <code>nums[i] <= nums[i + 1]</code> holds for every <code>i</code> (0-based) such that (<code>0 <= i <= n - 2</code>).

**Example 1:**

```
Input: nums = [4,2,3]
Output: true
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
```

**Example 2:**

```
Input: nums = [4,2,1]
Output: false
Explanation: You can't get a non-decreasing array by modifying at most one element.
```

**Constraints:**

- <code>n == nums.length</code>
- <code>1 <= n <= 10^4</code>
- <code>-10^5 <= nums[i] <= 10^5</code>

## ðŸ’¡ Approach: Greedy with One Pass

### Intuition

When we encounter a violation (nums[i] > nums[i+1]), we have two options:
1. Lower nums[i] to nums[i+1]
2. Raise nums[i+1] to nums[i]

We should choose the option that doesn't create a new violation. The key is to check if modifying nums[i] would break the relationship with nums[i-1].

### Algorithm

1. Track a count of modifications needed.
2. For each violation (nums[i] > nums[i+1]):
   - If we can lower nums[i] (i == 0 or nums[i-1] <= nums[i+1]), do it.
   - Otherwise, raise nums[i+1] to nums[i].
3. If count > 1, return false.

### Key Points

- Prefer lowering nums[i] when possible (less impact on future elements)
- Only raise nums[i+1] when lowering nums[i] would create a new violation
- Early exit if we need more than one modification

## Code

:::: code-group

```kotlin [Kotlin]
class Solution {
    fun checkPossibility(nums: IntArray): Boolean {
        var modified = false
        
        for (i in 0 until nums.size - 1) {
            if (nums[i] > nums[i + 1]) {
                if (modified) return false
                
                if (i == 0 || nums[i - 1] <= nums[i + 1]) {
                    nums[i] = nums[i + 1]
                } else {
                    nums[i + 1] = nums[i]
                }
                modified = true
            }
        }
        
        return true
    }
}
```

```typescript [TypeScript]
function checkPossibility(nums: number[]): boolean {
    let modified = false;
    
    for (let i = 0; i < nums.length - 1; i++) {
        if (nums[i] > nums[i + 1]) {
            if (modified) return false;
            
            if (i === 0 || nums[i - 1] <= nums[i + 1]) {
                nums[i] = nums[i + 1];
            } else {
                nums[i + 1] = nums[i];
            }
            modified = true;
        }
    }
    
    return true;
}
```

```java [Java]
class Solution {
    public boolean checkPossibility(int[] nums) {
        boolean modified = false;
        
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] > nums[i + 1]) {
                if (modified) return false;
                
                if (i == 0 || nums[i - 1] <= nums[i + 1]) {
                    nums[i] = nums[i + 1];
                } else {
                    nums[i + 1] = nums[i];
                }
                modified = true;
            }
        }
        
        return true;
    }
}
```

```python [Python]
class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        modified = False
        
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                if modified:
                    return False
                
                if i == 0 or nums[i - 1] <= nums[i + 1]:
                    nums[i] = nums[i + 1]
                else:
                    nums[i + 1] = nums[i]
                modified = True
        
        return True
```

::::

## Complexity

- **Time Complexity:** O(n), single pass through the array.
- **Space Complexity:** O(1), only using a boolean flag.
