# [633. Sum of Square Numbers](https://leetcode.com/problems/sum-of-square-numbers/description/) <Badge type="info" text="Easy" />

Given a non-negative integer <code>c</code>, decide whether there are two integers <code>a</code> and <code>b</code> such that <code>a² + b² = c</code>.

**Example 1:**

```
Input: c = 5
Output: true
Explanation: 1 * 1 + 2 * 2 = 5
```

**Example 2:**

```
Input: c = 3
Output: false
```

**Constraints:**

- <code>0 <= c <= 2^31 - 1</code>

## Approach: Two Pointers (or Single Pointer)

1. **Bounds:** <code>a</code> and <code>b</code> must be in <code>[0, √c]</code>. Let <code>right = floor(√c)</code>, <code>left = 0</code>.
2. **Two pointers:** While <code>left <= right</code>, compute <code>sum = left² + right²</code>.
   - If <code>sum == c</code> → return <code>true</code>.
   - If <code>sum > c</code> → decrease <code>right</code>.
   - If <code>sum < c</code> → increase <code>left</code>.
3. If loop ends without a match, return <code>false</code>.

**Alternative:** Fix <code>a</code> from 0 to √c, check if <code>c - a²</code> is a perfect square (binary search or sqrt).

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun judgeSquareSum(c: Int): Boolean {
        var left = 0L
        var right = kotlin.math.sqrt(c.toDouble()).toLong()
        while (left <= right) {
            val sum = left * left + right * right
            when {
                sum == c.toLong() -> return true
                sum > c -> right--
                else -> left++
            }
        }
        return false
    }
}
```

```typescript [TypeScript]
function judgeSquareSum(c: number): boolean {
    let left = 0;
    let right = Math.floor(Math.sqrt(c));
    while (left <= right) {
        const sum = left * left + right * right;
        if (sum === c) return true;
        if (sum > c) right--;
        else left++;
    }
    return false;
}
```

```java [Java]
class Solution {
    public boolean judgeSquareSum(int c) {
        long left = 0;
        long right = (long) Math.sqrt(c);
        while (left <= right) {
            long sum = left * left + right * right;
            if (sum == c) return true;
            if (sum > c) right--;
            else left++;
        }
        return false;
    }
}
```

```swift [Swift]
class Solution {
    func judgeSquareSum(_ c: Int) -> Bool {
        var left = 0
        var right = Int(Double(c).squareRoot())

        while left <= right {
            let sum = left * left + right * right
            if sum == c {
                return true
            } else if sum < c {
                left += 1
            } else {
                right -= 1
            }
        }

        return false
    }
}
```

```python [Python]
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        left, right = 0, int(c ** 0.5)
        while left <= right:
            s = left * left + right * right
            if s == c:
                return True
            if s > c:
                right -= 1
            else:
                left += 1
        return False
```

:::

## Complexity

- **Time Complexity:** O(√c) — at most √c steps.
- **Space Complexity:** O(1).
