# [680. Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/description/) <Badge type="info" text="Easy" />

Given a string <code>s</code>, return <code>true</code> if the <code>s</code> can be palindrome after deleting **at most one** character from it.

**Example 1:**

```
Input: s = "aba"
Output: true
```

**Example 2:**

```
Input: s = "abca"
Output: true
Explanation: You could delete the character 'c'.
```

**Example 3:**

```
Input: s = "abc"
Output: false
```

**Constraints:**

- <code>1 <= s.length <= 10^5</code>
- <code>s</code> consists of lowercase English letters.

## Approach: Two Pointers + One Skip

1. Use two pointers <code>left</code> and <code>right</code> from both ends.
2. While <code>s[left] == s[right]</code>, move both inward.
3. On first mismatch, check if either <code>s[left+1..right]</code> or <code>s[left..right-1]</code> is a palindrome (i.e. try skipping the left char or the right char once).
4. If one of them is palindrome, return <code>true</code>; otherwise <code>false</code>.

Helper: <code>isPalindrome(s, i, j)</code> — check if <code>s[i..j]</code> is palindrome.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun validPalindrome(s: String): Boolean {
        var left = 0
        var right = s.length - 1
        while (left < right) {
            if (s[left] != s[right]) {
                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1)
            }
            left++
            right--
        }
        return true
    }

    private fun isPalindrome(s: String, i: Int, j: Int): Boolean {
        var l = i
        var r = j
        while (l < r) {
            if (s[l] != s[r]) return false
            l++
            r--
        }
        return true
    }
}
```

```typescript [TypeScript]
function validPalindrome(s: string): boolean {
    let left = 0, right = s.length - 1;
    while (left < right) {
        if (s[left] !== s[right]) {
            return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);
        }
        left++;
        right--;
    }
    return true;
}

function isPalindrome(s: string, i: number, j: number): boolean {
    while (i < j) {
        if (s[i] !== s[j]) return false;
        i++;
        j--;
    }
    return true;
}
```

```java [Java]
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }
        return true;
    }

    private boolean isPalindrome(String s, int i, int j) {
        while (i < j) {
            if (s.charAt(i) != s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }
}
```

```swift [Swift]
class Solution {
    func validPalindrome(_ s: String) -> Bool {
        let chars = Array(s)
        var left = 0
        var right = chars.count - 1

        while left < right {
            if chars[left] != chars[right] {
                return isPalindrome(chars, left + 1, right) || isPalindrome(chars, left, right - 1)
            }
            left += 1
            right -= 1
        }

        return true
    }

    private func isPalindrome(_ chars: [Character], _ left: Int, _ right: Int) -> Bool {
        var l = left
        var r = right
        while l < r {
            if chars[l] != chars[r] {
                return false
            }
            l += 1
            r -= 1
        }
        return true
    }
}
```

```python [Python]
class Solution:
    def validPalindrome(self, s: str) -> bool:
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] != s[right]:
                return self._is_palindrome(s, left + 1, right) or self._is_palindrome(s, left, right - 1)
            left += 1
            right -= 1
        return True

    def _is_palindrome(self, s: str, i: int, j: int) -> bool:
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True
```

:::

## Complexity

- **Time Complexity:** O(n) — at most two passes over the string.
- **Space Complexity:** O(1).
