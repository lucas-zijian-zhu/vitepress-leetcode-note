# [918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/description/)

Given a **circular integer array** <code>nums</code> of length <code>n</code>, return *the maximum possible sum of a non-empty **subarray** of* <code>nums</code>.

A **circular array** means the end of the array connects to the beginning of the array. Formally, the next element of <code>nums[i]</code> is <code>nums[(i + 1) % n]</code> and the previous element of <code>nums[i]</code> is <code>nums[(i - 1 + n) % n]</code>.

A **subarray** may only include each element of the fixed buffer <code>nums</code> at most once. Formally, for a subarray <code>nums[i], nums[i + 1], ..., nums[j]</code>, there does not exist <code>i <= k1, k2 <= j</code> with <code>k1 % n == k2 % n</code>.

**Example 1:** 

```
Input: nums = [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3.
```

**Example 2:** 

```
Input: nums = [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.
```

**Example 3:** 

```
Input: nums = [-3,-2,-3]
Output: -2
Explanation: Subarray [-2] has maximum sum -2.
```

**Constraints:** 

- <code>n == nums.length</code>
- <code>1 <= n <= 3 * 10^4</code>
- <code>-3 * 10^4 <= nums[i] <= 3 * 10^4</code>

## ðŸ’¡ Approach: Kadane's Algorithm with Circular Array Handling

### Intuition

This is an extension of the **Maximum Subarray** problem (LeetCode 53) but with a **circular array**. The key insight is that the maximum sum can occur in two cases:

1. **Normal case**: Maximum subarray doesn't wrap around (same as regular Kadane's)
2. **Circular case**: Maximum subarray wraps around the array

### Strategy

For the circular case, we can use a clever observation:
- **Maximum circular sum** = **Total sum** - **Minimum subarray sum**
- This works because if we remove the minimum subarray, we get the maximum circular subarray

### Algorithm Steps

1. **Find maximum subarray sum** using Kadane's algorithm (normal case)
2. **Find minimum subarray sum** using modified Kadane's algorithm
3. **Calculate total sum** of the array
4. **Return** `max(maxSum, totalSum - minSum)` with edge case handling

**Edge case**: If all elements are negative, return the maximum single element.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun maxSubarraySumCircular(nums: IntArray): Int {
        var maxSum = nums[0]
        var minSum = nums[0]
        var currentMax = nums[0]
        var currentMin = nums[0]
        var totalSum = nums[0]
        
        for (i in 1 until nums.size) {
            // Kadane's algorithm for maximum subarray
            currentMax = maxOf(nums[i], currentMax + nums[i])
            maxSum = maxOf(maxSum, currentMax)
            
            // Modified Kadane's for minimum subarray
            currentMin = minOf(nums[i], currentMin + nums[i])
            minSum = minOf(minSum, currentMin)
            
            totalSum += nums[i]
        }
        
        // Edge case: all negative numbers
        return if (maxSum < 0) maxSum else maxOf(maxSum, totalSum - minSum)
    }
}
```

```typescript [TypeScript]
function maxSubarraySumCircular(nums: number[]): number {
    let maxSum = nums[0];
    let minSum = nums[0];
    let currentMax = nums[0];
    let currentMin = nums[0];
    let totalSum = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        // Kadane's algorithm for maximum subarray
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        maxSum = Math.max(maxSum, currentMax);
        
        // Modified Kadane's for minimum subarray
        currentMin = Math.min(nums[i], currentMin + nums[i]);
        minSum = Math.min(minSum, currentMin);
        
        totalSum += nums[i];
    }
    
    // Edge case: all negative numbers
    return maxSum < 0 ? maxSum : Math.max(maxSum, totalSum - minSum);
}
```

```java [Java]
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int maxSum = nums[0];
        int minSum = nums[0];
        int currentMax = nums[0];
        int currentMin = nums[0];
        int totalSum = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            // Kadane's algorithm for maximum subarray
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            maxSum = Math.max(maxSum, currentMax);
            
            // Modified Kadane's for minimum subarray
            currentMin = Math.min(nums[i], currentMin + nums[i]);
            minSum = Math.min(minSum, currentMin);
            
            totalSum += nums[i];
        }
        
        // Edge case: all negative numbers
        return maxSum < 0 ? maxSum : Math.max(maxSum, totalSum - minSum);
    }
}
```

```python [Python]
class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        max_sum = nums[0]
        min_sum = nums[0]
        current_max = nums[0]
        current_min = nums[0]
        total_sum = nums[0]
        
        for i in range(1, len(nums)):
            # Kadane's algorithm for maximum subarray
            current_max = max(nums[i], current_max + nums[i])
            max_sum = max(max_sum, current_max)
            
            # Modified Kadane's for minimum subarray
            current_min = min(nums[i], current_min + nums[i])
            min_sum = min(min_sum, current_min)
            
            total_sum += nums[i]
        
        # Edge case: all negative numbers
        return max_sum if max_sum < 0 else max(max_sum, total_sum - min_sum)
```

:::

## Complexity

- **Time Complexity:** O(N) where N is the length of the array
- **Space Complexity:** O(1) using only constant extra space
