# [455. Assign Cookies](https://leetcode.com/problems/assign-cookies/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="info" text="Easy" />

Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] >= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.

**Example 1:** 

```
Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
```

**Example 2:** 

```
Input: g = [1,2], s = [1,2,3]
Output: 2
Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.
```

**Constraints:** 

- <code>1 <= g.length <= 3 * 10^4</code>
- <code>0 <= s.length <= 3 * 10^4</code>
- <code>1 <= g[i], s[j] <= 2^31 - 1</code>

## ðŸ’¡ Approach: Greedy Algorithm

### Intuition

This is a classic **greedy algorithm** problem. The key insight is to:
1. Sort both arrays in ascending order
2. Try to satisfy the least greedy child first with the smallest cookie that can satisfy them
3. This maximizes the number of satisfied children

**Key Insight:**
- If we satisfy a child with a larger greed factor first, we might waste a large cookie that could satisfy multiple smaller children
- By satisfying smaller greed factors first, we maximize the number of children we can satisfy

### Algorithm

1. **Sort** both arrays: `g` (greed factors) and `s` (cookie sizes) in ascending order
2. **Initialize two pointers:** `i = 0` for children, `j = 0` for cookies
3. **While both pointers are valid:**
   - If `s[j] >= g[i]`: assign cookie `j` to child `i`, increment both pointers and count
   - Else: move to next cookie (increment `j`)
4. **Return** the count of satisfied children

### Key Points

- Greedy approach: always try to satisfy the least greedy child first
- Sorting allows us to process in order and make optimal choices
- Time complexity: O(n log n + m log m) for sorting, O(n + m) for matching
- Space complexity: O(1) if we don't count the sorting space

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun findContentChildren(g: IntArray, s: IntArray): Int {
        g.sort()
        s.sort()
        
        var i = 0  // pointer for children
        var j = 0  // pointer for cookies
        var count = 0
        
        while (i < g.size && j < s.size) {
            if (s[j] >= g[i]) {
                count++
                i++
            }
            j++
        }
        
        return count
    }
}
```

```typescript [TypeScript]
function findContentChildren(g: number[], s: number[]): number {
    g.sort((a, b) => a - b);
    s.sort((a, b) => a - b);
    
    let i = 0;  // pointer for children
    let j = 0;  // pointer for cookies
    let count = 0;
    
    while (i < g.length && j < s.length) {
        if (s[j] >= g[i]) {
            count++;
            i++;
        }
        j++;
    }
    
    return count;
}
```

```java [Java]
import java.util.Arrays;

class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        
        int i = 0;  // pointer for children
        int j = 0;  // pointer for cookies
        int count = 0;
        
        while (i < g.length && j < s.length) {
            if (s[j] >= g[i]) {
                count++;
                i++;
            }
            j++;
        }
        
        return count;
    }
}
```

```swift [Swift]
class Solution {
    func findContentChildren(_ g: [Int], _ s: [Int]) -> Int {
        let children = g.sorted()
        let cookies = s.sorted()
        var child = 0
        var cookie = 0

        while child < children.count && cookie < cookies.count {
            if cookies[cookie] >= children[child] {
                child += 1
            }
            cookie += 1
        }

        return child
    }
}
```

```python [Python]
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        
        i = 0  # pointer for children
        j = 0  # pointer for cookies
        count = 0
        
        while i < len(g) and j < len(s):
            if s[j] >= g[i]:
                count += 1
                i += 1
            j += 1
        
        return count
```

:::

## Complexity

- **Time Complexity:** O(n log n + m log m), where n is the length of `g` and m is the length of `s`. This is due to sorting both arrays. The matching process is O(n + m).
- **Space Complexity:** O(1), excluding the space used for sorting (which is typically O(log n) for the sorting algorithm's recursion stack or O(1) for iterative sorting).