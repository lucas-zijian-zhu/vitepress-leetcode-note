# [763. Partition Labels](https://leetcode.com/problems/partition-labels/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

You are given a string <code>s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.

**Example 1:**

```
Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
```

**Example 2:**

```
Input: s = "eccbbbbdec"
Output: [10]
```

**Constraints:**

- <code>1 <= s.length <= 500</code>
- <code>s</code> consists of lowercase English letters.

## ðŸ’¡ Approach: Greedy with Last Occurrence

### Intuition

If we know the last position of every character, we can expand the current partition to include all characters that appear within it. When the current index reaches the farthest last occurrence seen so far, we can close a partition.

### Algorithm

1. Record the last index of each character.
2. Scan the string while tracking `end` = farthest last index of characters seen so far.
3. When `i == end`, close the partition and start a new one.

### Key Points

- Each partition is as small as possible while still containing all occurrences of its letters.
- Greedy works because extending `end` only depends on characters already seen.

## Code

:::: code-group

```kotlin [Kotlin]
class Solution {
    fun partitionLabels(s: String): List<Int> {
        val last = IntArray(26)
        for (i in s.indices) {
            last[s[i] - 'a'] = i
        }

        val result = mutableListOf<Int>()
        var start = 0
        var end = 0

        for (i in s.indices) {
            end = maxOf(end, last[s[i] - 'a'])
            if (i == end) {
                result.add(end - start + 1)
                start = i + 1
            }
        }

        return result
    }
}
```

```typescript [TypeScript]
function partitionLabels(s: string): number[] {
    const last = new Array(26).fill(0);
    for (let i = 0; i < s.length; i++) {
        last[s.charCodeAt(i) - 97] = i;
    }

    const result: number[] = [];
    let start = 0;
    let end = 0;

    for (let i = 0; i < s.length; i++) {
        end = Math.max(end, last[s.charCodeAt(i) - 97]);
        if (i === end) {
            result.push(end - start + 1);
            start = i + 1;
        }
    }

    return result;
}
```

```java [Java]
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        for (int i = 0; i < s.length(); i++) {
            last[s.charAt(i) - 'a'] = i;
        }

        List<Integer> result = new ArrayList<>();
        int start = 0;
        int end = 0;

        for (int i = 0; i < s.length(); i++) {
            end = Math.max(end, last[s.charAt(i) - 'a']);
            if (i == end) {
                result.add(end - start + 1);
                start = i + 1;
            }
        }

        return result;
    }
}
```

```swift [Swift]
class Solution {
    func partitionLabels(_ s: String) -> [Int] {
        var lastIndex = [Int](repeating: 0, count: 26)
        let chars = Array(s)

        for (index, ch) in chars.enumerated() {
            if let ascii = ch.asciiValue {
                lastIndex[Int(ascii - Character("a").asciiValue!)] = index
            }
        }

        var result: [Int] = []
        var start = 0
        var end = 0

        for (index, ch) in chars.enumerated() {
            if let ascii = ch.asciiValue {
                end = max(end, lastIndex[Int(ascii - Character("a").asciiValue!)])
            }
            if index == end {
                result.append(end - start + 1)
                start = index + 1
            }
        }

        return result
    }
}
```

```python [Python]
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        last = [0] * 26
        for i, ch in enumerate(s):
            last[ord(ch) - ord('a')] = i

        res = []
        start = 0
        end = 0
        for i, ch in enumerate(s):
            end = max(end, last[ord(ch) - ord('a')])
            if i == end:
                res.append(end - start + 1)
                start = i + 1

        return res
```

::::

## Complexity

- **Time Complexity:** O(n), single pass with last occurrence lookup.
- **Space Complexity:** O(1), fixed-size array of 26 letters.
