# [605. Can Place Flowers](https://leetcode.com/problems/can-place-flowers/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="info" text="Easy" />

You have a long flowerbed in which some plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.

Given an integer array <code>flowerbed</code> containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer <code>n</code>, return <code>true</code> if <code>n</code> new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and <code>false</code> otherwise.

**Example 1:**

```
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
```

**Example 2:**

```
Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
```

**Constraints:**

- <code>1 <= flowerbed.length <= 2 * 10^4</code>
- <code>flowerbed[i]</code> is 0 or 1
- <code>1 <= n <= flowerbed.length</code>

## ðŸ’¡ Approach: Greedy Scan

### Intuition

We only need to plant a flower when the current plot and its neighbors are empty. A greedy left-to-right scan is optimal because placing a flower earlier never reduces the total number of flowers we can place.

### Algorithm

1. Iterate through each position `i`.
2. Check if `flowerbed[i] == 0`, and both neighbors (if exist) are also 0.
3. If so, place a flower (`flowerbed[i] = 1`) and decrement `n`.
4. If `n` reaches 0, return `true`.
5. If we finish the scan and still need flowers, return `false`.

### Key Points

- Treat out-of-bounds neighbors as 0.
- Modifying the array in-place simplifies checks.
- Early exit once `n == 0`.

## Code

:::: code-group

```typescript [TypeScript]
function canPlaceFlowers(flowerbed: number[], n: number): boolean {
    if (n === 0) return true;

    let need = n;
    for (let i = 0; i < flowerbed.length; i++) {
        if (flowerbed[i] === 1) continue;
        const leftEmpty = i === 0 || flowerbed[i - 1] === 0;
        const rightEmpty = i === flowerbed.length - 1 || flowerbed[i + 1] === 0;
        if (leftEmpty && rightEmpty) {
            flowerbed[i] = 1;
            need--;
            if (need === 0) return true;
        }
    }

    return false;
}
```

```kotlin [Kotlin]
class Solution {
    fun canPlaceFlowers(flowerbed: IntArray, n: Int): Boolean {
        if (n == 0) return true

        var need = n
        for (i in flowerbed.indices) {
            if (flowerbed[i] == 1) continue
            val leftEmpty = (i == 0) || flowerbed[i - 1] == 0
            val rightEmpty = (i == flowerbed.lastIndex) || flowerbed[i + 1] == 0
            if (leftEmpty && rightEmpty) {
                flowerbed[i] = 1
                need--
                if (need == 0) return true
            }
        }

        return false
    }
}
```

```java [Java]
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        if (n == 0) return true;

        int need = n;
        for (int i = 0; i < flowerbed.length; i++) {
            if (flowerbed[i] == 1) continue;
            boolean leftEmpty = (i == 0) || flowerbed[i - 1] == 0;
            boolean rightEmpty = (i == flowerbed.length - 1) || flowerbed[i + 1] == 0;
            if (leftEmpty && rightEmpty) {
                flowerbed[i] = 1;
                need--;
                if (need == 0) return true;
            }
        }

        return false;
    }
}
```

```swift [Swift]
class Solution {
    func canPlaceFlowers(_ flowerbed: [Int], _ n: Int) -> Bool {
        if n == 0 { return true }
        var bed = flowerbed
        var planted = 0

        for i in 0..<bed.count {
            if bed[i] == 0 {
                let emptyLeft = (i == 0) || bed[i - 1] == 0
                let emptyRight = (i == bed.count - 1) || bed[i + 1] == 0
                if emptyLeft && emptyRight {
                    bed[i] = 1
                    planted += 1
                    if planted >= n {
                        return true
                    }
                }
            }
        }

        return planted >= n
    }
}
```

```python [Python]
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        if n == 0:
            return True

        need = n
        for i in range(len(flowerbed)):
            if flowerbed[i] == 1:
                continue
            left_empty = (i == 0) or flowerbed[i - 1] == 0
            right_empty = (i == len(flowerbed) - 1) or flowerbed[i + 1] == 0
            if left_empty and right_empty:
                flowerbed[i] = 1
                need -= 1
                if need == 0:
                    return True

        return False
```

::::
## Complexity

- **Time Complexity:** O(n), single pass through the array.
- **Space Complexity:** O(1), in-place updates.
