# [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-interview-150)

Given an <code>m x n</code> <code>matrix</code>, return all elements of the <code>matrix</code> in spiral order.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" style="width: 242px; height: 242px;">

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" style="width: 322px; height: 242px;">

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Constraints:** 

- <code>m == matrix.length</code>
- <code>n == matrix[i].length</code>
- <code>1 <= m, n <= 10</code>
- <code>-100 <= matrix[i][j] <= 100</code>

## Approach

We need to return all elements of a matrix in **clockwise spiral order**.

**Key Idea: Use four boundary pointers to simulate the spiral traversal.**

1. Define four boundaries:
   - `top = 0`
   - `bottom = m - 1`
   - `left = 0`
   - `right = n - 1`

2. Traverse the matrix in **4 directions in a loop**:
   1. **Left → Right** along the `top` row, then `top++`
   2. **Top → Bottom** along the `right` column, then `right--`
   3. **Right → Left** along the `bottom` row (if `top <= bottom`), then `bottom--`
   4. **Bottom → Top** along the `left` column (if `left <= right`), then `left++`

3. Stop when the boundaries overlap: `top > bottom` or `left > right`.

## Kotlin Implementation

```kotlin
class Solution {
    fun spiralOrder(matrix: Array<IntArray>): List<Int> {
        val res = mutableListOf<Int>()
        if (matrix.isEmpty()) return res
        
        var top = 0
        var bottom = matrix.size - 1
        var left = 0
        var right = matrix[0].size - 1
        
        while (top <= bottom && left <= right) {
            // 1. Traverse from left to right
            for (j in left..right) res.add(matrix[top][j])
            top++
            
            // 2. Traverse from top to bottom
            for (i in top..bottom) res.add(matrix[i][right])
            right--
            
            // 3. Traverse from right to left
            if (top <= bottom) {
                for (j in right downTo left) res.add(matrix[bottom][j])
                bottom--
            }
            
            // 4. Traverse from bottom to top
            if (left <= right) {
                for (i in bottom downTo top) res.add(matrix[i][left])
                left++
            }
        }
        
        return res
    }
}
```

### Complexity

- **Time Complexity**: `O(m*n)` — each element visited once
- **Space Complexity**: `O(1)` extra (excluding the output list)