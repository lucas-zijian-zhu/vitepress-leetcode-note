# [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-interview-150)

Given an <code>m x n</code> <code>matrix</code>, return all elements of the <code>matrix</code> in spiral order.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" style="width: 242px; height: 242px;">

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" style="width: 322px; height: 242px;">

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Constraints:** 

- <code>m == matrix.length</code>
- <code>n == matrix[i].length</code>
- <code>1 <= m, n <= 10</code>
- <code>-100 <= matrix[i][j] <= 100</code>

## Approach

We need to return all elements of a matrix in **clockwise spiral order**.

**Key Idea: Use four boundary pointers to simulate the spiral traversal.**

1. Define four boundaries:
   - `top = 0`
   - `bottom = m - 1`
   - `left = 0`
   - `right = n - 1`

2. Traverse the matrix in **4 directions in a loop**:
   1. **Left → Right** along the `top` row, then `top++`
   2. **Top → Bottom** along the `right` column, then `right--`
   3. **Right → Left** along the `bottom` row (if `top <= bottom`), then `bottom--`
   4. **Bottom → Top** along the `left` column (if `left <= right`), then `left++`

3. Stop when the boundaries overlap: `top > bottom` or `left > right`.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun spiralOrder(matrix: Array<IntArray>): List<Int> {
        val res = mutableListOf<Int>()
        if (matrix.isEmpty()) return res
        
        var top = 0
        var bottom = matrix.size - 1
        var left = 0
        var right = matrix[0].size - 1
        
        while (top <= bottom && left <= right) {
            // 1. Traverse from left to right
            for (j in left..right) res.add(matrix[top][j])
            top++
            
            // 2. Traverse from top to bottom
            for (i in top..bottom) res.add(matrix[i][right])
            right--
            
            // 3. Traverse from right to left
            if (top <= bottom) {
                for (j in right downTo left) res.add(matrix[bottom][j])
                bottom--
            }
            
            // 4. Traverse from bottom to top
            if (left <= right) {
                for (i in bottom downTo top) res.add(matrix[i][left])
                left++
            }
        }
        
        return res
    }
}
```

```typescript [TypeScript]
class Solution {
    spiralOrder(matrix: number[][]): number[] {
        const res: number[] = [];
        if (matrix.length === 0) return res;
        
        let top = 0;
        let bottom = matrix.length - 1;
        let left = 0;
        let right = matrix[0].length - 1;
        
        while (top <= bottom && left <= right) {
            // 1. Traverse from left to right
            for (let j = left; j <= right; j++) {
                res.push(matrix[top][j]);
            }
            top++;
            
            // 2. Traverse from top to bottom
            for (let i = top; i <= bottom; i++) {
                res.push(matrix[i][right]);
            }
            right--;
            
            // 3. Traverse from right to left
            if (top <= bottom) {
                for (let j = right; j >= left; j--) {
                    res.push(matrix[bottom][j]);
                }
                bottom--;
            }
            
            // 4. Traverse from bottom to top
            if (left <= right) {
                for (let i = bottom; i >= top; i--) {
                    res.push(matrix[i][left]);
                }
                left++;
            }
        }
        
        return res;
    }
}
```

```java [Java]
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if (matrix.length == 0) return res;
        
        int top = 0;
        int bottom = matrix.length - 1;
        int left = 0;
        int right = matrix[0].length - 1;
        
        while (top <= bottom && left <= right) {
            // 1. Traverse from left to right
            for (int j = left; j <= right; j++) {
                res.add(matrix[top][j]);
            }
            top++;
            
            // 2. Traverse from top to bottom
            for (int i = top; i <= bottom; i++) {
                res.add(matrix[i][right]);
            }
            right--;
            
            // 3. Traverse from right to left
            if (top <= bottom) {
                for (int j = right; j >= left; j--) {
                    res.add(matrix[bottom][j]);
                }
                bottom--;
            }
            
            // 4. Traverse from bottom to top
            if (left <= right) {
                for (int i = bottom; i >= top; i--) {
                    res.add(matrix[i][left]);
                }
                left++;
            }
        }
        
        return res;
    }
}
```

```python [Python]
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        if not matrix:
            return res
        
        top = 0
        bottom = len(matrix) - 1
        left = 0
        right = len(matrix[0]) - 1
        
        while top <= bottom and left <= right:
            # 1. Traverse from left to right
            for j in range(left, right + 1):
                res.append(matrix[top][j])
            top += 1
            
            # 2. Traverse from top to bottom
            for i in range(top, bottom + 1):
                res.append(matrix[i][right])
            right -= 1
            
            # 3. Traverse from right to left
            if top <= bottom:
                for j in range(right, left - 1, -1):
                    res.append(matrix[bottom][j])
                bottom -= 1
            
            # 4. Traverse from bottom to top
            if left <= right:
                for i in range(bottom, top - 1, -1):
                    res.append(matrix[i][left])
                left += 1
        
        return res
```

:::

### Complexity

- **Time Complexity**: `O(m*n)` — each element visited once
- **Space Complexity**: `O(1)` extra (excluding the output list)