# [290. Word Pattern](https://leetcode.com/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150)

Given a `pattern` and a string `s`, determine if `s` follows the same pattern.

Here **follow** means a full match such that there is a bijection between a letter in `pattern` and a **non-empty** word in `s`.

Specifically:
- Each letter in `pattern` maps to **exactly one** unique word in `s`.
- Each unique word in `s` maps to **exactly one** letter in `pattern`.
- No two letters map to the same word, and no two words map to the same letter.

---

**Example 1:**

Input:  
`pattern = "abba", s = "dog cat cat dog"`  
Output:  
`true`

Explanation:  
The bijection can be established as:
- `'a'` → `"dog"`
- `'b'` → `"cat"`

---

**Example 2:**

Input:  
`pattern = "abba", s = "dog cat cat fish"`  
Output:  
`false`

---

**Example 3:**

Input:  
`pattern = "aaaa", s = "dog cat cat dog"`  
Output:  
`false`

---

**Constraints:**
- `1 <= pattern.length <= 300`
- `pattern` contains only lowercase English letters.
- `1 <= s.length <= 3000`
- `s` contains only lowercase English letters and spaces `' '`.
- `s` does **not** contain leading or trailing spaces.
- All words in `s` are separated by a **single space**.

## Approach (HashMap + Bijection Check)

1. **Split words**: `words = s.split(" ")`. If `words.size != pattern.length`, return `false`.
2. **Bijection (two-way) mapping**:
   - Maintain `p2w: Char -> String` and `w2p: String -> Char`.
   - For each index `i`:
     - Let `pc = pattern[i]`, `w = words[i]`.
     - If `pc` is already mapped, it must equal `w`; otherwise `false`.
     - If `w` is already mapped, it must equal `pc`; otherwise `false`.
     - Else create both mappings.
3. If all positions pass, return `true`.

**Why two maps?**  
To enforce **one-to-one** (bijective) mapping in both directions, preventing cases like two pattern chars → same word or one word ← multiple chars.

### Edge Cases
- Length mismatch between `pattern` and words.
- Repeated characters/words breaking bijection.
- Extra spaces are not expected by problem, but if trimming is needed, call `trim()` before `split(" ")`.

### Correctness
At each step we ensure consistency of previously established mappings in both directions. Any violation immediately returns `false`. If the scan completes, a bijection exists → `true`.

## Kotlin Code

```kotlin
class Solution {
    fun wordPattern(pattern: String, s: String): Boolean {
        val words = s.split(" ")
        if (words.size != pattern.length) return false

        val p2w = HashMap<Char, String>()
        val w2p = HashMap<String, Char>()

        for (i in pattern.indices) {
            val pc = pattern[i]
            val w = words[i]

            val mappedW = p2w[pc]
            if (mappedW != null && mappedW != w) return false

            val mappedP = w2p[w]
            if (mappedP != null && mappedP != pc) return false

            if (mappedW == null && mappedP == null) {
                p2w[pc] = w
                w2p[w] = pc
            }
        }
        return true
    }
}
```

### Complexity
- **Time:** `O(n)` where `n = pattern.length` (hash lookups are amortized O(1)).
- **Space:** `O(k)` where `k` is the number of distinct chars/words (at most `n`).
