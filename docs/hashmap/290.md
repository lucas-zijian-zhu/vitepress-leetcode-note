# [290. Word Pattern](https://leetcode.com/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150)

Given a `pattern` and a string `s`, determine if `s` follows the same pattern.

Here **follow** means a full match such that there is a bijection between a letter in `pattern` and a **non-empty** word in `s`.

Specifically:
- Each letter in `pattern` maps to **exactly one** unique word in `s`.
- Each unique word in `s` maps to **exactly one** letter in `pattern`.
- No two letters map to the same word, and no two words map to the same letter.

---

**Example 1:**

Input:  
`pattern = "abba", s = "dog cat cat dog"`  
Output:  
`true`

Explanation:  
The bijection can be established as:
- `'a'` → `"dog"`
- `'b'` → `"cat"`

---

**Example 2:**

Input:  
`pattern = "abba", s = "dog cat cat fish"`  
Output:  
`false`

---

**Example 3:**

Input:  
`pattern = "aaaa", s = "dog cat cat dog"`  
Output:  
`false`

---

**Constraints:**
- `1 <= pattern.length <= 300`
- `pattern` contains only lowercase English letters.
- `1 <= s.length <= 3000`
- `s` contains only lowercase English letters and spaces `' '`.
- `s` does **not** contain leading or trailing spaces.
- All words in `s` are separated by a **single space**.

## Approach (HashMap + Bijection Check)

1. **Split words**: `words = s.split(" ")`. If `words.size != pattern.length`, return `false`.
2. **Bijection (two-way) mapping**:
   - Maintain `p2w: Char -> String` and `w2p: String -> Char`.
   - For each index `i`:
     - Let `pc = pattern[i]`, `w = words[i]`.
     - If `pc` is already mapped, it must equal `w`; otherwise `false`.
     - If `w` is already mapped, it must equal `pc`; otherwise `false`.
     - Else create both mappings.
3. If all positions pass, return `true`.

**Why two maps?**  
To enforce **one-to-one** (bijective) mapping in both directions, preventing cases like two pattern chars → same word or one word ← multiple chars.

### Edge Cases
- Length mismatch between `pattern` and words.
- Repeated characters/words breaking bijection.
- Extra spaces are not expected by problem, but if trimming is needed, call `trim()` before `split(" ")`.

### Correctness
At each step we ensure consistency of previously established mappings in both directions. Any violation immediately returns `false`. If the scan completes, a bijection exists → `true`.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun wordPattern(pattern: String, s: String): Boolean {
        val words = s.split(" ")
        if (words.size != pattern.length) return false

        val p2w = HashMap<Char, String>()
        val w2p = HashMap<String, Char>()

        for (i in pattern.indices) {
            val pc = pattern[i]
            val w = words[i]

            val mappedW = p2w[pc]
            if (mappedW != null && mappedW != w) return false

            val mappedP = w2p[w]
            if (mappedP != null && mappedP != pc) return false

            if (mappedW == null && mappedP == null) {
                p2w[pc] = w
                w2p[w] = pc
            }
        }
        return true
    }
}
```

```typescript [TypeScript]
function wordPattern(pattern: string, s: string): boolean {
    const words = s.split(" ");
    if (words.length !== pattern.length) return false;

    const p2w = new Map<string, string>();
    const w2p = new Map<string, string>();

    for (let i = 0; i < pattern.length; i++) {
        const pc = pattern[i];
        const w = words[i];

        const mappedW = p2w.get(pc);
        if (mappedW !== undefined && mappedW !== w) return false;

        const mappedP = w2p.get(w);
        if (mappedP !== undefined && mappedP !== pc) return false;

        if (mappedW === undefined && mappedP === undefined) {
            p2w.set(pc, w);
            w2p.set(w, pc);
        }
    }
    
    return true;
}
```

```java [Java]
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] words = s.split(" ");
        if (words.length != pattern.length()) return false;

        Map<Character, String> p2w = new HashMap<>();
        Map<String, Character> w2p = new HashMap<>();

        for (int i = 0; i < pattern.length(); i++) {
            char pc = pattern.charAt(i);
            String w = words[i];

            String mappedW = p2w.get(pc);
            if (mappedW != null && !mappedW.equals(w)) return false;

            Character mappedP = w2p.get(w);
            if (mappedP != null && !mappedP.equals(pc)) return false;

            if (mappedW == null && mappedP == null) {
                p2w.put(pc, w);
                w2p.put(w, pc);
            }
        }
        
        return true;
    }
}
```

```python [Python]
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split(" ")
        if len(words) != len(pattern):
            return False

        p2w = {}
        w2p = {}

        for i in range(len(pattern)):
            pc = pattern[i]
            w = words[i]

            mapped_w = p2w.get(pc)
            if mapped_w is not None and mapped_w != w:
                return False

            mapped_p = w2p.get(w)
            if mapped_p is not None and mapped_p != pc:
                return False

            if mapped_w is None and mapped_p is None:
                p2w[pc] = w
                w2p[w] = pc

        return True
```

:::

### Complexity
- **Time:** `O(n)` where `n = pattern.length` (hash lookups are amortized O(1)).
- **Space:** `O(k)` where `k` is the number of distinct chars/words (at most `n`).
