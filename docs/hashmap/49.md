# [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-interview-150)

Given an array of strings `strs`, group the **anagrams** together. You can return the answer in **any order**.

**Example 1:**

<div class="example-block">

Input: strs = ["eat","tea","tan","ate","nat","bat"]

Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

Explanation:

- There is no string in `strs` that can be rearranged to form `"bat"`.
- The strings `"nat"` and `"tan"` are anagrams as they can be rearranged to form each other.
- The strings `"ate"`, `"eat"`, and `"tea"` are anagrams as they can be rearranged to form each other.
</div>

**Example 2:**

<div class="example-block">

Input: strs = [""]

Output: [[""]]
</div>

**Example 3:**

<div class="example-block">

Input: strs = ["a"]

Output: [["a"]]
</div>

**Constraints:**
- `1 <= strs.length <= 10^4`
- `0 <= strs[i].length <= 100`
- `strs[i]` consists of lowercase English letters.

## Approach (Count Signature)
For each word:
1. Create an `IntArray(26)` to count occurrences of `a..z`.
2. Build a **key string** from these counts (e.g., `"1#0#0#...#"`).  
   - Using a delimiter (like `#`) prevents ambiguity (`[1,11]` vs `[11,1]`).
3. Insert the word into a hash map: `key -> list of words`.
4. At the end, return the map’s values.

This guarantees that all anagrams share the same key and are grouped.

---

## Correctness & Edge Cases
- Empty strings `""` produce all-zero counts; they group together.
- Single-letter words group by their sole letter.
- Input guarantees lowercase English letters; a 26-length count is sufficient.
- The delimiter in the key avoids collisions from concatenated digits.

## Kotlin Code
```kotlin
fun groupAnagrams(strs: Array<String>): List<List<String>> {
    val groups = HashMap<String, MutableList<String>>()

    for (s in strs) {
        val cnt = IntArray(26)
        for (ch in s) {
            cnt[ch - 'a']++
        }
        // Build a stable key: "c0#c1#...#c25#"
        val key = buildString(26 * 2) {
            for (i in 0 until 26) {
                append(cnt[i])
                append('#')
            }
        }
        groups.computeIfAbsent(key) { mutableListOf() }.add(s)
    }

    return groups.values.map { it.toList() }
}
```

## Complexity
- Let `N` be the number of words and `L` the average word length.
- **Time:** `O(N · L)` — counting characters is linear in word length.
- **Space:** `O(N · L)` — storing all words plus the keys/lists (the key is length ~ `O(26)` per distinct anagram class; dominant term is storing the input in groups).
