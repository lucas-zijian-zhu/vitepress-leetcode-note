# [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-interview-150)

Given an array of strings `strs`, group the **anagrams** together. You can return the answer in **any order**.

**Example 1:**

<div class="example-block">

Input: strs = ["eat","tea","tan","ate","nat","bat"]

Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

Explanation:

- There is no string in `strs` that can be rearranged to form `"bat"`.
- The strings `"nat"` and `"tan"` are anagrams as they can be rearranged to form each other.
- The strings `"ate"`, `"eat"`, and `"tea"` are anagrams as they can be rearranged to form each other.
</div>

**Example 2:**

<div class="example-block">

Input: strs = [""]

Output: [[""]]
</div>

**Example 3:**

<div class="example-block">

Input: strs = ["a"]

Output: [["a"]]
</div>

**Constraints:**
- `1 <= strs.length <= 10^4`
- `0 <= strs[i].length <= 100`
- `strs[i]` consists of lowercase English letters.

## Approach (Count Signature)
For each word:
1. Create an `IntArray(26)` to count occurrences of `a..z`.
2. Build a **key string** from these counts (e.g., `"1#0#0#...#"`).  
   - Using a delimiter (like `#`) prevents ambiguity (`[1,11]` vs `[11,1]`).
3. Insert the word into a hash map: `key -> list of words`.
4. At the end, return the map’s values.

This guarantees that all anagrams share the same key and are grouped.

---

## Correctness & Edge Cases
- Empty strings `""` produce all-zero counts; they group together.
- Single-letter words group by their sole letter.
- Input guarantees lowercase English letters; a 26-length count is sufficient.
- The delimiter in the key avoids collisions from concatenated digits.

## Code

::: code-group

```kotlin [Kotlin]
fun groupAnagrams(strs: Array<String>): List<List<String>> {
    val groups = HashMap<String, MutableList<String>>()

    for (s in strs) {
        val cnt = IntArray(26)
        for (ch in s) {
            cnt[ch - 'a']++
        }
        // Build a stable key: "c0#c1#...#c25#"
        val key = buildString(26 * 2) {
            for (i in 0 until 26) {
                append(cnt[i])
                append('#')
            }
        }
        groups.computeIfAbsent(key) { mutableListOf() }.add(s)
    }

    return groups.values.map { it.toList() }
}
```

```typescript [TypeScript]
function groupAnagrams(strs: string[]): string[][] {
    const groups = new Map<string, string[]>();

    for (const s of strs) {
        const cnt = new Array(26).fill(0);
        for (const ch of s) {
            cnt[ch.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }
        // Build a stable key: "c0#c1#...#c25#"
        const key = cnt.join('#');
        
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key)!.push(s);
    }

    return Array.from(groups.values());
}
```

```java [Java]
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> groups = new HashMap<>();

        for (String s : strs) {
            int[] cnt = new int[26];
            for (char ch : s.toCharArray()) {
                cnt[ch - 'a']++;
            }
            // Build a stable key: "c0#c1#...#c25#"
            StringBuilder key = new StringBuilder();
            for (int i = 0; i < 26; i++) {
                key.append(cnt[i]).append('#');
            }
            
            groups.computeIfAbsent(key.toString(), k -> new ArrayList<>()).add(s);
        }

        return new ArrayList<>(groups.values());
    }
}
```

```python [Python]
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        groups = {}

        for s in strs:
            cnt = [0] * 26
            for ch in s:
                cnt[ord(ch) - ord('a')] += 1
            # Build a stable key: "c0#c1#...#c25#"
            key = '#'.join(map(str, cnt))
            
            if key not in groups:
                groups[key] = []
            groups[key].append(s)

        return list(groups.values())
```

:::

## Complexity
- Let `N` be the number of words and `L` the average word length.
- **Time:** `O(N · L)` — counting characters is linear in word length.
- **Space:** `O(N · L)` — storing all words plus the keys/lists (the key is length ~ `O(26)` per distinct anagram class; dominant term is storing the input in groups).
