# [205. Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/description/?envType=study-plan-v2&envId=top-interview-150)

Given two strings `s` and `t`, determine if they are isomorphic.

Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

**Example 1:** 

<div class="example-block">
Input: s = "egg", t = "add"

Output: true

Explanation:

The strings `s` and `t` can be made identical by:

- Mapping `e` to `a`.
- Mapping `g` to `d`.
</div>

**Example 2:** 

<div class="example-block">
Input: s = "foo", t = "bar"

Output: false

Explanation:

The strings `s` and `t` can not be made identical as `o` needs to be mapped to both `a` and `r`.
</div>

**Example 3:** 

<div class="example-block">
Input: s = "paper", t = "title"

Output: true
</div>

**Constraints:** 

- `1 <= s.length <= 5 * 10^4`
- `t.length == s.length`
- `s` and `t` consist of any valid ascii character.


### Approach
Two strings `s` and `t` are isomorphic if there is a **one-to-one** mapping between characters of `s` and characters of `t` that preserves order.  
We can enforce bijection by tracking **two maps** simultaneously:
- `s -> t` to ensure one character in `s` always maps to the same character in `t`.
- `t -> s` to ensure no two different characters in `s` map to the same character in `t`.

For each index `i`, check the existing mappings:
- If neither `s[i]` nor `t[i]` is mapped, create both mappings.
- Otherwise, the existing mappings must match `s[i] -> t[i]` **and** `t[i] -> s[i]`; otherwise return `false`.

This works for any Unicode chars (not restricted to 26 letters).

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun isIsomorphic(s: String, t: String): Boolean {
        if (s.length != t.length) return false
        val st = HashMap<Char, Char>()
        val ts = HashMap<Char, Char>()

        for (i in s.indices) {
            val a = s[i]
            val b = t[i]

            val m1 = st[a]
            val m2 = ts[b]

            if (m1 == null && m2 == null) {
                st[a] = b
                ts[b] = a
            } else {
                if (m1 != b || m2 != a) return false
            }
        }
        return true
    }
}
```

```typescript [TypeScript]
function isIsomorphic(s: string, t: string): boolean {
    if (s.length !== t.length) return false;
    
    const st = new Map<string, string>();
    const ts = new Map<string, string>();

    for (let i = 0; i < s.length; i++) {
        const a = s[i];
        const b = t[i];

        const m1 = st.get(a);
        const m2 = ts.get(b);

        if (m1 === undefined && m2 === undefined) {
            st.set(a, b);
            ts.set(b, a);
        } else {
            if (m1 !== b || m2 !== a) return false;
        }
    }
    
    return true;
}
```

```java [Java]
class Solution {
    public boolean isIsomorphic(String s, String t) {
        if (s.length() != t.length()) return false;
        
        Map<Character, Character> st = new HashMap<>();
        Map<Character, Character> ts = new HashMap<>();

        for (int i = 0; i < s.length(); i++) {
            char a = s.charAt(i);
            char b = t.charAt(i);

            Character m1 = st.get(a);
            Character m2 = ts.get(b);

            if (m1 == null && m2 == null) {
                st.put(a, b);
                ts.put(b, a);
            } else {
                if (m1 == null || !m1.equals(b) || m2 == null || !m2.equals(a)) {
                    return false;
                }
            }
        }
        
        return true;
    }
}
```

```python [Python]
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        
        st = {}
        ts = {}

        for i in range(len(s)):
            a = s[i]
            b = t[i]

            m1 = st.get(a)
            m2 = ts.get(b)

            if m1 is None and m2 is None:
                st[a] = b
                ts[b] = a
            else:
                if m1 != b or m2 != a:
                    return False

        return True
```

:::

### Complexity
- **Time:** `O(n)` where `n` is the length of the strings.
- **Space:** `O(k)` for distinct characters encountered (bounded by charset size).
