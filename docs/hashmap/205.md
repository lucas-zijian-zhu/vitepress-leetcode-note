# [205. Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/description/?envType=study-plan-v2&envId=top-interview-150)

Given two strings `s` and `t`, determine if they are isomorphic.

Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

**Example 1:** 

<div class="example-block">
Input: s = "egg", t = "add"

Output: true

Explanation:

The strings `s` and `t` can be made identical by:

- Mapping `e` to `a`.
- Mapping `g` to `d`.
</div>

**Example 2:** 

<div class="example-block">
Input: s = "foo", t = "bar"

Output: false

Explanation:

The strings `s` and `t` can not be made identical as `o` needs to be mapped to both `a` and `r`.
</div>

**Example 3:** 

<div class="example-block">
Input: s = "paper", t = "title"

Output: true
</div>

**Constraints:** 

- `1 <= s.length <= 5 * 10^4`
- `t.length == s.length`
- `s` and `t` consist of any valid ascii character.


### Approach
Two strings `s` and `t` are isomorphic if there is a **one-to-one** mapping between characters of `s` and characters of `t` that preserves order.  
We can enforce bijection by tracking **two maps** simultaneously:
- `s -> t` to ensure one character in `s` always maps to the same character in `t`.
- `t -> s` to ensure no two different characters in `s` map to the same character in `t`.

For each index `i`, check the existing mappings:
- If neither `s[i]` nor `t[i]` is mapped, create both mappings.
- Otherwise, the existing mappings must match `s[i] -> t[i]` **and** `t[i] -> s[i]`; otherwise return `false`.

This works for any Unicode chars (not restricted to 26 letters).

### Kotlin Code

```kotlin
class Solution {
    fun isIsomorphic(s: String, t: String): Boolean {
        if (s.length != t.length) return false
        val st = HashMap<Char, Char>()
        val ts = HashMap<Char, Char>()

        for (i in s.indices) {
            val a = s[i]
            val b = t[i]

            val m1 = st[a]
            val m2 = ts[b]

            if (m1 == null && m2 == null) {
                st[a] = b
                ts[b] = a
            } else {
                if (m1 != b || m2 != a) return false
            }
        }
        return true
    }
}
```

### Complexity
- **Time:** `O(n)` where `n` is the length of the strings.
- **Space:** `O(k)` for distinct characters encountered (bounded by charset size).
