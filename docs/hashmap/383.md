# [383. Ransom Note](https://leetcode.com/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="info" text="Easy" />

Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code> if <code>ransomNote</code> can be constructed by using the letters from <code>magazine</code> and <code>false</code> otherwise.

Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.

**Example 1:** 

```
Input: ransomNote = "a", magazine = "b"
Output: false
```

**Example 2:** 

```
Input: ransomNote = "aa", magazine = "ab"
Output: false
```

**Example 3:** 

```
Input: ransomNote = "aa", magazine = "aab"
Output: true
```

**Constraints:** 

- <code>1 <= ransomNote.length, magazine.length <= 10^5</code>
- <code>ransomNote</code> and <code>magazine</code> consist of lowercase English letters.

## Approach

We need to determine if the `ransomNote` string can be constructed from the characters available in the `magazine` string.  
A simple and efficient way to solve this is:

1. **Count the characters in `magazine`**  
   - We create a map (or array) to store the frequency of each character in `magazine`.

2. **Check each character in `ransomNote`**  
   - For each character, check if it exists in the map with a positive count.  
   - If the count is zero or the character doesn't exist, return `false`.

3. **If all characters in `ransomNote` are available**, return `true`.

## Code

::: code-group

```typescript [TypeScript]
function canConstruct(ransomNote: string, magazine: string): boolean {
    const map = new Map<string, number>();
    
    for (const c of magazine) {
        map.set(c, (map.get(c) || 0) + 1);
    }
    
    for (const c of ransomNote) {
        if ((map.get(c) || 0) === 0) {
            return false;
        }
        map.set(c, (map.get(c) || 0) - 1);
    }
    
    return true;
}
```

```kotlin [Kotlin]
class Solution {
    fun canConstruct(ransomNote: String, magazine: String): Boolean {
        val map = mutableMapOf<Char, Int>()
        for (c in magazine) {
            map[c] = map.getOrDefault(c, 0) + 1
        }
        for(c in ransomNote) {
            if (map.getOrDefault(c, 0) == 0) {
                return false
            }
            map[c] = map.getOrDefault(c, 0) - 1
        }
        return true
    }
}
```

```java [Java]
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map<Character, Integer> map = new HashMap<>();
        
        for (char c : magazine.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        
        for (char c : ransomNote.toCharArray()) {
            if (map.getOrDefault(c, 0) == 0) {
                return false;
            }
            map.put(c, map.getOrDefault(c, 0) - 1);
        }
        
        return true;
    }
}
```

```swift [Swift]
class Solution {
    func canConstruct(_ ransomNote: String, _ magazine: String) -> Bool {
        var counts: [Character: Int] = [:]
        for ch in magazine {
            counts[ch, default: 0] += 1
        }
        for ch in ransomNote {
            guard let value = counts[ch], value > 0 else {
                return false
            }
            counts[ch] = value - 1
        }
        return true
    }
}
```

```python [Python]
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        map_dict = {}
        
        for c in magazine:
            map_dict[c] = map_dict.get(c, 0) + 1
        
        for c in ransomNote:
            if map_dict.get(c, 0) == 0:
                return False
            map_dict[c] = map_dict.get(c, 0) - 1
        
        return True
```

:::
**Complexity Analysis**:
- **Time Complexity**: `O(m + n)` where `m` is the length of `magazine` and `n` is the length of `ransomNote`.
- **Space Complexity**: `O(1)` because the number of possible characters (26 lowercase letters) is constant.

