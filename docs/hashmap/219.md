# [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="info" text="Easy" />

Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if there are two **distinct indices**  <code>i</code> and <code>j</code> in the array such that <code>nums[i] == nums[j]</code> and <code>abs(i - j) <= k</code>.

**Example 1:** 

```
Input: nums = [1,2,3,1], k = 3
Output: true
```

**Example 2:** 

```
Input: nums = [1,0,1,1], k = 1
Output: true
```

**Example 3:** 

```
Input: nums = [1,2,3,1,2,3], k = 2
Output: false
```

**Constraints:** 

- <code>1 <= nums.length <= 10^5</code>
- <code>-10^9 <= nums[i] <= 10^9</code>
- <code>0 <= k <= 10^5</code>

## Approach (HashMap: last seen index)

We scan the array once and keep a map from value → its **last seen index**.  
For each index `i`:

- If `nums[i]` has appeared before at index `j`, check if `i - j <= k`.  
  - If yes, we’ve found a valid pair → return `true`.
- Update the last seen index of `nums[i]` to `i`.

This ensures we only keep the most recent index for each value and check distance in O(1).

## Code

::: code-group

```typescript [TypeScript]
function containsNearbyDuplicate(nums: number[], k: number): boolean {
    const last = new Map<number, number>(); // value -> last index
    
    for (let i = 0; i < nums.length; i++) {
        const v = nums[i];
        const prev = last.get(v);
        if (prev !== undefined && i - prev <= k) return true;
        last.set(v, i);
    }
    
    return false;
}
```

```kotlin [Kotlin]
class Solution {
    fun containsNearbyDuplicate(nums: IntArray, k: Int): Boolean {
        val last = HashMap<Int, Int>() // value -> last index
        for (i in nums.indices) {
            val v = nums[i]
            val prev = last[v]
            if (prev != null && i - prev <= k) return true
            last[v] = i
        }
        return false
    }
}
```

```java [Java]
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> last = new HashMap<>(); // value -> last index
        
        for (int i = 0; i < nums.length; i++) {
            int v = nums[i];
            Integer prev = last.get(v);
            if (prev != null && i - prev <= k) return true;
            last.put(v, i);
        }
        
        return false;
    }
}
```

```swift [Swift]
class Solution {
    func containsNearbyDuplicate(_ nums: [Int], _ k: Int) -> Bool {
        var indices: [Int: Int] = [:]
        for (i, value) in nums.enumerated() {
            if let previous = indices[value], i - previous <= k {
                return true
            }
            indices[value] = i
        }
        return false
    }
}
```

```python [Python]
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        last = {}  # value -> last index
        
        for i in range(len(nums)):
            v = nums[i]
            prev = last.get(v)
            if prev is not None and i - prev <= k:
                return True
            last[v] = i
        
        return False
```

:::
## Complexity
- **Time Complexity:** `O(n)`  
  We traverse the array once, and each lookup/update in the HashMap/HashSet is `O(1)` on average.  

- **Space Complexity:** `O(min(n, k))`  
  At most, the HashMap/HashSet will store `k` elements (sliding window of size `k`).