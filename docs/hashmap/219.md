# [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/description/?envType=study-plan-v2&envId=top-interview-150)

Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if there are two **distinct indices**  <code>i</code> and <code>j</code> in the array such that <code>nums[i] == nums[j]</code> and <code>abs(i - j) <= k</code>.

**Example 1:** 

```
Input: nums = [1,2,3,1], k = 3
Output: true
```

**Example 2:** 

```
Input: nums = [1,0,1,1], k = 1
Output: true
```

**Example 3:** 

```
Input: nums = [1,2,3,1,2,3], k = 2
Output: false
```

**Constraints:** 

- <code>1 <= nums.length <= 10^5</code>
- <code>-10^9 <= nums[i] <= 10^9</code>
- <code>0 <= k <= 10^5</code>

## Approach (HashMap: last seen index)

We scan the array once and keep a map from value → its **last seen index**.  
For each index `i`:

- If `nums[i]` has appeared before at index `j`, check if `i - j <= k`.  
  - If yes, we’ve found a valid pair → return `true`.
- Update the last seen index of `nums[i]` to `i`.

This ensures we only keep the most recent index for each value and check distance in O(1).

### Kotlin

```kotlin
class Solution {
    fun containsNearbyDuplicate(nums: IntArray, k: Int): Boolean {
        val last = HashMap<Int, Int>() // value -> last index
        for (i in nums.indices) {
            val v = nums[i]
            val prev = last[v]
            if (prev != null && i - prev <= k) return true
            last[v] = i
        }
        return false
    }
}
```

## Complexity
- **Time Complexity:** `O(n)`  
  We traverse the array once, and each lookup/update in the HashMap/HashSet is `O(1)` on average.  

- **Space Complexity:** `O(min(n, k))`  
  At most, the HashMap/HashSet will store `k` elements (sliding window of size `k`).