# [202. Happy Number](https://leetcode.com/problems/happy-number/description/?envType=study-plan-v2&envId=top-interview-150)

Write an algorithm to determine if a number <code>n</code> is happy.

A **happy number**  is a number defined by the following process:

- Starting with any positive integer, replace the number by the sum of the squares of its digits.
- Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle**  which does not include 1.
- Those numbers for which this process **ends in 1**  are happy.

Return <code>true</code> if <code>n</code> is a happy number, and <code>false</code> if not.

**Example 1:** 

```
Input: n = 19
Output: true
Explanation:
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

**Example 2:** 

```
Input: n = 2
Output: false
```

**Constraints:** 

- <code>1 <= n <= 2^31 - 1</code>

## Approach
We need to repeatedly replace the number by the **sum of the squares of its digits**.  
- If the result becomes `1`, the number is happy.  
- If the process loops (e.g., `4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 ...`), then it will never reach `1` and is not happy.

There are two main ways to detect cycles:

### A) Using a HashSet
- Store every seen number in a set.  
- If we reach `1`, return `true`.  
- If we see a number already in the set, a cycle is detected → return `false`.

### B) Floyd’s Cycle Detection (Two Pointers)
- Treat the transformation as a linked list where `next(x)` is the sum of squares.  
- Use two pointers: `slow` moves one step, `fast` moves two steps.  
- If `fast` becomes `1`, return `true`.  
- If `slow == fast` (but not `1`), we found a cycle → return `false`.

Floyd’s method uses **O(1)** space, while HashSet is more intuitive.


## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun isHappy(n: Int): Boolean {
        var x = n
        val seen = HashSet<Int>()
        while (x != 1 && x !in seen) {
            seen.add(x)
            x = sumOfSquares(x)
        }
        return x == 1
    }

    private fun sumOfSquares(num: Int): Int {
        var v = num
        var sum = 0
        while (v > 0) {
            val d = v % 10
            sum += d * d
            v /= 10
        }
        return sum
    }
}
```

```typescript [TypeScript]
function isHappy(n: number): boolean {
    let x = n;
    const seen = new Set<number>();
    while (x !== 1 && !seen.has(x)) {
        seen.add(x);
        x = sumOfSquares(x);
    }
    return x === 1;
}

function sumOfSquares(num: number): number {
    let sum = 0;
    while (num > 0) {
        const digit = num % 10;
        sum += digit * digit;
        num = Math.floor(num / 10);
    }
    return sum;
}
```

```java [Java]
class Solution {
    public boolean isHappy(int n) {
        int x = n;
        Set<Integer> seen = new HashSet<>();
        while (x != 1 && !seen.contains(x)) {
            seen.add(x);
            x = sumOfSquares(x);
        }
        return x == 1;
    }

    private int sumOfSquares(int num) {
        int sum = 0;
        while (num > 0) {
            int digit = num % 10;
            sum += digit * digit;
            num /= 10;
        }
        return sum;
    }
}
```

```python [Python]
class Solution:
    def isHappy(self, n: int) -> bool:
        seen = set()
        while n != 1 and n not in seen:
            seen.add(n)
            n = self.sum_of_squares(n)
        return n == 1

    def sum_of_squares(self, num: int) -> int:
        total = 0
        while num > 0:
            digit = num % 10
            total += digit * digit
            num //= 10
        return total
```

:::

## Complexity
- **Time:** `O(k)` where `k` is the number of iterations before reaching `1` or a cycle (bounded for 32-bit integers).  
- **Space:**  
  - HashSet: `O(k)`  
  - Floyd's algorithm: `O(1)`