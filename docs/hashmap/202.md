# [202. Happy Number](https://leetcode.com/problems/happy-number/description/?envType=study-plan-v2&envId=top-interview-150)

Write an algorithm to determine if a number <code>n</code> is happy.

A **happy number**  is a number defined by the following process:

- Starting with any positive integer, replace the number by the sum of the squares of its digits.
- Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle**  which does not include 1.
- Those numbers for which this process **ends in 1**  are happy.

Return <code>true</code> if <code>n</code> is a happy number, and <code>false</code> if not.

**Example 1:** 

```
Input: n = 19
Output: true
Explanation:
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

**Example 2:** 

```
Input: n = 2
Output: false
```

**Constraints:** 

- <code>1 <= n <= 2^31 - 1</code>

## Approach
We need to repeatedly replace the number by the **sum of the squares of its digits**.  
- If the result becomes `1`, the number is happy.  
- If the process loops (e.g., `4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 ...`), then it will never reach `1` and is not happy.

There are two main ways to detect cycles:

### A) Using a HashSet
- Store every seen number in a set.  
- If we reach `1`, return `true`.  
- If we see a number already in the set, a cycle is detected → return `false`.

### B) Floyd’s Cycle Detection (Two Pointers)
- Treat the transformation as a linked list where `next(x)` is the sum of squares.  
- Use two pointers: `slow` moves one step, `fast` moves two steps.  
- If `fast` becomes `1`, return `true`.  
- If `slow == fast` (but not `1`), we found a cycle → return `false`.

Floyd’s method uses **O(1)** space, while HashSet is more intuitive.


## Kotlin Code

```kotlin
class Solution {
    fun isHappy(n: Int): Boolean {
        var x = n
        val seen = HashSet<Int>()
        while (x != 1 && x !in seen) {
            seen.add(x)
            x = sumOfSquares(x)
        }
        return x == 1
    }

    private fun sumOfSquares(num: Int): Int {
        var v = num
        var sum = 0
        while (v > 0) {
            val d = v % 10
            sum += d * d
            v /= 10
        }
        return sum
    }
}
```

```kotlin
class Solution {
    fun isHappy(n: Int): Boolean {
        var slow = n
        var fast = n
        do {
            slow = sumOfSquares(slow)                  // move one step
            fast = sumOfSquares(sumOfSquares(fast))    // move two steps
        } while (fast != 1 && slow != fast)
        return fast == 1
    }

    private fun sumOfSquares(num: Int): Int {
        var v = num
        var sum = 0
        while (v > 0) {
            val d = v % 10
            sum += d * d
            v /= 10
        }
        return sum
    }
}
```

## Complexity
- **Time:** `O(k)` where `k` is the number of iterations before reaching `1` or a cycle (bounded for 32-bit integers).  
- **Space:**  
  - HashSet: `O(k)`  
  - Floyd’s algorithm: `O(1)`