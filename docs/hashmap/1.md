# [1. Two Sum](https://leetcode.com/problems/two-sum/description/?envType=study-plan-v2&envId=top-interview-150)

Given an array of integers <code>nums</code>and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.

You may assume that each input would have **exactly one solution** , and you may not use the same element twice.

You can return the answer in any order.

**Example 1:** 

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:** 

```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Example 3:** 

```
Input: nums = [3,3], target = 6
Output: [0,1]
```

**Constraints:** 

- <code>2 <= nums.length <= 10^4</code>
- <code>-10^9 <= nums[i] <= 10^9</code>
- <code>-10^9 <= target <= 10^9</code>
- **Only one valid answer exists.** 

**Follow-up:** Can you come up with an algorithm that is less than <code>O(n^2)</code>time complexity?

## Approach
We want to find two indices `i` and `j` such that `nums[i] + nums[j] == target`.  
A brute-force approach would check all pairs, which costs `O(n^2)` time.  
We can optimize with a **hash map** to store values we have seen and their indices.

Steps:
1. Iterate through `nums`.
2. For each element `x = nums[i]`, compute `complement = target - x`.
3. If `complement` is already in the map, return indices `[map[complement], i]`.
4. Otherwise, add `(x -> i)` into the map.

This ensures each number is processed once.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun twoSum(nums: IntArray, target: Int): IntArray {
        val map = HashMap<Int, Int>()
        for (i in nums.indices) {
            val complement = target - nums[i]
            if (map.containsKey(complement)) {
                return intArrayOf(map[complement]!!, i)
            }
            map[nums[i]] = i
        }
        return intArrayOf() // Should never reach here if one solution guaranteed
    }
}
```

```typescript [TypeScript]
function twoSum(nums: number[], target: number): number[] {
    const map = new Map<number, number>();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement)!, i];
        }
        map.set(nums[i], i);
    }
    return []; // Should never reach here if one solution guaranteed
}
```

```java [Java]
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }
        return new int[]{}; // Should never reach here if one solution guaranteed
    }
}
```

```python [Python]
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        map_dict = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in map_dict:
                return [map_dict[complement], i]
            map_dict[num] = i
        return []  # Should never reach here if one solution guaranteed
```

:::

## Complexity
- **Time Complexity:** O(n)  
  Each element in the array is visited once, and hash map operations (lookup/insert) are O(1) on average.

- **Space Complexity:** O(n)  
  In the worst case, we may store all n elements in the hash map.
