# [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="info" text="Easy" />

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

**Example 1:**

Input:  
`s = "anagram", t = "nagaram"`  
Output:  
`true`

**Example 2:**

Input:  
`s = "rat", t = "car"`  
Output:  
`false`

**Constraints:**
- `1 <= s.length, t.length <= 5 * 10^4`
- `s` and `t` consist of lowercase English letters.

**Follow-up:**  
What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

## Approach — Counting with Hash / Fixed Array

### Idea
- If lengths differ → return `false`.
- Count each char in `s` (+1) and in `t` (−1) using a hash table (or fixed-size array for lowercase letters).
- If any count < 0 → not an anagram.

**Why Hash?**
- Works for all characters (not just a–z).
- Array version is a faster special case if charset is known (e.g., 26 lowercase letters).

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun isAnagram(s: String, t: String): Boolean {
        if (s.length != t.length) return false
        val map = HashMap<Char, Int>()
        for (c in s) map[c] = (map[c] ?: 0) + 1
        for (c in t) {
            val count = (map[c] ?: 0) - 1
            if (count < 0) return false
            map[c] = count
        }
        return true
    }
}
```

```typescript [TypeScript]
function isAnagram(s: string, t: string): boolean {
    if (s.length !== t.length) return false;
    
    const map = new Map<string, number>();
    
    for (const c of s) {
        map.set(c, (map.get(c) || 0) + 1);
    }
    
    for (const c of t) {
        const count = (map.get(c) || 0) - 1;
        if (count < 0) return false;
        map.set(c, count);
    }
    
    return true;
}
```

```java [Java]
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        
        Map<Character, Integer> map = new HashMap<>();
        
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        
        for (char c : t.toCharArray()) {
            int count = map.getOrDefault(c, 0) - 1;
            if (count < 0) return false;
            map.put(c, count);
        }
        
        return true;
    }
}
```

```swift [Swift]
class Solution {
    func isAnagram(_ s: String, _ t: String) -> Bool {
        if s.count != t.count { return false }
        var counts: [Character: Int] = [:]
        for ch in s {
            counts[ch, default: 0] += 1
        }
        for ch in t {
            if let value = counts[ch] {
                if value == 1 {
                    counts.removeValue(forKey: ch)
                } else {
                    counts[ch] = value - 1
                }
            } else {
                return false
            }
        }
        return counts.isEmpty
    }
}
```

```python [Python]
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        
        map_dict = {}
        
        for c in s:
            map_dict[c] = map_dict.get(c, 0) + 1
        
        for c in t:
            count = map_dict.get(c, 0) - 1
            if count < 0:
                return False
            map_dict[c] = count
        
        return True
```

:::

### Complexity
- **Time:** O(n)
- **Space:** O(1) for fixed alphabet, O(k) for k distinct chars.
