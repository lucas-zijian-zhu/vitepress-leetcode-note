# [211. Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/description/?envType=study-plan-v2&envId=top-interview-150)

Design a data structure that supports adding new words and finding if a string matches any previously added string.

Implement the `WordDictionary` class:

- `WordDictionary()` Initializes the object.
- `void addWord(word)` Adds `word` to the data structure, it can be matched later.
- `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `'.'` where dots can be matched with any letter.

**Example 1:**

```
Input
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output
[null,null,null,null,false,true,true,true]

Explanation
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True
```

**Constraints:**

- `1 <= word.length <= 25`
- `word` in `addWord` consists of lowercase English letters.
- `word` in `search` consist of `'.'` or lowercase English letters.
- There will be at most `2 * 10^4` calls to `addWord` and `search`.

## ðŸ’¡ Approach: Trie with DFS for Wildcard Search

### Intuition

This is a variation of the Trie problem where we need to handle **wildcard characters** (`.`). The key challenge is that when we encounter a `.`, we need to search **all possible children** at that level.

### Algorithm

1. **Use Trie structure** similar to problem 208
2. **Add operation**: Same as regular trie insert
3. **Search operation**: 
   - For regular characters: traverse normally
   - For `.` (wildcard): use **DFS** to check all possible children
   - Use recursive helper function for wildcard handling

### Key Points

- When encountering `.`, we need to search all 26 possible children
- Use DFS/recursion to handle the wildcard search
- Ensure we handle the end-of-word check correctly for wildcards
- The recursive search should return early when a match is found

## Code

::: code-group

```kotlin [Kotlin]
class TrieNode {
    val children = Array<TrieNode?>(26) { null }
    var isEndOfWord = false
}

class WordDictionary {
    private val root = TrieNode()

    fun addWord(word: String) {
        var current = root
        for (char in word) {
            val index = char - 'a'
            if (current.children[index] == null) {
                current.children[index] = TrieNode()
            }
            current = current.children[index]!!
        }
        current.isEndOfWord = true
    }

    fun search(word: String): Boolean {
        return searchHelper(word, 0, root)
    }

    private fun searchHelper(word: String, index: Int, node: TrieNode): Boolean {
        if (index == word.length) {
            return node.isEndOfWord
        }

        val char = word[index]
        
        if (char == '.') {
            // Check all possible children for wildcard
            for (child in node.children) {
                if (child != null && searchHelper(word, index + 1, child)) {
                    return true
                }
            }
        } else {
            val childIndex = char - 'a'
            val child = node.children[childIndex]
            if (child != null) {
                return searchHelper(word, index + 1, child)
            }
        }
        
        return false
    }
}
```

```typescript [TypeScript]
class TrieNode {
    children: (TrieNode | null)[] = new Array(26).fill(null);
    isEndOfWord: boolean = false;
}

class WordDictionary {
    private root: TrieNode;

    constructor() {
        this.root = new TrieNode();
    }

    addWord(word: string): void {
        let current = this.root;
        for (const char of word) {
            const index = char.charCodeAt(0) - 'a'.charCodeAt(0);
            if (current.children[index] === null) {
                current.children[index] = new TrieNode();
            }
            current = current.children[index]!;
        }
        current.isEndOfWord = true;
    }

    search(word: string): boolean {
        return this.searchHelper(word, 0, this.root);
    }

    private searchHelper(word: string, index: number, node: TrieNode): boolean {
        if (index === word.length) {
            return node.isEndOfWord;
        }

        const char = word[index];
        
        if (char === '.') {
            // Check all possible children for wildcard
            for (const child of node.children) {
                if (child !== null && this.searchHelper(word, index + 1, child)) {
                    return true;
                }
            }
        } else {
            const childIndex = char.charCodeAt(0) - 'a'.charCodeAt(0);
            const child = node.children[childIndex];
            if (child !== null) {
                return this.searchHelper(word, index + 1, child);
            }
        }
        
        return false;
    }
}
```

```java [Java]
class TrieNode {
    TrieNode[] children;
    boolean isEndOfWord;
    
    public TrieNode() {
        children = new TrieNode[26];
        isEndOfWord = false;
    }
}

class WordDictionary {
    private TrieNode root;
    
    public WordDictionary() {
        root = new TrieNode();
    }
    
    public void addWord(String word) {
        TrieNode current = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (current.children[index] == null) {
                current.children[index] = new TrieNode();
            }
            current = current.children[index];
        }
        current.isEndOfWord = true;
    }
    
    public boolean search(String word) {
        return searchHelper(word, 0, root);
    }
    
    private boolean searchHelper(String word, int index, TrieNode node) {
        if (index == word.length()) {
            return node.isEndOfWord;
        }
        
        char c = word.charAt(index);
        
        if (c == '.') {
            // Check all possible children for wildcard
            for (TrieNode child : node.children) {
                if (child != null && searchHelper(word, index + 1, child)) {
                    return true;
                }
            }
        } else {
            int childIndex = c - 'a';
            if (node.children[childIndex] != null) {
                return searchHelper(word, index + 1, node.children[childIndex]);
            }
        }
        
        return false;
    }
}
```

```python [Python]
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.is_end_of_word = False

class WordDictionary:
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word: str) -> None:
        current = self.root
        for char in word:
            index = ord(char) - ord('a')
            if current.children[index] is None:
                current.children[index] = TrieNode()
            current = current.children[index]
        current.is_end_of_word = True

    def search(self, word: str) -> bool:
        return self._search_helper(word, 0, self.root)

    def _search_helper(self, word: str, index: int, node: TrieNode) -> bool:
        if index == len(word):
            return node.is_end_of_word

        char = word[index]
        
        if char == '.':
            # Check all possible children for wildcard
            for child in node.children:
                if child is not None and self._search_helper(word, index + 1, child):
                    return True
        else:
            child_index = ord(char) - ord('a')
            child = node.children[child_index]
            if child is not None:
                return self._search_helper(word, index + 1, child)
        
        return False
```

:::

## Complexity

- **Time Complexity:** 
  - `addWord`: O(M) where M is the length of the word
  - `search`: O(N Ã— 26^K) where N is the number of words in the dictionary and K is the number of dots in the search word. In the worst case, we might need to check all combinations.
- **Space Complexity:** O(ALPHABET_SIZE * M * N) where M is the average length of words and N is the number of words stored in the dictionary.
