# [212. Word Search II](https://leetcode.com/problems/word-search-ii/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="danger" text="Hard" />

Given an `m x n` `board` of characters and a list of strings `words`, return all words on the board.

Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

**Example 1:**
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" style="width: 322px; height: 322px;">

```
Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
```

**Example 2:**
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" style="width: 322px; height: 322px;">

```
Input: board = [["a","b"],["c","d"]], words = ["abcb"]
Output: []
```

**Constraints:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 12`
- `board[i][j]` is a lowercase English letter.
- `1 <= words.length <= 3 * 10^4`
- `1 <= words[i].length <= 10`
- `words[i]` consists of lowercase English letters.
- All the values of `words` are **unique**.

## ðŸ’¡ Approach: Trie + Backtracking

### Intuition

This problem combines **Trie** data structure with **Backtracking** DFS to efficiently search for multiple words on a 2D board:

1. **Build a Trie** from all the words to search for efficient prefix checking
2. **DFS on the board** starting from each cell
3. **Use Trie** to guide the search and avoid exploring invalid paths early
4. **Backtrack** when no valid words can be formed from current path

### Algorithm

1. **Build Trie** from the `words` array for efficient searching
2. **For each cell** on the board, start DFS search
3. **During DFS**:
   - Check if current character exists in Trie
   - If end of word is reached, add to results and optionally remove from Trie (to avoid duplicates)
   - Continue DFS to adjacent cells (up, down, left, right)
   - Mark current cell as visited and backtrack after exploring

### Key Points

- Use Trie to efficiently check if current path can lead to valid words
- Mark cells as visited during DFS and unmark during backtrack
- Remove found words from Trie to avoid duplicates (optional optimization)
- Prune search early when Trie path doesn't exist

## Code

::: code-group

```typescript [TypeScript]
class TrieNode {
    children: Map<string, TrieNode> = new Map();
    word: string | null = null;
}

function findWords(board: string[][], words: string[]): string[] {
    const root = buildTrie(words);
    const result = new Set<string>();
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    
    function dfs(row: number, col: number, node: TrieNode): void {
        // Check bounds and if cell is visited
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) return;
        if (board[row][col] === '#') return;
        
        const char = board[row][col];
        const nextNode = node.children.get(char);
        if (!nextNode) return;  // Early termination
        
        // Check if we found a complete word
        if (nextNode.word) {
            result.add(nextNode.word);
            nextNode.word = null;  // Avoid duplicates
        }
        
        // Mark current cell as visited
        const originalChar = board[row][col];
        board[row][col] = '#';
        
        // Explore all 4 directions
        for (const [dr, dc] of directions) {
            dfs(row + dr, col + dc, nextNode);
        }
        
        // Backtrack: restore the original character
        board[row][col] = originalChar;
    }
    
    // DFS from each cell
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[0].length; j++) {
            dfs(i, j, root);
        }
    }
    
    return Array.from(result);
}

function buildTrie(words: string[]): TrieNode {
    const root = new TrieNode();
    for (const word of words) {
        let node = root;
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char)!;
        }
        node.word = word;
    }
    return root;
}
```

```kotlin [Kotlin]
class TrieNode {
    val children = mutableMapOf<Char, TrieNode>()
    var word: String? = null
}

class Solution {
    private val directions = arrayOf(
        intArrayOf(0, 1), intArrayOf(0, -1),
        intArrayOf(1, 0), intArrayOf(-1, 0)
    )
    
    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {
        // Build Trie from words
        val root = buildTrie(words)
        val result = mutableSetOf<String>()
        
        // DFS from each cell
        for (i in board.indices) {
            for (j in board[0].indices) {
                dfs(board, i, j, root, result)
            }
        }
        
        return result.toList()
    }
    
    private fun buildTrie(words: Array<String>): TrieNode {
        val root = TrieNode()
        for (word in words) {
            var node = root
            for (char in word) {
                node.children[char] = node.children.getOrDefault(char, TrieNode())
                node = node.children[char]!!
            }
            node.word = word
        }
        return root
    }
    
    private fun dfs(board: Array<CharArray>, row: Int, col: Int, node: TrieNode, result: MutableSet<String>) {
        // Check bounds and if cell is visited
        if (row < 0 || row >= board.size || col < 0 || col >= board[0].size) return
        if (board[row][col] == '#') return
        
        val char = board[row][col]
        val nextNode = node.children[char] ?: return  // Early termination if path doesn't exist
        
        // Check if we found a complete word
        nextNode.word?.let { word ->
            result.add(word)
            nextNode.word = null  // Avoid duplicates
        }
        
        // Mark current cell as visited
        board[row][col] = '#'
        
        // Explore all 4 directions
        for (direction in directions) {
            val newRow = row + direction[0]
            val newCol = col + direction[1]
            dfs(board, newRow, newCol, nextNode, result)
        }
        
        // Backtrack: restore the original character
        board[row][col] = char
    }
}
```

```java [Java]
class TrieNode {
    Map<Character, TrieNode> children;
    String word;
    
    public TrieNode() {
        children = new HashMap<>();
        word = null;
    }
}

class Solution {
    private int[][] directions = {â€‹{0, 1}, {0, -1}, {1, 0}, {-1, 0}â€‹};
    
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = buildTrie(words);
        Set<String> result = new HashSet<>();
        
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                dfs(board, i, j, root, result);
            }
        }
        
        return new ArrayList<>(result);
    }
    
    private TrieNode buildTrie(String[] words) {
        TrieNode root = new TrieNode();
        for (String word : words) {
            TrieNode node = root;
            for (char c : word.toCharArray()) {
                node.children.putIfAbsent(c, new TrieNode());
                node = node.children.get(c);
            }
            node.word = word;
        }
        return root;
    }
    
    private void dfs(char[][] board, int row, int col, TrieNode node, Set<String> result) {
        // Check bounds and if cell is visited
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) return;
        if (board[row][col] == '#') return;
        
        char c = board[row][col];
        TrieNode nextNode = node.children.get(c);
        if (nextNode == null) return;  // Early termination
        
        // Check if we found a complete word
        if (nextNode.word != null) {
            result.add(nextNode.word);
            nextNode.word = null;  // Avoid duplicates
        }
        
        // Mark current cell as visited
        board[row][col] = '#';
        
        // Explore all 4 directions
        for (int[] direction : directions) {
            dfs(board, row + direction[0], col + direction[1], nextNode, result);
        }
        
        // Backtrack: restore the original character
        board[row][col] = c;
    }
}
```

```swift [Swift]
class TrieNode {
    var children: [Character: TrieNode] = [:]
    var word: String?
}

class Solution {
    private let directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {
        let root = buildTrie(words)
        var result: Set<String> = []
        var grid = board
        for i in 0..<grid.count {
            for j in 0..<grid[0].count {
                dfs(&grid, i, j, root, &result)
            }
        }
        return Array(result)
    }

    private func buildTrie(_ words: [String]) -> TrieNode {
        let root = TrieNode()
        for word in words {
            var node = root
            for char in word {
                if node.children[char] == nil { node.children[char] = TrieNode() }
                node = node.children[char]!
            }
            node.word = word
        }
        return root
    }

    private func dfs(_ board: inout [[Character]], _ row: Int, _ col: Int, _ node: TrieNode, _ result: inout Set<String>) {
        if row < 0 || row >= board.count || col < 0 || col >= board[0].count { return }
        if board[row][col] == "#" { return }
        let c = board[row][col]
        guard let nextNode = node.children[c] else { return }
        if let word = nextNode.word {
            result.insert(word)
            nextNode.word = nil
        }
        board[row][col] = "#"
        for (dr, dc) in directions {
            dfs(&board, row + dr, col + dc, nextNode, &result)
        }
        board[row][col] = c
    }
}
```

```python [Python]
class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        root = self.build_trie(words)
        result = set()
        
        def dfs(row, col, node):
            # Check bounds and if cell is visited
            if (row < 0 or row >= len(board) or 
                col < 0 or col >= len(board[0]) or 
                board[row][col] == '#'):
                return
            
            char = board[row][col]
            next_node = node.children.get(char)
            if not next_node:
                return  # Early termination
            
            # Check if we found a complete word
            if next_node.word:
                result.add(next_node.word)
                next_node.word = None  # Avoid duplicates
            
            # Mark current cell as visited
            board[row][col] = '#'
            
            # Explore all 4 directions
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            for dr, dc in directions:
                dfs(row + dr, col + dc, next_node)
            
            # Backtrack: restore the original character
            board[row][col] = char
        
        # DFS from each cell
        for i in range(len(board)):
            for j in range(len(board[0])):
                dfs(i, j, root)
        
        return list(result)
    
    def build_trie(self, words):
        root = TrieNode()
        for word in words:
            node = root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.word = word
        return root
```

:::
## Complexity

- **Time Complexity:** O(M Ã— N Ã— 4^L), where MÃ—N is the board size and L is the maximum length of words. In worst case, we explore 4 directions for each cell up to L depth.
- **Space Complexity:** O(W Ã— L), where W is the number of words and L is the average length of words for the Trie, plus O(L) for the recursion stack during DFS.
