# 71. Simplify Path

You are given an absolute path for a Unix-style file system, which always begins with a slash `/`. Your task is to transform this absolute path into its **simplified canonical path**.

## Rules of Unix-style file system

- A single period `.` represents the current directory.
- A double period `..` represents the previous/parent directory.
- Multiple consecutive slashes such as `//` or `///` are treated as a single slash `/`.
- Any sequence of periods that does **not match** the rules above should be treated as a **valid directory or file name**. For example, `...` and `....` are valid directory or file names.

## Simplified canonical path requirements

- The path must start with a single slash `/`.
- Directories within the path must be separated by exactly one slash `/`.
- The path must not end with a slash `/`, unless it is the root directory.
- The path must not have any single or double periods (`.` and `..`) used to denote current or parent directories.

Return the **simplified canonical path**.

## Examples

### Example 1

**Input:**  
`path = "/home/"`  

**Output:**  
`"/home"`  

**Explanation:**  
The trailing slash should be removed.

### Example 2

**Input:**  
`path = "/home//foo/"`  

**Output:**  
`"/home/foo"`  

**Explanation:**  
Multiple consecutive slashes are replaced by a single one.

### Example 3

**Input:**  
`path = "/home/user/Documents/../Pictures"`  

**Output:**  
`"/home/user/Pictures"`  

**Explanation:**  
A double period `".."` refers to the directory up a level (the parent directory).

### Example 4

**Input:**  
`path = "/../"`  

**Output:**  
`"/"`  

**Explanation:**  
Going one level up from the root directory is not possible.

### Example 5

**Input:**  
`path = "/.../a/../b/c/../d/./"`  

**Output:**  
`"/.../b/d"`  

**Explanation:**  
`"..."` is a valid name for a directory in this problem.

## Constraints

- `1 <= path.length <= 3000`
- `path` consists of English letters, digits, period `.`, slash `/`, or `_`.
- `path` is a valid absolute Unix path.


## Approach

1. Split the path by `/` to get each directory component.
2. Use a stack to keep track of valid directory names:
   - Ignore empty strings and `.`.
   - If `..`, pop from the stack if it's not empty.
   - Otherwise, push the directory name onto the stack.
3. Join the stack elements with `/` and prepend `/` to get the canonical path.

## Kotlin Code

```kotlin
class Solution {
    fun simplifyPath(path: String): String {
        val stack = mutableListOf<String>()
        val components = path.split("/")

        for (comp in components) {
            when {
                comp.isEmpty() || comp == "." -> continue
                comp == ".." -> if (stack.isNotEmpty()) stack.removeAt(stack.size - 1)
                else -> stack.add(comp)
            }
        }

        return "/" + stack.joinToString("/")
    }
}
```

## Time & Space Complexity

- **Time Complexity:** `O(n)` — each character is processed at most twice (split + stack operations).  
- **Space Complexity:** `O(n)` — the stack stores directory names, which in the worst case is proportional to the number of path components.
