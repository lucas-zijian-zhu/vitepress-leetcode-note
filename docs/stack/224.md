# [224. Basic Calculator](https://leetcode.com/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150)

Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.

**Note:**  You are **not**  allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.

**Example 1:** 

```
Input: s = "1 + 1"
Output: 2
```

**Example 2:** 

```
Input: s = " 2-1 + 2 "
Output: 3
```

**Example 3:** 

```
Input: s = "(1+(4+5+2)-3)+(6+8)"
Output: 23
```

**Constraints:** 

- <code>1 <= s.length <= 3 * 10^5</code>
- <code>s</code> consists of digits, <code>'+'</code>, <code>'-'</code>, <code>'('</code>, <code>')'</code>, and <code>' '</code>.
- <code>s</code> represents a valid expression.
- <code>'+'</code> is **not**  used as a unary operation (i.e., <code>"+1"</code> and <code>"+(2 + 3)"</code> is invalid).
- <code>'-'</code> could be used as a unary operation (i.e., <code>"-1"</code> and <code>"-(2 + 3)"</code> is valid).
- There will be no two consecutive operators in the input.
- Every number and running calculation will fit in a signed 32-bit integer.

## Approach

1. **Use a Stack for signs:**  
   - Traverse the string character by character.
   - Keep a running total `result` and a `sign` (1 or -1) for the current number.
   - When encountering `'('`, push the current `result` and `sign` onto a stack and reset `result` and `sign`.
   - When encountering `')'`, pop the previous `sign` and `result` from the stack, and combine them with the current `result`.
2. **Parse numbers:**  
   - When encountering a digit, build the number until the end of the consecutive digits.
3. **Update result:**  
   - When encountering `'+'` or `'-'`, update the current `sign`.
4. **Ignore spaces.**

**Key idea:** The stack keeps track of the cumulative result and the sign before each parenthesis, allowing you to handle nested expressions efficiently.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun calculate(s: String): Int {
        var result = 0
        var number = 0
        var sign = 1
        val stack = mutableListOf<Int>()

        var i = 0
        while (i < s.length) {
            when (val c = s[i]) {
                in '0'..'9' -> {
                    number = 0
                    while (i < s.length && s[i].isDigit()) {
                        number = number * 10 + (s[i] - '0')
                        i++
                    }
                    result += sign * number
                    continue
                }
                '+' -> sign = 1
                '-' -> sign = -1
                '(' -> {
                    stack.add(result)
                    stack.add(sign)
                    result = 0
                    sign = 1
                }
                ')' -> {
                    val prevSign = stack.removeAt(stack.size - 1)
                    val prevResult = stack.removeAt(stack.size - 1)
                    result = prevResult + prevSign * result
                }
            }
            i++
        }
        return result
    }
}
```

```typescript [TypeScript]
function calculate(s: string): number {
    let result = 0;
    let number = 0;
    let sign = 1;
    const stack: number[] = [];

    let i = 0;
    while (i < s.length) {
        const c = s[i];
        if (c >= '0' && c <= '9') {
            number = 0;
            while (i < s.length && s[i] >= '0' && s[i] <= '9') {
                number = number * 10 + (s[i].charCodeAt(0) - '0'.charCodeAt(0));
                i++;
            }
            result += sign * number;
            continue;
        } else if (c === '+') {
            sign = 1;
        } else if (c === '-') {
            sign = -1;
        } else if (c === '(') {
            stack.push(result);
            stack.push(sign);
            result = 0;
            sign = 1;
        } else if (c === ')') {
            const prevSign = stack.pop()!;
            const prevResult = stack.pop()!;
            result = prevResult + prevSign * result;
        }
        i++;
    }
    
    return result;
}
```

```java [Java]
class Solution {
    public int calculate(String s) {
        int result = 0;
        int number = 0;
        int sign = 1;
        Stack<Integer> stack = new Stack<>();

        int i = 0;
        while (i < s.length()) {
            char c = s.charAt(i);
            if (c >= '0' && c <= '9') {
                number = 0;
                while (i < s.length() && Character.isDigit(s.charAt(i))) {
                    number = number * 10 + (s.charAt(i) - '0');
                    i++;
                }
                result += sign * number;
                continue;
            } else if (c == '+') {
                sign = 1;
            } else if (c == '-') {
                sign = -1;
            } else if (c == '(') {
                stack.push(result);
                stack.push(sign);
                result = 0;
                sign = 1;
            } else if (c == ')') {
                int prevSign = stack.pop();
                int prevResult = stack.pop();
                result = prevResult + prevSign * result;
            }
            i++;
        }
        
        return result;
    }
}
```

```python [Python]
class Solution:
    def calculate(self, s: str) -> int:
        result = 0
        number = 0
        sign = 1
        stack = []

        i = 0
        while i < len(s):
            c = s[i]
            if c.isdigit():
                number = 0
                while i < len(s) and s[i].isdigit():
                    number = number * 10 + int(s[i])
                    i += 1
                result += sign * number
                continue
            elif c == '+':
                sign = 1
            elif c == '-':
                sign = -1
            elif c == '(':
                stack.append(result)
                stack.append(sign)
                result = 0
                sign = 1
            elif c == ')':
                prev_sign = stack.pop()
                prev_result = stack.pop()
                result = prev_result + prev_sign * result
            i += 1

        return result
```

:::

## Complexity

- **Time complexity:** `O(n)` — each character is processed once.
- **Space complexity:** `O(n)` — for the stack in case of nested parentheses.
