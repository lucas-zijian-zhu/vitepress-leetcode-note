# [224. Basic Calculator](https://leetcode.com/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150)

Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.

**Note:**  You are **not**  allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.

**Example 1:** 

```
Input: s = "1 + 1"
Output: 2
```

**Example 2:** 

```
Input: s = " 2-1 + 2 "
Output: 3
```

**Example 3:** 

```
Input: s = "(1+(4+5+2)-3)+(6+8)"
Output: 23
```

**Constraints:** 

- <code>1 <= s.length <= 3 * 10^5</code>
- <code>s</code> consists of digits, <code>'+'</code>, <code>'-'</code>, <code>'('</code>, <code>')'</code>, and <code>' '</code>.
- <code>s</code> represents a valid expression.
- <code>'+'</code> is **not**  used as a unary operation (i.e., <code>"+1"</code> and <code>"+(2 + 3)"</code> is invalid).
- <code>'-'</code> could be used as a unary operation (i.e., <code>"-1"</code> and <code>"-(2 + 3)"</code> is valid).
- There will be no two consecutive operators in the input.
- Every number and running calculation will fit in a signed 32-bit integer.

## Approach

1. **Use a Stack for signs:**  
   - Traverse the string character by character.
   - Keep a running total `result` and a `sign` (1 or -1) for the current number.
   - When encountering `'('`, push the current `result` and `sign` onto a stack and reset `result` and `sign`.
   - When encountering `')'`, pop the previous `sign` and `result` from the stack, and combine them with the current `result`.
2. **Parse numbers:**  
   - When encountering a digit, build the number until the end of the consecutive digits.
3. **Update result:**  
   - When encountering `'+'` or `'-'`, update the current `sign`.
4. **Ignore spaces.**

**Key idea:** The stack keeps track of the cumulative result and the sign before each parenthesis, allowing you to handle nested expressions efficiently.

## Kotlin Code

```kotlin
class Solution {
    fun calculate(s: String): Int {
        var result = 0
        var number = 0
        var sign = 1
        val stack = mutableListOf<Int>()

        var i = 0
        while (i < s.length) {
            when (val c = s[i]) {
                in '0'..'9' -> {
                    number = 0
                    while (i < s.length && s[i].isDigit()) {
                        number = number * 10 + (s[i] - '0')
                        i++
                    }
                    result += sign * number
                    continue
                }
                '+' -> sign = 1
                '-' -> sign = -1
                '(' -> {
                    stack.add(result)
                    stack.add(sign)
                    result = 0
                    sign = 1
                }
                ')' -> {
                    val prevSign = stack.removeAt(stack.size - 1)
                    val prevResult = stack.removeAt(stack.size - 1)
                    result = prevResult + prevSign * result
                }
            }
            i++
        }
        return result
    }
}
```

## Complexity

- **Time complexity:** `O(n)` — each character is processed once.
- **Space complexity:** `O(n)` — for the stack in case of nested parentheses.
