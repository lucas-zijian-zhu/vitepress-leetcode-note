# 20. Valid Parentheses

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

- Open brackets must be closed by the same type of brackets.
- Open brackets must be closed in the correct order.
- Every close bracket has a corresponding open bracket of the same type.

## Example 1

Input: `s = "()"`  
Output: `true`

## Example 2

Input: `s = "()[]{}"`  
Output: `true`

## Example 3

Input: `s = "(]"`  
Output: `false`

## Example 4

Input: `s = "([])"`  
Output: `true`

## Example 5

Input: `s = "([)]"`  
Output: `false`

## Constraints

- `1 <= s.length <= 10^4`
- `s` consists of parentheses only `'()[]{}'`.

## Approach

We can use a **stack** to solve this problem:

1. Initialize an empty stack.
2. Iterate through each character `c` in the string:
   - If `c` is an **opening bracket** (`(`, `{`, `[`), push it onto the stack.
   - If `c` is a **closing bracket** (`)`, `}`, `]`):
     - Check if the stack is empty. If it is, return `false`.
     - Otherwise, pop the top element from the stack and check if it matches the type of `c`. If it does not match, return `false`.
3. After iterating, if the stack is empty, all brackets were matched correctly, return `true`; otherwise, return `false`.

## Code

::: code-group

```kotlin [Kotlin]
fun isValid(s: String): Boolean {
    val stack = mutableListOf<Char>()
    val map = mapOf(')' to '(', '}' to '{', ']' to '[')

    for (c in s) {
        if (c in map.values) {
            stack.add(c)
        } else if (c in map.keys) {
            if (stack.isEmpty() || stack.last() != map[c]) return false
            stack.removeAt(stack.size - 1)
        }
    }
    return stack.isEmpty()
}
```

```typescript [TypeScript]
function isValid(s: string): boolean {
    const stack: string[] = [];
    const map: { [key: string]: string } = {
        ')': '(',
        '}': '{',
        ']': '['
    };

    for (const c of s) {
        if (Object.values(map).includes(c)) {
            stack.push(c);
        } else if (c in map) {
            if (stack.length === 0 || stack.pop() !== map[c]) {
                return false;
            }
        }
    }
    
    return stack.length === 0;
}
```

```java [Java]
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        Map<Character, Character> map = new HashMap<>();
        map.put(')', '(');
        map.put('}', '{');
        map.put(']', '[');

        for (char c : s.toCharArray()) {
            if (map.containsValue(c)) {
                stack.push(c);
            } else if (map.containsKey(c)) {
                if (stack.isEmpty() || stack.pop() != map.get(c)) {
                    return false;
                }
            }
        }
        
        return stack.isEmpty();
    }
}
```

```python [Python]
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mapping = {')': '(', '}': '{', ']': '['}

        for char in s:
            if char in mapping.values():
                stack.append(char)
            elif char in mapping:
                if not stack or stack.pop() != mapping[char]:
                    return False
        
        return len(stack) == 0
```

:::

## Complexity Analysis

- **Time Complexity:** `O(n)`, where `n` is the length of the string. We process each character exactly once.  
- **Space Complexity:** `O(n)`, in the worst case we may store all opening brackets in the stack.
