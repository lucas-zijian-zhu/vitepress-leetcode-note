# [67. Add Binary](https://leetcode.com/problems/add-binary/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="info" text="Easy" />

Given two binary strings <code>a</code> and <code>b</code>, return their sum as a binary string.

**Example 1:** 

```
Input: a = "11", b = "1"
Output: "100"
```

**Example 2:** 

```
Input: a = "1010", b = "1011"
Output: "10101"
```

**Constraints:** 

- <code>1 <= a.length, b.length <= 10^4</code>
- <code>a</code> and <code>b</code> consist only of <code>'0'</code> or <code>'1'</code> characters.
- Each string does not contain leading zeros except for the zero itself.

## ðŸ’¡ Approach: String Manipulation with Carry

### Intuition

This problem is similar to adding two numbers, but we're working with binary strings. We need to:
1. Process both strings from right to left (least significant bit first)
2. Add corresponding bits along with any carry from the previous position
3. Handle different string lengths
4. Reverse the result at the end since we built it backwards

**Key Insight:**
- Binary addition: `sum = a + b + carry`, result bit = `sum % 2`, new carry = `sum / 2`
- Similar to decimal addition but with base 2 instead of base 10

### Algorithm

1. **Initialize pointers** at the end of both strings: `i = a.length - 1`, `j = b.length - 1`
2. **Initialize carry** = 0 and result string builder
3. **While there are digits or carry:**
   - Get digit from `a` at position `i` (or 0 if out of bounds)
   - Get digit from `b` at position `j` (or 0 if out of bounds)
   - Calculate `sum = digitA + digitB + carry`
   - Append `sum % 2` to result
   - Update `carry = sum / 2`
   - Decrement `i` and `j`
4. **Reverse the result** and return

### Key Points

- Process strings from right to left (least significant bit first)
- Handle different string lengths by treating out-of-bounds as 0
- Don't forget to reverse the result at the end
- Handle edge case where final carry is 1

## Code

::: code-group

```typescript [TypeScript]
function addBinary(a: string, b: string): string {
    const result: string[] = [];
    let i = a.length - 1;
    let j = b.length - 1;
    let carry = 0;
    
    while (i >= 0 || j >= 0 || carry > 0) {
        const digitA = i >= 0 ? parseInt(a[i]) : 0;
        const digitB = j >= 0 ? parseInt(b[j]) : 0;
        
        const sum = digitA + digitB + carry;
        result.push((sum % 2).toString());
        carry = Math.floor(sum / 2);
        
        i--;
        j--;
    }
    
    return result.reverse().join('');
}
```

```kotlin [Kotlin]
class Solution {
    fun addBinary(a: String, b: String): String {
        val result = StringBuilder()
        var i = a.length - 1
        var j = b.length - 1
        var carry = 0
        
        while (i >= 0 || j >= 0 || carry > 0) {
            val digitA = if (i >= 0) a[i] - '0' else 0
            val digitB = if (j >= 0) b[j] - '0' else 0
            
            val sum = digitA + digitB + carry
            result.append(sum % 2)
            carry = sum / 2
            
            i--
            j--
        }
        
        return result.reverse().toString()
    }
}
```

```java [Java]
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder result = new StringBuilder();
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;
        
        while (i >= 0 || j >= 0 || carry > 0) {
            int digitA = (i >= 0) ? a.charAt(i) - '0' : 0;
            int digitB = (j >= 0) ? b.charAt(j) - '0' : 0;
            
            int sum = digitA + digitB + carry;
            result.append(sum % 2);
            carry = sum / 2;
            
            i--;
            j--;
        }
        
        return result.reverse().toString();
    }
}
```

```swift [Swift]
class Solution {
    func addBinary(_ a: String, _ b: String) -> String {
        let aChars = Array(a)
        let bChars = Array(b)
        var i = aChars.count - 1
        var j = bChars.count - 1
        var carry = 0
        var result: [Character] = []

        while i >= 0 || j >= 0 || carry > 0 {
            let bitA = i >= 0 ? Int(String(aChars[i]))! : 0
            let bitB = j >= 0 ? Int(String(bChars[j]))! : 0
            let sum = bitA + bitB + carry
            result.append(Character(String(sum % 2)))
            carry = sum / 2
            if i >= 0 { i -= 1 }
            if j >= 0 { j -= 1 }
        }

        return String(result.reversed())
    }
}
```

```python [Python]
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        result = []
        i, j = len(a) - 1, len(b) - 1
        carry = 0
        
        while i >= 0 or j >= 0 or carry:
            digit_a = int(a[i]) if i >= 0 else 0
            digit_b = int(b[j]) if j >= 0 else 0
            
            total = digit_a + digit_b + carry
            result.append(str(total % 2))
            carry = total // 2
            
            i -= 1
            j -= 1
        
        return ''.join(reversed(result))
```

:::
## Complexity

- **Time Complexity:** O(max(m, n)), where m and n are the lengths of strings a and b. We process each character once.
- **Space Complexity:** O(max(m, n)), for the result string

