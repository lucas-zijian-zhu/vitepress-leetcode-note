# [137. Single Number II](https://leetcode.com/problems/single-number-ii/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given an integer array <code>nums</code> where every element appears **three times** except for one, which appears **exactly once**. Find the single element and return it.

You must implement a solution with linear runtime complexity and use only constant extra space.

**Example 1:** 

```
Input: nums = [2,2,3,2]
Output: 3
```

**Example 2:** 

```
Input: nums = [0,1,0,1,0,1,99]
Output: 99
```

**Constraints:** 

- <code>1 <= nums.length <= 3 * 10^4</code>
- <code>-2^31 <= nums[i] <= 2^31 - 1</code>
- Each element in <code>nums</code> appears exactly **three times** except for one element which appears **once**.

## ðŸ’¡ Approach: Bit Counting Mod 3

### Intuition

If we count how many times each bit (0..31) is set across all numbers, multiples of three belong to the triplicates. The leftover bit counts (modulo 3) belong to the unique number.

**Key Insight:** For each bit position, the total count of set bits modulo 3 equals that bit in the single number.

### Algorithm

1. Initialize `result = 0`.
2. For each bit position `i` from 0 to 31:
   - Count how many numbers have bit `i` set.
   - If count % 3 != 0, set bit `i` in `result`.
3. Handle sign bit (if bit 31 is set, convert to negative using two's complement).

### Alternative: Bitmask State Machine

Track bits that have appeared once (`ones`) and twice (`twos`). For each number:
- Update `ones` with bits seen once but not twice: `ones = (ones ^ num) & ~twos`
- Update `twos` with bits seen twice but not once: `twos = (twos ^ num) & ~ones`

After processing all numbers, `ones` holds the single number.

### Key Points

- Both methods run in O(n) time and O(1) extra space.
- The bit counting method is straightforward; the state machine avoids looping over bits.

## Code

::: code-group

```kotlin [Kotlin - Bit Counting]
class Solution {
    fun singleNumber(nums: IntArray): Int {
        var result = 0
        for (i in 0 until 32) {
            var count = 0
            for (num in nums) {
                if ((num shr i) and 1 == 1) count++
            }
            if (count % 3 != 0) {
                result = result or (1 shl i)
            }
        }
        return result
    }
}
```

```kotlin [Kotlin - Bitmask State Machine]
class Solution {
    fun singleNumber(nums: IntArray): Int {
        var ones = 0
        var twos = 0
        for (num in nums) {
            ones = (ones xor num) and twos.inv()
            twos = (twos xor num) and ones.inv()
        }
        return ones
    }
}
```

```typescript [TypeScript - Bitmask State Machine]
function singleNumber(nums: number[]): number {
    let ones = 0
    let twos = 0
    for (const num of nums) {
        ones = (ones ^ num) & ~twos
        twos = (twos ^ num) & ~ones
    }
    return ones
}
```

```java [Java - Bitmask State Machine]
class Solution {
    public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for (int num : nums) {
            ones = (ones ^ num) & ~twos;
            twos = (twos ^ num) & ~ones;
        }
        return ones;
    }
}
```

```python [Python - Bitmask State Machine]
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ones = 0
        twos = 0
        for num in nums:
            ones = (ones ^ num) & ~twos
            twos = (twos ^ num) & ~ones
        return ones
```

:::

## Complexity

- **Time Complexity:** O(n), single pass through the array (plus 32 * n for bit counting variant).
- **Space Complexity:** O(1), constant extra space.