# [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="info" text="Easy" />

Write a function that takes the binary representation of a positive integer and returns the number of **set bits** it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).

**Example 1:** 

```
Input: n = 11
Output: 3
Explanation: The input binary string "1011" has a total of three set bits.
```

**Example 2:** 

```
Input: n = 128
Output: 1
Explanation: The input binary string "10000000" has a total of one set bit.
```

**Example 3:** 

```
Input: n = 2147483645
Output: 30
Explanation: The input binary string "1111111111111111111111111111101" has a total of thirty set bits.
```

**Constraints:** 

- <code>1 <= n <= 2^31 - 1</code>

**Follow up:** If this function is called many times, how would you optimize it?

## ðŸ’¡ Approach: Bit Manipulation

### Intuition

We need to count the number of 1s in the binary representation of a number. There are several approaches:

**Method 1: Loop and Shift**
- Iterate through each bit
- Count how many bits are set to 1

**Method 2: Brian Kernighan's Algorithm (Optimized)**
- Use `n & (n - 1)` to flip the rightmost set bit
- Count how many times we can do this until n becomes 0
- This is more efficient as it only iterates over set bits

**Key Insight:**
- `n & (n - 1)` removes the rightmost set bit
- Each iteration removes exactly one set bit
- Number of iterations = number of set bits

### Algorithm

**Method 1: Loop and Shift**
1. Initialize count = 0
2. While n > 0:
   - If `n & 1 == 1`, increment count
   - Right shift n by 1: `n >>= 1`
3. Return count

**Method 2: Brian Kernighan's Algorithm (Recommended)**
1. Initialize count = 0
2. While n > 0:
   - `n = n & (n - 1)` (removes rightmost set bit)
   - Increment count
3. Return count

### Key Points

- Method 1: O(32) = O(1) time, always checks all 32 bits
- Method 2: O(k) time where k is the number of set bits (more efficient when few bits are set)
- Both methods use O(1) space

## Code

::: code-group

```kotlin [Kotlin - Method 1]
class Solution {
    fun hammingWeight(n: Int): Int {
        var num = n
        var count = 0
        
        while (num != 0) {
            if (num and 1 == 1) {
                count++
            }
            num = num ushr 1  // Unsigned right shift
        }
        
        return count
    }
}
```

```kotlin [Kotlin - Method 2: Brian Kernighan]
class Solution {
    fun hammingWeight(n: Int): Int {
        var num = n
        var count = 0
        
        while (num != 0) {
            num = num and (num - 1)  // Remove rightmost set bit
            count++
        }
        
        return count
    }
}
```

```typescript [TypeScript - Method 1]
function hammingWeight(n: number): number {
    let count = 0;
    
    while (n !== 0) {
        if ((n & 1) === 1) {
            count++;
        }
        n = n >>> 1;  // Unsigned right shift
    }
    
    return count;
}
```

```typescript [TypeScript - Method 2: Brian Kernighan]
function hammingWeight(n: number): number {
    let count = 0;
    
    while (n !== 0) {
        n = n & (n - 1);  // Remove rightmost set bit
        count++;
    }
    
    return count;
}
```

```java [Java - Method 1]
public class Solution {
    public int hammingWeight(int n) {
        int count = 0;
        
        while (n != 0) {
            if ((n & 1) == 1) {
                count++;
            }
            n = n >>> 1;  // Unsigned right shift
        }
        
        return count;
    }
}
```

```java [Java - Method 2: Brian Kernighan]
public class Solution {
    public int hammingWeight(int n) {
        int count = 0;
        
        while (n != 0) {
            n = n & (n - 1);  // Remove rightmost set bit
            count++;
        }
        
        return count;
    }
}
```

```python [Python - Method 1]
class Solution:
    def hammingWeight(self, n: int) -> int:
        count = 0
        
        while n:
            if n & 1:
                count += 1
            n = n >> 1
        
        return count
```

```python [Python - Method 2: Brian Kernighan]
class Solution:
    def hammingWeight(self, n: int) -> int:
        count = 0
        
        while n:
            n = n & (n - 1)  # Remove rightmost set bit
            count += 1
        
        return count
```

:::

## Complexity

### Method 1: Loop and Shift
- **Time Complexity:** O(32) = O(1), always checks all 32 bits
- **Space Complexity:** O(1)

### Method 2: Brian Kernighan's Algorithm
- **Time Complexity:** O(k), where k is the number of set bits (more efficient)
- **Space Complexity:** O(1)

## Follow-up Optimization

If this function is called many times, we can optimize further:

1. **Lookup Table:** Pre-compute Hamming weight for all 8-bit values (0-255), then process 32-bit number in 4 chunks
   - Time: O(1) with O(256) space
   - Example: `count = table[n & 0xFF] + table[(n >> 8) & 0xFF] + table[(n >> 16) & 0xFF] + table[(n >> 24) & 0xFF]`

2. **Built-in Functions:** Many languages have built-in functions:
   - Python: `bin(n).count('1')` or `n.bit_count()`
   - Java: `Integer.bitCount(n)`
   - Kotlin: `n.countOneBits()`