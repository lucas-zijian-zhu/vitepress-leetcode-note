import{_ as t,c as o,o as a,ag as n}from"./chunks/framework.Bw-5EFTY.js";const h=JSON.parse('{"title":"JavaScript Strings: Common Methods and Operations (English)","description":"","frontmatter":{},"headers":[],"relativePath":"reading-notes/web/js-string.en.md","filePath":"reading-notes/web/js-string.en.md"}'),s={name:"reading-notes/web/js-string.en.md"};function c(d,e,r,i,l,u){return a(),o("div",null,e[0]||(e[0]=[n(`<h1 id="javascript-strings-common-methods-and-operations-english" tabindex="-1">JavaScript Strings: Common Methods and Operations (English) <a class="header-anchor" href="#javascript-strings-common-methods-and-operations-english" aria-label="Permalink to &quot;JavaScript Strings: Common Methods and Operations (English)&quot;">​</a></h1><p><a href="/reading-notes/web/js-string.html">中文</a></p><p>This note summarizes common JS string APIs, operations, and one practice task: sentence-capitalization plus name normalization.</p><h2 id="_0-the-right-mental-model" tabindex="-1">0. The right mental model <a class="header-anchor" href="#_0-the-right-mental-model" aria-label="Permalink to &quot;0. The right mental model&quot;">​</a></h2><ul><li><strong>Strings are immutable</strong>: every “mutating” method returns a new string; the original is never changed.</li><li><strong>Zero-based indexing</strong>: <code>str[0]</code> and <code>str.charAt(0)</code> are the first character; negative indices in some methods mean “from the end” (e.g. <code>slice(-1)</code>).</li><li><strong>Typical use cases</strong>: slice, split, replace, case conversion, and regex-based match/replace.</li></ul><h2 id="_1-properties-and-basics" tabindex="-1">1. Properties and basics <a class="header-anchor" href="#_1-properties-and-basics" aria-label="Permalink to &quot;1. Properties and basics&quot;">​</a></h2><h3 id="_1-1-length-and-indexing" tabindex="-1">1.1 <code>length</code> and indexing <a class="header-anchor" href="#_1-1-length-and-indexing" aria-label="Permalink to &quot;1.1 \`length\` and indexing&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="vp-code"><code class="language-js">const s = &quot;hello&quot;;
s.length;        // 5
s[0];            // &quot;h&quot;
s.charAt(0);     // &quot;h&quot;
s[s.length - 1]; // &quot;o&quot;
</code></pre></div><h3 id="_1-2-iteration" tabindex="-1">1.2 Iteration <a class="header-anchor" href="#_1-2-iteration" aria-label="Permalink to &quot;1.2 Iteration&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="vp-code"><code class="language-js">for (const c of &quot;hi&quot;) console.log(c); // &quot;h&quot;, &quot;i&quot;
[...&quot;hi&quot;];  // [&quot;h&quot;, &quot;i&quot;]
</code></pre></div><h2 id="_2-common-methods-at-a-glance" tabindex="-1">2. Common methods at a glance <a class="header-anchor" href="#_2-common-methods-at-a-glance" aria-label="Permalink to &quot;2. Common methods at a glance&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Method</th><th>Purpose</th><th>Example</th></tr></thead><tbody><tr><td><code>slice(start, end?)</code></td><td>Extract substring; supports negative indices</td><td><code>&quot;abc&quot;.slice(1, -1)</code> → <code>&quot;b&quot;</code></td></tr><tr><td><code>substring(start, end?)</code></td><td>Extract; negative values treated as 0</td><td><code>&quot;abc&quot;.substring(1, 2)</code> → <code>&quot;b&quot;</code></td></tr><tr><td><code>split(sep?, limit?)</code></td><td>Split by separator into array</td><td><code>&quot;a,b,c&quot;.split(&quot;,&quot;)</code> → <code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></td></tr><tr><td><code>trim()</code> / <code>trimStart()</code> / <code>trimEnd()</code></td><td>Remove leading/trailing whitespace</td><td><code>&quot; hi &quot;.trim()</code> → <code>&quot;hi&quot;</code></td></tr><tr><td><code>toUpperCase()</code> / <code>toLowerCase()</code></td><td>Case conversion for whole string</td><td><code>&quot;Hi&quot;.toLowerCase()</code> → <code>&quot;hi&quot;</code></td></tr><tr><td><code>charAt(i)</code></td><td>Character at index i</td><td><code>&quot;hi&quot;.charAt(1)</code> → <code>&quot;i&quot;</code></td></tr><tr><td><code>concat(...strs)</code></td><td>Concatenate (often use <code>+</code> or template literals)</td><td><code>&quot;a&quot;.concat(&quot;b&quot;)</code> → <code>&quot;ab&quot;</code></td></tr><tr><td><code>includes(sub)</code> / <code>startsWith(sub)</code> / <code>endsWith(sub)</code></td><td>Contains / starts with / ends with</td><td><code>&quot;hello&quot;.includes(&quot;ell&quot;)</code> → <code>true</code></td></tr><tr><td><code>indexOf(sub, from?)</code> / <code>lastIndexOf(sub, from?)</code></td><td>First / last index of substring</td><td><code>&quot;abca&quot;.indexOf(&quot;a&quot;, 1)</code> → <code>3</code></td></tr><tr><td><code>repeat(n)</code></td><td>Repeat string n times</td><td><code>&quot;ab&quot;.repeat(2)</code> → <code>&quot;abab&quot;</code></td></tr><tr><td><code>padStart(len, pad)</code> / <code>padEnd(len, pad)</code></td><td>Pad to length</td><td><code>&quot;5&quot;.padStart(3, &quot;0&quot;)</code> → <code>&quot;005&quot;</code></td></tr></tbody></table><h2 id="_3-replace-and-search" tabindex="-1">3. Replace and search <a class="header-anchor" href="#_3-replace-and-search" aria-label="Permalink to &quot;3. Replace and search&quot;">​</a></h2><h3 id="_3-1-replace-searchvalue-replacement" tabindex="-1">3.1 <code>replace(searchValue, replacement)</code> <a class="header-anchor" href="#_3-1-replace-searchvalue-replacement" aria-label="Permalink to &quot;3.1 \`replace(searchValue, replacement)\`&quot;">​</a></h3><ul><li><strong>Replaces only the first match</strong> unless <code>searchValue</code> is a regex with <code>g</code>.</li><li><code>replacement</code> can be a string or a function: <code>(match, ...groups) =&gt; string</code>.</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="vp-code"><code class="language-js">&quot;a1b2&quot;.replace(/\\d/, &quot;x&quot;);     // &quot;axb2&quot;
&quot;a1b2&quot;.replace(/\\d/g, &quot;x&quot;);    // &quot;axbx&quot;
&quot;hello&quot;.replace(&quot;l&quot;, &quot;L&quot;);     // &quot;heLlo&quot;
&quot;hello&quot;.replace(/l/g, &quot;L&quot;);   // &quot;heLLo&quot;
</code></pre></div><h3 id="_3-2-using-a-function-in-replace-for-per-match-replacement" tabindex="-1">3.2 Using a function in <code>replace</code> for per-match replacement <a class="header-anchor" href="#_3-2-using-a-function-in-replace-for-per-match-replacement" aria-label="Permalink to &quot;3.2 Using a function in \`replace\` for per-match replacement&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="vp-code"><code class="language-js">&quot;abc-123&quot;.replace(/([a-z]+)-(\\d+)/, (_, letters, digits) =&gt; digits + &quot;-&quot; + letters);
// &quot;123-abc&quot;
</code></pre></div><h3 id="_3-3-search-regexp-match-regexp-matchall-regexp" tabindex="-1">3.3 <code>search(regexp)</code>, <code>match(regexp)</code>, <code>matchAll(regexp)</code> <a class="header-anchor" href="#_3-3-search-regexp-match-regexp-matchall-regexp" aria-label="Permalink to &quot;3.3 \`search(regexp)\`, \`match(regexp)\`, \`matchAll(regexp)\`&quot;">​</a></h3><ul><li><code>search</code>: index of first match, or <code>-1</code>.</li><li><code>match</code>: without <code>g</code>, first match and groups; with <code>g</code>, array of all matches (no groups).</li><li><code>matchAll</code>: iterator of matches, each with groups.</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="vp-code"><code class="language-js">&quot;hi 123&quot;.search(/\\d/);           // 3
&quot;a1b2&quot;.match(/\\d/g);            // [&quot;1&quot;, &quot;2&quot;]
&quot;a1b2&quot;.match(/(\\d)/g);         // [&quot;1&quot;, &quot;2&quot;]
[...&quot;x1y2&quot;.matchAll(/(\\d)/g)]; // [[&quot;1&quot;,&quot;1&quot;],[&quot;2&quot;,&quot;2&quot;]]
</code></pre></div><h2 id="_4-split-with-regex" tabindex="-1">4. <code>split</code> with regex <a class="header-anchor" href="#_4-split-with-regex" aria-label="Permalink to &quot;4. \`split\` with regex&quot;">​</a></h2><ul><li><code>split</code> can take a regex; <strong>if the regex has capturing groups, the separators appear in the result array</strong>.</li><li>Use this to “split on sentence-ending punctuation but keep the punctuation”.</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="vp-code"><code class="language-js">&quot;a.b.c&quot;.split(/\\./);              // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&quot;a. b. c&quot;.split(/(\\.)\\s*/);       // [&quot;a&quot;, &quot;.&quot;, &quot;b&quot;, &quot;.&quot;, &quot;c&quot;]
&quot;Hi. Bye! Ok?&quot;.split(/([.!?]\\s*)/);
// [&quot;Hi&quot;, &quot;. &quot;, &quot;Bye&quot;, &quot;! &quot;, &quot;Ok&quot;, &quot;? &quot;, &quot;&quot;]
// join with &quot;&quot; to restore punctuation and spaces; pairs of [sentence, separator] follow.
</code></pre></div><p>Common pattern: split by sentence and keep delimiters:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="vp-code"><code class="language-js">&quot;First. Second! Third?&quot;.split(/([.!?]\\s*)/);
// [&quot;First&quot;, &quot;. &quot;, &quot;Second&quot;, &quot;! &quot;, &quot;Third&quot;, &quot;? &quot;, &quot;&quot;]
// odd indices are delimiters; even indices (and trailing &quot;&quot;) are sentence content; map then join(&quot;&quot;)
</code></pre></div><h2 id="_5-practice-sentence-capitalization-name-normalization-formattext" tabindex="-1">5. Practice: sentence-capitalization + name normalization (formatText) <a class="header-anchor" href="#_5-practice-sentence-capitalization-name-normalization-formattext" aria-label="Permalink to &quot;5. Practice: sentence-capitalization + name normalization (formatText)&quot;">​</a></h2><p><strong>Requirements</strong>:</p><ol><li>Capitalize the first letter of each sentence; keep leading spaces (do not trim).</li><li>Given a list of names, match whole words case-insensitively and normalize to “first letter uppercase, rest lowercase”.</li></ol><p><strong>Approach</strong>:</p><ul><li>Use <code>split(/([.!?]\\s*)/)</code> to split on sentence-ending punctuation while keeping delimiters; for each segment, find the first letter and uppercase it.</li><li>Use <code>RegExp(&quot;\\\\b&quot; + name + &quot;\\\\b&quot;, &quot;gi&quot;)</code> for whole-word, case-insensitive match, then <code>replace</code> to the normalized form.</li></ul><p><strong>Implementation</strong>:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="vp-code"><code class="language-js">function formatText(str, names) {
  if (!str) return str;

  // 1. Capitalize first letter of each sentence, keep leading spaces
  let formatted = str
    .split(/([.!?]\\s*)/) // keep delimiters
    .map(sentence =&gt; {
      if (sentence.trim().length === 0) return sentence; // all spaces/empty: return as-is

      let firstLetterIndex = sentence.search(/[a-zA-Z]/);
      if (firstLetterIndex === -1) return sentence; // no letter: return as-is

      return (
        sentence.slice(0, firstLetterIndex) +
        sentence.charAt(firstLetterIndex).toUpperCase() +
        sentence.slice(firstLetterIndex + 1)
      );
    })
    .join(&quot;&quot;);

  // 2. Name replacement (case-insensitive → title case)
  names.forEach(name =&gt; {
    let regex = new RegExp(\`\\\\b\${name}\\\\b\`, &quot;gi&quot;);
    formatted = formatted.replace(regex, () =&gt; {
      return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
    });
  });

  return formatted;
}
</code></pre></div><p><strong>Concepts used</strong>:</p><ul><li><code>split(/([.!?]\\s*)/)</code>: split by sentence and keep <code>.!?</code> and following whitespace.</li><li><code>sentence.search(/[a-zA-Z]/)</code>: index of first letter.</li><li><code>slice</code> + <code>charAt(...).toUpperCase()</code> + <code>slice</code>: capitalize only the first letter, keep leading spaces.</li><li><code>new RegExp(&quot;\\\\b&quot; + name + &quot;\\\\b&quot;, &quot;gi&quot;)</code>: whole-word, case-insensitive; <code>replace(regex, fn)</code> to normalize to title case.</li></ul><p><strong>Test</strong>:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="vp-code"><code class="language-js">const input =
  &quot;  today lucas and joshua go to the grocery store.did they buy any good stuff?  Nobody knows!Only lUcas know it.  Am I right?&quot;;
const names = [&quot;lucas&quot;, &quot;joshua&quot;];

console.log(formatText(input, names));
// &quot;  Today Lucas and Joshua go to the grocery store.Did they buy any good stuff?  Nobody knows!Only Lucas know it.  Am I right?&quot;
</code></pre></div><ul><li>Sentence starts (Today, Did, Nobody, Only, Am) are capitalized; leading spaces kept.</li><li>All occurrences of <code>lucas</code> / <code>lUcas</code> and <code>joshua</code> are normalized to <code>Lucas</code> and <code>Joshua</code>.</li></ul><hr><p><strong>Summary</strong>: String handling = slice, split, replace, toUpperCase/toLowerCase, search/indexOf, plus regex for whole-word / global / keep-delimiter behavior—covers most day-to-day needs.</p>`,40)]))}const q=t(s,[["render",c]]);export{h as __pageData,q as default};
