import{_ as i,c as t,o,ag as a}from"./chunks/framework.Bw-5EFTY.js";const p=JSON.parse('{"title":"Android Notes: Context, memory leaks, async options, Serializable vs Parcelable (English)","description":"","frontmatter":{},"headers":[],"relativePath":"reading-notes/android/android.en.md","filePath":"reading-notes/android/android.en.md"}'),n={name:"reading-notes/android/android.en.md"};function l(r,e,s,c,d,u){return o(),t("div",null,e[0]||(e[0]=[a('<h1 id="android-notes-context-memory-leaks-async-options-serializable-vs-parcelable-english" tabindex="-1">Android Notes: Context, memory leaks, async options, Serializable vs Parcelable (English) <a class="header-anchor" href="#android-notes-context-memory-leaks-async-options-serializable-vs-parcelable-english" aria-label="Permalink to &quot;Android Notes: Context, memory leaks, async options, Serializable vs Parcelable (English)&quot;">​</a></h1><p><a href="/reading-notes/android/android.html">中文</a></p><h2 id="_1-what-context-is-what-it-represents" tabindex="-1">1) What <code>Context</code> is (what it “represents”) <a class="header-anchor" href="#_1-what-context-is-what-it-represents" aria-label="Permalink to &quot;1) What `Context` is (what it “represents”)&quot;">​</a></h2><p>Think of <code>Context</code> as the <strong>entry point to “app environment capabilities”</strong>, including:</p><ul><li><strong>Resources</strong>: <code>getResources()</code>, <code>getString()</code>, <code>getTheme()</code></li><li><strong>System services</strong>: <code>getSystemService(...)</code> (e.g. <code>LayoutInflater</code>, <code>NotificationManager</code>, <code>ClipboardManager</code>)</li><li><strong>Component operations</strong>: <code>startActivity()</code>, <code>startService()</code>, <code>sendBroadcast()</code></li><li><strong>UI “theme scope”</strong>: theme + attribute resolution (e.g. Material theme attributes)</li></ul><p>In short: <strong>Context decides “which environment/scope you’re operating in”</strong>, and it directly affects UI theming and lifecycle reference chains.</p><h2 id="_2-activity-context-vs-application-context" tabindex="-1">2) Activity Context vs Application Context <a class="header-anchor" href="#_2-activity-context-vs-application-context" aria-label="Permalink to &quot;2) Activity Context vs Application Context&quot;">​</a></h2><h3 id="key-differences" tabindex="-1">Key differences <a class="header-anchor" href="#key-differences" aria-label="Permalink to &quot;Key differences&quot;">​</a></h3><ul><li><p><strong>Activity Context</strong> (e.g. <code>this</code>, <code>requireActivity()</code>, <code>view.context</code>)</p><ul><li>tied to the Activity lifecycle</li><li>carries the Activity theme (better for UI)</li><li>easier to leak if captured by a long-lived object</li></ul></li><li><p><strong>Application Context</strong> (<code>applicationContext</code> / <code>getApplicationContext()</code>)</p><ul><li>tied to the process lifetime (effectively “long-lived”)</li><li>typically <strong>does not carry Activity theme overlays</strong></li><li>good for non-UI, long-lived components (singletons, repositories, DB, global registrations)</li></ul></li></ul><h3 id="practical-selection" tabindex="-1">Practical selection <a class="header-anchor" href="#practical-selection" aria-label="Permalink to &quot;Practical selection&quot;">​</a></h3><ul><li><strong>Needs UI theme/window</strong>: prefer Activity Context <ul><li>inflating views, Dialog/PopupWindow, Material widgets, etc.</li></ul></li><li><strong>Cross-screen / long-lived / theme-independent</strong>: use Application Context <ul><li>database, networking, cache, notifications, WorkManager initialization</li></ul></li><li><strong>Toast</strong><ul><li><code>Toast.makeText(appContext, ...)</code> is common; but for custom views/theme-sensitive styles, Activity Context can be more appropriate</li></ul></li></ul><h2 id="_3-what-happens-if-you-use-application-context-to-draw-a-view-in-a-screen" tabindex="-1">3) What happens if you use Application Context to “draw” a View in a screen? <a class="header-anchor" href="#_3-what-happens-if-you-use-application-context-to-draw-a-view-in-a-screen" aria-label="Permalink to &quot;3) What happens if you use Application Context to “draw” a View in a screen?&quot;">​</a></h2><p>Two common cases:</p><h3 id="a-you-only-create-inflate-the-view-and-later-attach-it-to-the-activity-view-tree" tabindex="-1">A. You only create/inflate the View (and later attach it to the Activity view tree) <a class="header-anchor" href="#a-you-only-create-inflate-the-view-and-later-attach-it-to-the-activity-view-tree" aria-label="Permalink to &quot;A. You only create/inflate the View (and later attach it to the Activity view tree)&quot;">​</a></h3><ul><li><strong>Often works</strong>: the View can still render once attached.</li><li>But you may see <strong>wrong styles / missing theme attributes</strong>: <ul><li>Application Context doesn’t have the Activity’s theme overlay (Material3, night mode overlays, dynamic color, etc.)</li><li>some widgets read themed attributes; values may differ → UI looks off</li><li>in edge cases, if a widget requires certain theme attrs, it may throw (depends on implementation)</li></ul></li></ul><h3 id="b-you-use-application-context-for-window-bound-ui" tabindex="-1">B. You use Application Context for “window-bound UI” <a class="header-anchor" href="#b-you-use-application-context-for-window-bound-ui" aria-label="Permalink to &quot;B. You use Application Context for “window-bound UI”&quot;">​</a></h3><p>Examples: Dialog / PopupWindow / anything needing a <code>Window</code> token.</p><ul><li>These typically must attach to an Activity window</li><li>Using Application Context may lead to: <ul><li><strong><code>BadTokenException</code></strong> (no valid window token)</li><li>wrong theme / animation behavior</li></ul></li></ul><p>Bottom line: <strong>Creating a View might be fine, but UI that depends on theme/window should use Activity Context</strong>.</p><h2 id="_4-common-causes-of-memory-leaks" tabindex="-1">4) Common causes of memory leaks <a class="header-anchor" href="#_4-common-causes-of-memory-leaks" aria-label="Permalink to &quot;4) Common causes of memory leaks&quot;">​</a></h2><p>One-liner: <strong>short-lived objects (Activity/Fragment/View) being held by long-lived objects</strong>.</p><p>Typical pitfalls:</p><ul><li><strong>static/singleton holds Activity/Fragment/View</strong></li><li><strong>anonymous / non-static inner classes</strong> implicitly capture the outer Activity <ul><li>Handler/Runnable/callbacks inside an Activity</li></ul></li><li><strong>Handler / delayed Runnables</strong><ul><li>message queue keeps the Runnable after Activity is destroyed</li></ul></li><li><strong>listeners not unregistered</strong><ul><li>sensors, location, BroadcastReceiver, EventBus, LiveData observers, Rx subscriptions, Flow collections</li></ul></li><li><strong>threads/coroutines with wrong scope</strong><ul><li>background work outlives the UI but keeps references (e.g. GlobalScope touching Views)</li></ul></li><li><strong>WebView</strong><ul><li>complex internal refs; follow best-practice destroy + detach patterns</li></ul></li><li><strong>Drawable/Bitmap reference chains</strong><ul><li>image caches / drawable callbacks indirectly retaining Views/Activities</li></ul></li></ul><p>Quick practices:</p><ul><li>use Application Context for non-UI singletons</li><li>unregister listeners in <code>onDestroy/onStop/onDestroyView</code></li><li>use <code>lifecycleScope</code> / <code>viewLifecycleOwner.lifecycleScope</code> for coroutines</li><li>prefer lifecycle-aware patterns over raw Handler; avoid inner-class leaks</li></ul><h2 id="_5-common-async-options-in-android-by-scenario" tabindex="-1">5) Common async options in Android (by scenario) <a class="header-anchor" href="#_5-common-async-options-in-android-by-scenario" aria-label="Permalink to &quot;5) Common async options in Android (by scenario)&quot;">​</a></h2><h3 id="_5-1-run-immediately-app-is-foreground-needs-to-happen-now" tabindex="-1">5.1 Run immediately (app is foreground / needs to happen now) <a class="header-anchor" href="#_5-1-run-immediately-app-is-foreground-needs-to-happen-now" aria-label="Permalink to &quot;5.1 Run immediately (app is foreground / needs to happen now)&quot;">​</a></h3><ul><li><strong>Kotlin Coroutines</strong><ul><li><code>Dispatchers.IO</code> / <code>Dispatchers.Default</code></li><li><code>lifecycleScope</code> / <code>viewModelScope</code></li></ul></li><li><strong>Thread pools</strong><ul><li><code>ExecutorService</code>, <code>Executors.newFixedThreadPool(...)</code></li></ul></li><li><strong>HandlerThread / Looper</strong><ul><li>useful for single-thread serial work (e.g. file writes)</li></ul></li></ul><h3 id="_5-2-deferrable-constrained-reliable-execution-recommended" tabindex="-1">5.2 Deferrable + constrained + reliable execution (recommended) <a class="header-anchor" href="#_5-2-deferrable-constrained-reliable-execution-recommended" aria-label="Permalink to &quot;5.2 Deferrable + constrained + reliable execution (recommended)&quot;">​</a></h3><ul><li><strong>WorkManager</strong> (recommended) <ul><li>constraints: network, battery, charging, idle, etc.</li><li>persisted tasks, retries, chaining</li></ul></li><li><strong>JobScheduler</strong><ul><li>lower-level system job scheduling</li></ul></li></ul><h3 id="_5-3-legacy-know-it-avoid-it" tabindex="-1">5.3 Legacy (know it, avoid it) <a class="header-anchor" href="#_5-3-legacy-know-it-avoid-it" aria-label="Permalink to &quot;5.3 Legacy (know it, avoid it)&quot;">​</a></h3><ul><li><strong>AsyncTask</strong> (deprecated)</li><li><strong>IntentService</strong> (deprecated; prefer WorkManager / ForegroundService depending on needs)</li></ul><p>Selection:</p><ul><li><strong>foreground immediate</strong>: coroutines / thread pool</li><li><strong>must run in background + constraints/retry</strong>: WorkManager</li><li><strong>long-running ongoing work</strong> (music, continuous location): Foreground Service (subject to platform restrictions)</li></ul><h2 id="_6-serializable-vs-parcelable" tabindex="-1">6) Serializable vs Parcelable <a class="header-anchor" href="#_6-serializable-vs-parcelable" aria-label="Permalink to &quot;6) Serializable vs Parcelable&quot;">​</a></h2><h3 id="serializable" tabindex="-1">Serializable <a class="header-anchor" href="#serializable" aria-label="Permalink to &quot;Serializable&quot;">​</a></h3><ul><li>Java standard serialization (reflection-heavy)</li><li><strong>easy to implement</strong>: <code>class Foo : Serializable</code></li><li><strong>slower</strong> on Android for frequent Bundle/IPC usage</li></ul><h3 id="parcelable" tabindex="-1">Parcelable <a class="header-anchor" href="#parcelable" aria-label="Permalink to &quot;Parcelable&quot;">​</a></h3><ul><li>Android-optimized for IPC/Bundle</li><li><strong>typically faster</strong></li><li>historically more verbose, but Kotlin <strong><code>@Parcelize</code></strong> makes it much easier</li></ul><h3 id="when-to-use-which-practical" tabindex="-1">When to use which (practical) <a class="header-anchor" href="#when-to-use-which-practical" aria-label="Permalink to &quot;When to use which (practical)&quot;">​</a></h3><ul><li><strong>Intent/Bundle arguments (hot path)</strong>: prefer <strong>Parcelable</strong><ul><li>Activity/Fragment args (<code>Intent</code> extras / <code>Bundle</code>)</li><li><code>savedInstanceState</code> (process death restore)</li><li>Activity results</li></ul></li><li><strong>Cross-process (AIDL/Binder)</strong>: typically <strong>Parcelable</strong><ul><li>Binder transactions have size limits; keep payloads small</li></ul></li><li><strong>Quick-and-dirty / low frequency</strong>: <code>Serializable</code> can be acceptable <ul><li>demos, experiments, tooling</li><li>avoid long-term use in performance-sensitive flows</li></ul></li><li><strong>Persistence / network</strong>: usually neither <ul><li>prefer Room/SQLite, JSON (Moshi/Gson/Kotlinx Serialization), protobuf, etc.</li></ul></li></ul><p>Avoid:</p><ul><li>putting huge graphs/lists/images into <code>Intent</code>/<code>Bundle</code> (Serializable or Parcelable)</li><li>treating View/Context/Bitmap/Drawable as transferable data</li></ul>',43)]))}const g=i(n,[["render",l]]);export{p as __pageData,g as default};
