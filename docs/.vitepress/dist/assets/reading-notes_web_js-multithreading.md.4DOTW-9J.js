import{_ as o,c as l,o as r,ag as a}from"./chunks/framework.Bw-5EFTY.js";const g=JSON.parse('{"title":"JS 多任务与多线程：浏览器 vs Node.js","description":"","frontmatter":{},"headers":[],"relativePath":"reading-notes/web/js-multithreading.md","filePath":"reading-notes/web/js-multithreading.md"}'),i={name:"reading-notes/web/js-multithreading.md"};function t(s,e,d,n,c,u){return r(),l("div",null,e[0]||(e[0]=[a('<h1 id="js-多任务与多线程-浏览器-vs-node-js" tabindex="-1">JS 多任务与多线程：浏览器 vs Node.js <a class="header-anchor" href="#js-多任务与多线程-浏览器-vs-node-js" aria-label="Permalink to &quot;JS 多任务与多线程：浏览器 vs Node.js&quot;">​</a></h1><p><a href="/reading-notes/web/js-multithreading.en.html">English</a></p><p>这篇讲“JS 怎么做多任务处理”和“什么情况下才算多线程”。先分清：<strong>异步 ≠ 多线程</strong>。</p><h2 id="先明确概念-异步、并发、并行" tabindex="-1">先明确概念：异步、并发、并行 <a class="header-anchor" href="#先明确概念-异步、并发、并行" aria-label="Permalink to &quot;先明确概念：异步、并发、并行&quot;">​</a></h2><ul><li><strong>异步（async）</strong>：发起操作后不阻塞当前执行，结果未来某个时刻回来</li><li><strong>并发（concurrency）</strong>：同一时间段推进多个任务（不等于同一时刻真的同时跑）</li><li><strong>并行（parallelism）</strong>：同一时刻在多个 CPU 核上同时执行（通常需要多线程/多进程）</li></ul><h2 id="浏览器-单线程主线程-事件循环" tabindex="-1">浏览器：单线程主线程 + 事件循环 <a class="header-anchor" href="#浏览器-单线程主线程-事件循环" aria-label="Permalink to &quot;浏览器：单线程主线程 + 事件循环&quot;">​</a></h2><h3 id="事件循环与任务队列" tabindex="-1">事件循环与任务队列 <a class="header-anchor" href="#事件循环与任务队列" aria-label="Permalink to &quot;事件循环与任务队列&quot;">​</a></h3><ul><li>JS 主线程执行同步代码</li><li><strong>宏任务（task）</strong>：<code>setTimeout</code>、<code>setInterval</code>、<code>postMessage</code>、<code>MessageChannel</code> 等</li><li><strong>微任务（microtask）</strong>：<code>Promise.then</code>、<code>queueMicrotask</code>、<code>MutationObserver</code></li><li>常见执行顺序：执行一个宏任务 → 清空微任务队列 → 渲染（可能）→ 下一个宏任务</li></ul><h3 id="浏览器中的-多任务处理-手段" tabindex="-1">浏览器中的“多任务处理”手段 <a class="header-anchor" href="#浏览器中的-多任务处理-手段" aria-label="Permalink to &quot;浏览器中的“多任务处理”手段&quot;">​</a></h3><ul><li><strong>I/O 并发</strong>：<code>fetch</code>、IndexedDB、WebSocket（底层由浏览器线程/进程实现，JS 侧是异步回调/Promise）</li><li><strong>切片避免卡顿</strong>： <ul><li><code>requestAnimationFrame</code>：每帧前执行（适合动画/视觉更新前准备）</li><li><code>requestIdleCallback</code>：浏览器空闲时执行（适合低优先级任务）</li><li><code>setTimeout(fn, 0)</code>：让出主线程（精度不保证）</li></ul></li><li><strong>真正多线程</strong>：<code>Web Worker</code> / <code>Shared Worker</code>（另起线程跑 JS，不阻塞主线程）</li></ul><h2 id="node-js-事件循环-libuv-线程池" tabindex="-1">Node.js：事件循环 + libuv + 线程池 <a class="header-anchor" href="#node-js-事件循环-libuv-线程池" aria-label="Permalink to &quot;Node.js：事件循环 + libuv + 线程池&quot;">​</a></h2><h3 id="node-的-异步-来自哪里" tabindex="-1">Node 的“异步”来自哪里 <a class="header-anchor" href="#node-的-异步-来自哪里" aria-label="Permalink to &quot;Node 的“异步”来自哪里&quot;">​</a></h3><ul><li>Node 仍然是单线程执行 JS（主线程）</li><li>I/O 由 <strong>libuv</strong> 协调： <ul><li>一部分 I/O 走 OS 异步能力</li><li>一部分（例如某些文件系统/加密/压缩等）走 <strong>线程池</strong>，完成后回调到事件循环</li></ul></li></ul><h3 id="node-的-多线程-多进程-选择" tabindex="-1">Node 的“多线程/多进程”选择 <a class="header-anchor" href="#node-的-多线程-多进程-选择" aria-label="Permalink to &quot;Node 的“多线程/多进程”选择&quot;">​</a></h3><ul><li><strong>多进程</strong>：<code>child_process</code>、<code>cluster</code><ul><li>隔离更强、稳定性好；进程间通信成本更高</li></ul></li><li><strong>多线程</strong>：<code>worker_threads</code><ul><li>适合 CPU 密集型（压缩、图像处理、大量计算）</li><li>可配合 <code>SharedArrayBuffer</code> + <code>Atomics</code> 做更底层的共享内存同步</li></ul></li></ul><h2 id="浏览器-vs-node-差异总结" tabindex="-1">浏览器 vs Node：差异总结 <a class="header-anchor" href="#浏览器-vs-node-差异总结" aria-label="Permalink to &quot;浏览器 vs Node：差异总结&quot;">​</a></h2><ul><li><strong>目标不同</strong><ul><li>浏览器：UI 响应、渲染与安全隔离优先</li><li>Node：吞吐、I/O 并发与服务稳定优先</li></ul></li><li><strong>多线程方式不同</strong><ul><li>浏览器：Worker 家族（Web/Shared/Service）</li><li>Node：<code>worker_threads</code> / 多进程</li></ul></li><li><strong>Worker 能做的事不同</strong><ul><li>浏览器 Worker 受同源/能力限制（无 DOM）</li><li>Node worker 可访问 Node API（取决于设计），更适合后端计算任务</li></ul></li></ul><h2 id="何时需要-多线程" tabindex="-1">何时需要“多线程” <a class="header-anchor" href="#何时需要-多线程" aria-label="Permalink to &quot;何时需要“多线程”&quot;">​</a></h2><ul><li><strong>适合多线程/Worker</strong>：CPU 密集、长时间计算、需要不阻塞 UI/主线程</li><li><strong>不需要多线程</strong>：主要是 I/O（网络请求、数据库、文件读写）——用异步并发即可</li></ul><p>下一篇会专门把 Web Worker / Shared Worker / Service Worker 逐一讲透。</p>',20)]))}const b=o(i,[["render",t]]);export{g as __pageData,b as default};
