import{_ as r,c as o,o as a,ag as s}from"./chunks/framework.Bw-5EFTY.js";const m=JSON.parse('{"title":"JS Concurrency and Multithreading: Browser vs Node.js (English)","description":"","frontmatter":{},"headers":[],"relativePath":"reading-notes/web/js-multithreading.en.md","filePath":"reading-notes/web/js-multithreading.en.md"}'),t={name:"reading-notes/web/js-multithreading.en.md"};function n(i,e,l,d,c,u){return a(),o("div",null,e[0]||(e[0]=[s('<h1 id="js-concurrency-and-multithreading-browser-vs-node-js-english" tabindex="-1">JS Concurrency and Multithreading: Browser vs Node.js (English) <a class="header-anchor" href="#js-concurrency-and-multithreading-browser-vs-node-js-english" aria-label="Permalink to &quot;JS Concurrency and Multithreading: Browser vs Node.js (English)&quot;">​</a></h1><p><a href="/reading-notes/web/js-multithreading.html">中文</a></p><p>This note clarifies what “multitasking” means in JavaScript, and when you actually need multiple threads. Key point: <strong>async ≠ multithreading</strong>.</p><h2 id="terms-async-concurrency-parallelism" tabindex="-1">Terms: async, concurrency, parallelism <a class="header-anchor" href="#terms-async-concurrency-parallelism" aria-label="Permalink to &quot;Terms: async, concurrency, parallelism&quot;">​</a></h2><ul><li><strong>Async</strong>: start work without blocking; get the result later.</li><li><strong>Concurrency</strong>: making progress on multiple tasks in the same time window.</li><li><strong>Parallelism</strong>: tasks truly run at the same time on different CPU cores (threads/processes).</li></ul><h2 id="browser-single-main-thread-event-loop" tabindex="-1">Browser: single main thread + event loop <a class="header-anchor" href="#browser-single-main-thread-event-loop" aria-label="Permalink to &quot;Browser: single main thread + event loop&quot;">​</a></h2><h3 id="tasks-and-microtasks" tabindex="-1">Tasks and microtasks <a class="header-anchor" href="#tasks-and-microtasks" aria-label="Permalink to &quot;Tasks and microtasks&quot;">​</a></h3><ul><li>JS runs on the main thread.</li><li><strong>Tasks (macrotasks)</strong>: <code>setTimeout</code>, <code>setInterval</code>, <code>postMessage</code>, <code>MessageChannel</code>, etc.</li><li><strong>Microtasks</strong>: <code>Promise.then</code>, <code>queueMicrotask</code>, <code>MutationObserver</code>.</li><li>Typical order: one task → drain microtasks → (maybe render) → next task.</li></ul><h3 id="multitasking-techniques-in-the-browser" tabindex="-1">“Multitasking” techniques in the browser <a class="header-anchor" href="#multitasking-techniques-in-the-browser" aria-label="Permalink to &quot;“Multitasking” techniques in the browser&quot;">​</a></h3><ul><li><strong>I/O concurrency</strong>: <code>fetch</code>, IndexedDB, WebSocket (handled by browser internals; JS side is Promise/callbacks).</li><li><strong>Time slicing to keep UI responsive</strong>: <ul><li><code>requestAnimationFrame</code> for frame-aligned work</li><li><code>requestIdleCallback</code> for low-priority work</li><li><code>setTimeout(fn, 0)</code> to yield (timing not guaranteed)</li></ul></li><li><strong>Real multithreading</strong>: <code>Web Worker</code> / <code>Shared Worker</code> (separate JS execution context; no DOM access)</li></ul><h2 id="node-js-event-loop-libuv-thread-pool" tabindex="-1">Node.js: event loop + libuv + thread pool <a class="header-anchor" href="#node-js-event-loop-libuv-thread-pool" aria-label="Permalink to &quot;Node.js: event loop + libuv + thread pool&quot;">​</a></h2><h3 id="where-node-s-async-comes-from" tabindex="-1">Where Node’s “async” comes from <a class="header-anchor" href="#where-node-s-async-comes-from" aria-label="Permalink to &quot;Where Node’s “async” comes from&quot;">​</a></h3><ul><li>JS still runs on a single thread (the main thread).</li><li>I/O is coordinated by <strong>libuv</strong>: <ul><li>some operations use OS async capabilities</li><li>some run on a <strong>thread pool</strong> (then callback into the event loop)</li></ul></li></ul><h3 id="multithreading-vs-multiprocessing-in-node" tabindex="-1">Multithreading vs multiprocessing in Node <a class="header-anchor" href="#multithreading-vs-multiprocessing-in-node" aria-label="Permalink to &quot;Multithreading vs multiprocessing in Node&quot;">​</a></h3><ul><li><strong>Multiprocessing</strong>: <code>child_process</code>, <code>cluster</code><ul><li>stronger isolation; IPC overhead</li></ul></li><li><strong>Multithreading</strong>: <code>worker_threads</code><ul><li>best for CPU-heavy work</li><li>can use <code>SharedArrayBuffer</code> + <code>Atomics</code> for shared-memory patterns</li></ul></li></ul><h2 id="browser-vs-node-summary" tabindex="-1">Browser vs Node (summary) <a class="header-anchor" href="#browser-vs-node-summary" aria-label="Permalink to &quot;Browser vs Node (summary)&quot;">​</a></h2><ul><li><strong>Goals</strong><ul><li>Browser: UI responsiveness, rendering, security isolation</li><li>Node: throughput, I/O concurrency, stability</li></ul></li><li><strong>How to get “threads”</strong><ul><li>Browser: Worker family (Web/Shared/Service)</li><li>Node: <code>worker_threads</code> / processes</li></ul></li><li><strong>What workers can do</strong><ul><li>Browser workers: no DOM; strict capabilities</li><li>Node workers: can leverage Node APIs depending on design</li></ul></li></ul><h2 id="when-do-you-actually-need-multithreading" tabindex="-1">When do you actually need multithreading? <a class="header-anchor" href="#when-do-you-actually-need-multithreading" aria-label="Permalink to &quot;When do you actually need multithreading?&quot;">​</a></h2><ul><li>Use Workers/threads for <strong>CPU-bound</strong> / long-running computations.</li><li>For mostly I/O work, async concurrency is usually enough.</li></ul>',19)]))}const g=r(t,[["render",n]]);export{m as __pageData,g as default};
