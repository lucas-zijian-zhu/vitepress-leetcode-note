import{_ as i,c as l,o as t,ag as o}from"./chunks/framework.Bw-5EFTY.js";const p=JSON.parse('{"title":"Android 笔记：Context、内存泄露、异步方式、Serializable vs Parcelable","description":"","frontmatter":{},"headers":[],"relativePath":"reading-notes/android/android.md","filePath":"reading-notes/android/android.md"}'),a={name:"reading-notes/android/android.md"};function r(n,e,c,d,s,u){return t(),l("div",null,e[0]||(e[0]=[o('<h1 id="android-笔记-context、内存泄露、异步方式、serializable-vs-parcelable" tabindex="-1">Android 笔记：Context、内存泄露、异步方式、Serializable vs Parcelable <a class="header-anchor" href="#android-笔记-context、内存泄露、异步方式、serializable-vs-parcelable" aria-label="Permalink to &quot;Android 笔记：Context、内存泄露、异步方式、Serializable vs Parcelable&quot;">​</a></h1><p><a href="/reading-notes/android/android.en.html">English</a></p><h2 id="_1-context-的作用-它到底-代表-什么" tabindex="-1">1）Context 的作用（它到底“代表”什么） <a class="header-anchor" href="#_1-context-的作用-它到底-代表-什么" aria-label="Permalink to &quot;1）Context 的作用（它到底“代表”什么）&quot;">​</a></h2><p>可以把 <code>Context</code> 理解为“<strong>访问应用环境能力的入口</strong>”，它提供：</p><ul><li><strong>资源访问</strong>：<code>getResources()</code>、<code>getString()</code>、<code>getTheme()</code></li><li><strong>系统服务</strong>：<code>getSystemService(...)</code>（如 <code>LayoutInflater</code>、<code>NotificationManager</code>、<code>ClipboardManager</code>）</li><li><strong>组件能力</strong>：<code>startActivity()</code>、<code>startService()</code>、<code>sendBroadcast()</code></li><li><strong>创建 UI 的语境</strong>：主题（Theme）、样式属性解析（例如 Material 组件的 attribute）</li></ul><p>一句话：<strong>Context 决定了你在“哪个环境/语境”里做事</strong>，尤其影响 UI 的主题与生命周期引用关系。</p><h2 id="_2-activity-context-vs-application-context-区别与选择" tabindex="-1">2）Activity Context vs Application Context：区别与选择 <a class="header-anchor" href="#_2-activity-context-vs-application-context-区别与选择" aria-label="Permalink to &quot;2）Activity Context vs Application Context：区别与选择&quot;">​</a></h2><h3 id="核心区别" tabindex="-1">核心区别 <a class="header-anchor" href="#核心区别" aria-label="Permalink to &quot;核心区别&quot;">​</a></h3><ul><li><p><strong>Activity Context</strong>（例如 <code>this</code> / <code>requireActivity()</code> / <code>view.context</code>）</p><ul><li>跟随 Activity 生命周期</li><li>带 Activity 的主题（Theme），更适合 UI</li><li>更容易因为“被长生命周期对象持有”而泄露 Activity</li></ul></li><li><p><strong>Application Context</strong>（<code>applicationContext</code> / <code>getApplicationContext()</code>）</p><ul><li>生命周期与进程一致（几乎等同“常驻”）</li><li><strong>不带 Activity 的主题语境</strong>（通常是 Application/默认主题）</li><li>适合“与界面无关、需要长期存在”的逻辑（如单例、Repository、数据库、全局广播注册等）</li></ul></li></ul><h3 id="常用选择建议-实战" tabindex="-1">常用选择建议（实战） <a class="header-anchor" href="#常用选择建议-实战" aria-label="Permalink to &quot;常用选择建议（实战）&quot;">​</a></h3><ul><li><strong>需要 UI 样式/主题/窗口能力</strong>：优先 Activity Context <ul><li>inflate View、创建 Dialog、PopupWindow、Material 组件等</li></ul></li><li><strong>需要跨页面、长期存在、不依赖主题</strong>：用 Application Context <ul><li>数据库、网络层、缓存、全局通知、WorkManager 初始化等</li></ul></li><li><strong>Toast</strong>： <ul><li>传统 <code>Toast.makeText(appContext, ...)</code> 常见；但如果你的 Toast/自定义 View 依赖主题样式，仍可能更适合用 Activity Context</li></ul></li></ul><h2 id="_3-如果在一个页面用-application-context-画-了一个-view-会怎么样" tabindex="-1">3）如果在一个页面用 Application Context “画”了一个 View 会怎么样？ <a class="header-anchor" href="#_3-如果在一个页面用-application-context-画-了一个-view-会怎么样" aria-label="Permalink to &quot;3）如果在一个页面用 Application Context “画”了一个 View 会怎么样？&quot;">​</a></h2><p>这里分两种常见情况：</p><h3 id="a-仅仅-创建-inflate-view-但最终加到-activity-的-view-树里" tabindex="-1">A. 仅仅“创建/Inflate” View（但最终加到 Activity 的 View 树里） <a class="header-anchor" href="#a-仅仅-创建-inflate-view-但最终加到-activity-的-view-树里" aria-label="Permalink to &quot;A. 仅仅“创建/Inflate” View（但最终加到 Activity 的 View 树里）&quot;">​</a></h3><ul><li><strong>通常不会直接崩</strong>：View 依然可以被加入 Activity 的布局中并正常渲染。</li><li>但可能出现 <strong>样式不对/主题不生效</strong>： <ul><li>Application Context 没有 Activity 的 theme overlay（比如 Material3、夜间模式、动态颜色等）</li><li>一些控件在读取 themed attributes 时，可能拿不到期望值 → 样式异常</li><li>极端情况下，如果控件强依赖某些 theme attributes，可能会抛异常（取决于控件实现）</li></ul></li></ul><h3 id="b-用-application-context-去做-需要-window-的-ui-更容易出问题" tabindex="-1">B. 用 Application Context 去做“需要 Window 的 UI”（更容易出问题） <a class="header-anchor" href="#b-用-application-context-去做-需要-window-的-ui-更容易出问题" aria-label="Permalink to &quot;B. 用 Application Context 去做“需要 Window 的 UI”（更容易出问题）&quot;">​</a></h3><p>典型如：Dialog/PopupWindow/需要 <code>Window</code> token 的场景。</p><ul><li>这类 UI 通常需要与某个 Activity 的窗口绑定</li><li>使用 Application Context 容易遇到： <ul><li><strong><code>BadTokenException</code></strong>（没有有效 window token）</li><li>主题不对、动画不对</li></ul></li></ul><p>结论：<strong>创建 View 本身不一定出问题，但 UI 相关（主题/窗口）强依赖 Activity Context</strong>。<br> 所以“在页面里画 UI”，默认优先用 Activity Context；除非你非常确定不需要主题语境。</p><h2 id="_4-常见导致内存泄露-memory-leak-的原因" tabindex="-1">4）常见导致内存泄露（Memory Leak）的原因 <a class="header-anchor" href="#_4-常见导致内存泄露-memory-leak-的原因" aria-label="Permalink to &quot;4）常见导致内存泄露（Memory Leak）的原因&quot;">​</a></h2><p>一句话：<strong>短生命周期对象（Activity/Fragment/View）被长生命周期对象持有</strong>。</p><p>常见坑位：</p><ul><li><strong>静态变量/单例持有 Activity/Fragment/View</strong><ul><li>例如 <code>object Foo { var ctx: Context? }</code> 把 Activity context 塞进去</li></ul></li><li><strong>匿名内部类/非静态内部类持有外部类引用</strong><ul><li>例如 Activity 里的 <code>Handler</code>、<code>Runnable</code>、回调对象，默认持有 Activity 引用</li></ul></li><li><strong>Handler / Runnable 延迟任务</strong><ul><li><code>postDelayed</code> 还没执行完，Activity 已经销毁，但消息队列还持有 Runnable → 泄露</li></ul></li><li><strong>监听器未解绑</strong><ul><li>传感器、位置、BroadcastReceiver、EventBus、LiveData observer、Rx subscription、Flow collect 等</li></ul></li><li><strong>线程/协程作用域不当</strong><ul><li>开了线程一直跑、协程跑在不该跑的 scope，导致引用链保留</li><li>例如在 Activity 里启动全局 scope 的协程去引用 View</li></ul></li><li><strong>WebView</strong><ul><li>WebView 相关的 Context/内部引用复杂，容易泄露；要按规范销毁并移除父容器引用</li></ul></li><li><strong>Drawable/Bitmap 引用链</strong><ul><li>大图缓存、ImageView 的 drawable callback 等导致 View/Activity 被间接引用</li></ul></li></ul><p>实践建议（简版）：</p><ul><li>能用 Application Context 的“非 UI 全局对象”就别用 Activity Context</li><li>所有 listener/observer/subscription 在 <code>onDestroy/onStop/onDestroyView</code> 及时解绑</li><li>用 <code>lifecycleScope</code> / <code>viewLifecycleOwner.lifecycleScope</code> 管理协程</li><li>Handler 用静态内部类 + 弱引用，或尽量用 lifecycle-aware 的方式</li></ul><h2 id="_5-android-常见异步实现方式-按场景归类" tabindex="-1">5）Android 常见异步实现方式（按场景归类） <a class="header-anchor" href="#_5-android-常见异步实现方式-按场景归类" aria-label="Permalink to &quot;5）Android 常见异步实现方式（按场景归类）&quot;">​</a></h2><h3 id="_5-1-立即后台执行-应用在前台-需要立刻做" tabindex="-1">5.1 立即后台执行（应用在前台/需要立刻做） <a class="header-anchor" href="#_5-1-立即后台执行-应用在前台-需要立刻做" aria-label="Permalink to &quot;5.1 立即后台执行（应用在前台/需要立刻做）&quot;">​</a></h3><ul><li><strong>Kotlin Coroutines</strong><ul><li><code>Dispatchers.IO</code> / <code>Dispatchers.Default</code></li><li><code>lifecycleScope</code> / <code>viewModelScope</code></li></ul></li><li><strong>Java/Kotlin 线程池</strong><ul><li><code>ExecutorService</code>、<code>Executors.newFixedThreadPool(...)</code></li></ul></li><li><strong>HandlerThread / Looper</strong><ul><li>有“单线程串行执行”需求时好用（比如串行写文件）</li></ul></li></ul><h3 id="_5-2-可延迟、可约束、要保证执行-更推荐" tabindex="-1">5.2 可延迟、可约束、要保证执行（更推荐） <a class="header-anchor" href="#_5-2-可延迟、可约束、要保证执行-更推荐" aria-label="Permalink to &quot;5.2 可延迟、可约束、要保证执行（更推荐）&quot;">​</a></h3><ul><li><strong>WorkManager</strong>（推荐） <ul><li>支持约束：网络、电量、充电、空闲等</li><li>支持持久化任务、重试、链式任务</li></ul></li><li><strong>JobScheduler</strong><ul><li>系统级作业调度（更底层）</li></ul></li></ul><h3 id="_5-3-旧方案-了解即可" tabindex="-1">5.3 旧方案（了解即可） <a class="header-anchor" href="#_5-3-旧方案-了解即可" aria-label="Permalink to &quot;5.3 旧方案（了解即可）&quot;">​</a></h3><ul><li><strong>AsyncTask</strong>（已废弃）</li><li><strong>IntentService</strong>（已废弃，更多用 WorkManager / ForegroundService）</li></ul><p>选择建议：</p><ul><li><strong>前台立即执行</strong>：协程/线程池</li><li><strong>后台必须执行、支持约束/重试</strong>：WorkManager</li><li><strong>长时间持续任务（如音乐播放/定位）</strong>：Foreground Service（需合规与系统限制）</li></ul><h2 id="_6-serializable-vs-parcelable-你这里的-personalized-我理解为-parcelable" tabindex="-1">6）Serializable vs Parcelable（你这里的 “personalized” 我理解为 Parcelable） <a class="header-anchor" href="#_6-serializable-vs-parcelable-你这里的-personalized-我理解为-parcelable" aria-label="Permalink to &quot;6）Serializable vs Parcelable（你这里的 “personalized” 我理解为 Parcelable）&quot;">​</a></h2><h3 id="serializable" tabindex="-1">Serializable <a class="header-anchor" href="#serializable" aria-label="Permalink to &quot;Serializable&quot;">​</a></h3><ul><li>Java 标准序列化（反射为主）</li><li><strong>实现简单</strong>：<code>class Foo : Serializable</code></li><li><strong>性能相对差</strong>：Android 进程间/Bundle 频繁传输时开销更大</li></ul><h3 id="parcelable" tabindex="-1">Parcelable <a class="header-anchor" href="#parcelable" aria-label="Permalink to &quot;Parcelable&quot;">​</a></h3><ul><li>Android 体系为 IPC/Bundle 优化的序列化方式</li><li><strong>性能更好</strong>（通常）</li><li><strong>实现更繁琐</strong>（但 Kotlin <code>@Parcelize</code> 已大幅简化）</li></ul><h3 id="什么时候用哪个" tabindex="-1">什么时候用哪个 <a class="header-anchor" href="#什么时候用哪个" aria-label="Permalink to &quot;什么时候用哪个&quot;">​</a></h3><ul><li><strong>Intent/Bundle/组件间传参（高频路径）</strong>：优先 <strong>Parcelable</strong><ul><li>Activity/Fragment 参数（<code>Intent</code> extras / <code>Bundle</code>）</li><li><code>savedInstanceState</code>（进程被杀后恢复时需要序列化）</li><li><code>Result</code>/<code>ActivityResult</code> 数据</li><li>配合 Kotlin <code>@Parcelize</code>，实现成本已经很低</li></ul></li><li><strong>跨进程（AIDL / Binder）传输</strong>：通常也更偏向 <strong>Parcelable</strong><ul><li>Binder 事务有大小限制；尽量传“小而必要”的数据，避免大对象/大列表</li></ul></li><li><strong>临时图省事 / 调试 / 低频</strong>：<code>Serializable</code> 可以用 <ul><li>例如 demo、小工具、一次性实验代码</li><li>但不建议在主链路/高频传参中长期依赖它</li></ul></li><li><strong>本地持久化 / 网络传输</strong>：通常不用这俩 <ul><li>用 Room/SQLite、JSON（Moshi/Gson/Kotlinx Serialization）、protobuf 等更合适</li></ul></li></ul><p>不建议：</p><ul><li>把超大对象（大列表/大图片/大树）塞进 <code>Intent</code>/<code>Bundle</code>（无论 Serializable 还是 Parcelable）</li><li>把 View/Context/Bitmap/Drawable 等“带资源引用”的对象当作可传输数据</li></ul>',43)]))}const h=i(a,[["render",r]]);export{p as __pageData,h as default};
