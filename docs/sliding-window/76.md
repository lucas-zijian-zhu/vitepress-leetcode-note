# [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-interview-150)

Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return the **minimum window**  <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1b:" data-state="closed" class="">**substring** </button> of <code>s</code> such that every character in <code>t</code> (**including duplicates** ) is included in the window. If there is no such substring, return the empty string <code>""</code>.

The testcases will be generated such that the answer is **unique** .

**Example 1:** 

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:** 

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:** 

```
Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
```

**Constraints:** 

- <code>m == s.length</code>
- <code>n == t.length</code>
- <code>1 <= m, n <= 10^5</code>
- <code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.

**Follow up:**  Could you find an algorithm that runs in <code>O(m + n)</code> time?

## ✅ Approach: Sliding Window + Two HashMaps

We use a sliding window with two pointers `left` and `right` to expand and contract the window:

1. Use a `Map` (`need`) to count the frequency of each character in `t`.
2. Traverse `s` with `right` pointer, adding characters into the `window` map.
3. Once all required characters are covered with correct frequencies, try to **shrink the window** from the left to minimize its size.
4. Keep track of the minimum window seen so far using `(start, length)`.

This is an advanced variation of sliding window where **character frequencies matter**.

## Kotlin Code

```kotlin
class Solution {
    fun minWindow(s: String, t: String): String {
        if (t.length > s.length) return ""

        val need = mutableMapOf<Char, Int>()
        val window = mutableMapOf<Char, Int>()

        // Build need map
        for (c in t) {
            need[c] = need.getOrDefault(c, 0) + 1
        }

        var left = 0
        var right = 0
        var valid = 0
        var start = 0
        var minLen = Int.MAX_VALUE

        while (right < s.length) {
            val c = s[right]
            right++

            if (c in need) {
                window[c] = window.getOrDefault(c, 0) + 1
                if (window[c] == need[c]) {
                    valid++
                }
            }

            // Try to shrink window
            while (valid == need.size) {
                if (right - left < minLen) {
                    start = left
                    minLen = right - left
                }

                val d = s[left]
                left++

                if (d in need) {
                    if (window[d] == need[d]) {
                        valid--
                    }
                    window[d] = window[d]!! - 1
                }
            }
        }

        return if (minLen == Int.MAX_VALUE) "" else s.substring(start, start + minLen)
    }
}
```

## Complexity Analysis

- **Time Complexity:** O(n + m)  
  - `n` is the length of string `s`, and `m` is the length of string `t`.  
  - Each character in `s` is visited at most twice — once when expanding the window and once when contracting it.  
  - Building the frequency map for `t` takes O(m).

- **Space Complexity:** O(m)  
  - We use two hash maps: one to store the character counts in `t` (`need`) and another to track the counts in the current window (`window`).  
  - The space complexity depends on the number of unique characters in `t`, which is at most O(m).