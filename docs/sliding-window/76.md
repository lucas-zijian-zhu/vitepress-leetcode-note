# [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-interview-150)

Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return the **minimum window**  <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1b:" data-state="closed" class="">**substring** </button> of <code>s</code> such that every character in <code>t</code> (**including duplicates** ) is included in the window. If there is no such substring, return the empty string <code>""</code>.

The testcases will be generated such that the answer is **unique** .

**Example 1:** 

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:** 

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:** 

```
Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
```

**Constraints:** 

- <code>m == s.length</code>
- <code>n == t.length</code>
- <code>1 <= m, n <= 10^5</code>
- <code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.

**Follow up:**  Could you find an algorithm that runs in <code>O(m + n)</code> time?

## ✅ Approach: Sliding Window + Two HashMaps

We use a sliding window with two pointers `left` and `right` to expand and contract the window:

1. Use a `Map` (`need`) to count the frequency of each character in `t`.
2. Traverse `s` with `right` pointer, adding characters into the `window` map.
3. Once all required characters are covered with correct frequencies, try to **shrink the window** from the left to minimize its size.
4. Keep track of the minimum window seen so far using `(start, length)`.

This is an advanced variation of sliding window where **character frequencies matter**.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun minWindow(s: String, t: String): String {
        if (t.length > s.length) return ""

        val need = mutableMapOf<Char, Int>()
        val window = mutableMapOf<Char, Int>()

        // Build need map
        for (c in t) {
            need[c] = need.getOrDefault(c, 0) + 1
        }

        var left = 0
        var right = 0
        var valid = 0
        var start = 0
        var minLen = Int.MAX_VALUE

        while (right < s.length) {
            val c = s[right]
            right++

            if (c in need) {
                window[c] = window.getOrDefault(c, 0) + 1
                if (window[c] == need[c]) {
                    valid++
                }
            }

            // Try to shrink window
            while (valid == need.size) {
                if (right - left < minLen) {
                    start = left
                    minLen = right - left
                }

                val d = s[left]
                left++

                if (d in need) {
                    if (window[d] == need[d]) {
                        valid--
                    }
                    window[d] = window[d]!! - 1
                }
            }
        }

        return if (minLen == Int.MAX_VALUE) "" else s.substring(start, start + minLen)
    }
}
```

```typescript [TypeScript]
function minWindow(s: string, t: string): string {
    if (t.length > s.length) return "";

    const need = new Map<string, number>();
    const window = new Map<string, number>();

    // Build need map
    for (const c of t) {
        need.set(c, (need.get(c) || 0) + 1);
    }

    let left = 0;
    let right = 0;
    let valid = 0;
    let start = 0;
    let minLen = Number.MAX_VALUE;

    while (right < s.length) {
        const c = s[right];
        right++;

        if (need.has(c)) {
            window.set(c, (window.get(c) || 0) + 1);
            if (window.get(c) === need.get(c)) {
                valid++;
            }
        }

        // Try to shrink window
        while (valid === need.size) {
            if (right - left < minLen) {
                start = left;
                minLen = right - left;
            }

            const d = s[left];
            left++;

            if (need.has(d)) {
                if (window.get(d) === need.get(d)) {
                    valid--;
                }
                window.set(d, window.get(d)! - 1);
            }
        }
    }

    return minLen === Number.MAX_VALUE ? "" : s.substring(start, start + minLen);
}
```

```java [Java]
class Solution {
    public String minWindow(String s, String t) {
        if (t.length() > s.length()) return "";

        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();

        // Build need map
        for (char c : t.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        int left = 0, right = 0;
        int valid = 0;
        int start = 0, minLen = Integer.MAX_VALUE;

        while (right < s.length()) {
            char c = s.charAt(right);
            right++;

            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c))) {
                    valid++;
                }
            }

            // Try to shrink window
            while (valid == need.size()) {
                if (right - left < minLen) {
                    start = left;
                    minLen = right - left;
                }

                char d = s.charAt(left);
                left++;

                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d))) {
                        valid--;
                    }
                    window.put(d, window.get(d) - 1);
                }
            }
        }

        return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
    }
}
```

```python [Python]
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if len(t) > len(s):
            return ""

        need = {}
        window = {}

        # Build need map
        for c in t:
            need[c] = need.get(c, 0) + 1

        left = right = 0
        valid = 0
        start = 0
        min_len = float('inf')

        while right < len(s):
            c = s[right]
            right += 1

            if c in need:
                window[c] = window.get(c, 0) + 1
                if window[c] == need[c]:
                    valid += 1

            # Try to shrink window
            while valid == len(need):
                if right - left < min_len:
                    start = left
                    min_len = right - left

                d = s[left]
                left += 1

                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1

        return "" if min_len == float('inf') else s[start:start + min_len]
```

:::

## Complexity Analysis

- **Time Complexity:** O(n + m)  
  - `n` is the length of string `s`, and `m` is the length of string `t`.  
  - Each character in `s` is visited at most twice — once when expanding the window and once when contracting it.  
  - Building the frequency map for `t` takes O(m).

- **Space Complexity:** O(m)  
  - We use two hash maps: one to store the character counts in `t` (`need`) and another to track the counts in the current window (`window`).  
  - The space complexity depends on the number of unique characters in `t`, which is at most O(m).