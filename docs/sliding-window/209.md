# [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150)

Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the **minimal length**  of a <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1b:" data-state="closed" class="">subarray</button> whose sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.

**Example 1:** 

```
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
```

**Example 2:** 

```
Input: target = 4, nums = [1,4,4]
Output: 1
```

**Example 3:** 

```
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
```

**Constraints:** 

- <code>1 <= target <= 10^9</code>
- <code>1 <= nums.length <= 10^5</code>
- <code>1 <= nums[i] <= 10^4</code>

**Follow up:**  If you have figured out the <code>O(n)</code> solution, try coding another solution of which the time complexity is <code>O(n log(n))</code>.


## ✅ Approach: Sliding Window

Since all numbers are **positive**, we can use a **shrinking window** approach:

1. Start with both left and right pointers at index 0.
2. Expand the right pointer and add to the running sum.
3. When the sum becomes `>= target`, update the minimum length.
4. Then try to **shrink the window** from the left while still `sum >= target`.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun minSubArrayLen(target: Int, nums: IntArray): Int {
        var left = 0
        var sum = 0
        var minLen = Int.MAX_VALUE

        for (right in nums.indices) {
            sum += nums[right]

            while (sum >= target) {
                minLen = minOf(minLen, right - left + 1)
                sum -= nums[left]
                left++
            }
        }

        return if (minLen == Int.MAX_VALUE) 0 else minLen
    }
}
```

```typescript [TypeScript]
function minSubArrayLen(target: number, nums: number[]): number {
    let left = 0;
    let sum = 0;
    let minLen = Number.MAX_SAFE_INTEGER;

    for (let right = 0; right < nums.length; right++) {
        sum += nums[right];

        while (sum >= target) {
            minLen = Math.min(minLen, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }

    return minLen === Number.MAX_SAFE_INTEGER ? 0 : minLen;
}
```

```java [Java]
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int minLen = Integer.MAX_VALUE;

        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];

            while (sum >= target) {
                minLen = Math.min(minLen, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }

        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

```python [Python]
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        sum_val = 0
        min_len = float('inf')

        for right in range(len(nums)):
            sum_val += nums[right]

            while sum_val >= target:
                min_len = min(min_len, right - left + 1)
                sum_val -= nums[left]
                left += 1

        return 0 if min_len == float('inf') else min_len
```

:::

## Complexity Analysis

- **Time Complexity:** O(n)  
  Each element is visited at most twice — once by the right pointer and once by the left pointer. So the total number of operations is linear in the size of the array.

- **Space Complexity:** O(1)  
  We only use a constant number of variables (`left`, `sum`, `minLen`), regardless of the input size.
