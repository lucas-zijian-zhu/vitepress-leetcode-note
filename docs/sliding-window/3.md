# [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-interview-150)

Given a string <code>s</code>, find the length of the **longest**  <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1b:" data-state="closed" class="">**substring** </button> without duplicate characters.

**Example 1:** 

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:** 

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:** 

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:** 

- <code>0 <= s.length <= 5 * 10^4</code>
- <code>s</code> consists of English letters, digits, symbols and spaces.

## Approach: Sliding Window + HashSet

We use the **sliding window** technique to maintain a dynamic window of characters that are **non-repeating**.

- A `Set<Char>` is used to track which characters are currently in the window.
- Two pointers `left` and `right` define the window boundaries.
- If `s[right]` is not in the set, we add it and expand the window.
- If it **is** in the set, we shrink the window from the left until the duplicate is removed.

This guarantees that the window always contains unique characters.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun lengthOfLongestSubstring(s: String): Int {
        var left = 0
        val seen = mutableSetOf<Char>()
        var maxLen = 0

        for (right in s.indices) {
            while (s[right] in seen) {
                seen.remove(s[left])
                left++
            }
            seen.add(s[right])
            maxLen = maxOf(maxLen, right - left + 1)
        }

        return maxLen
    }
}
```

```typescript [TypeScript]
function lengthOfLongestSubstring(s: string): number {
    let left = 0;
    const seen = new Set<string>();
    let maxLen = 0;

    for (let right = 0; right < s.length; right++) {
        while (seen.has(s[right])) {
            seen.delete(s[left]);
            left++;
        }
        seen.add(s[right]);
        maxLen = Math.max(maxLen, right - left + 1);
    }

    return maxLen;
}
```

```java [Java]
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int left = 0;
        Set<Character> seen = new HashSet<>();
        int maxLen = 0;

        for (int right = 0; right < s.length(); right++) {
            while (seen.contains(s.charAt(right))) {
                seen.remove(s.charAt(left));
                left++;
            }
            seen.add(s.charAt(right));
            maxLen = Math.max(maxLen, right - left + 1);
        }

        return maxLen;
    }
}
```

```python [Python]
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = 0
        seen = set()
        max_len = 0

        for right in range(len(s)):
            while s[right] in seen:
                seen.remove(s[left])
                left += 1
            seen.add(s[right])
            max_len = max(max_len, right - left + 1)

        return max_len
```

:::

## Complexity Analysis

- **Time Complexity:** O(n)  
  Each character is visited at most twice â€” once by the right pointer, and once by the left pointer. So the total time complexity is linear in the size of the input string.

- **Space Complexity:** O(min(n, m))  
  Where `n` is the length of the input string and `m` is the size of the character set (e.g. 128 for ASCII).  
  We use a set to store at most `m` characters.