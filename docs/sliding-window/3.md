# [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-interview-150)

Given a string <code>s</code>, find the length of the **longest**  <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1b:" data-state="closed" class="">**substring** </button> without duplicate characters.

**Example 1:** 

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:** 

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:** 

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:** 

- <code>0 <= s.length <= 5 * 10^4</code>
- <code>s</code> consists of English letters, digits, symbols and spaces.

## Approach: Sliding Window + HashSet

We use the **sliding window** technique to maintain a dynamic window of characters that are **non-repeating**.

- A `Set<Char>` is used to track which characters are currently in the window.
- Two pointers `left` and `right` define the window boundaries.
- If `s[right]` is not in the set, we add it and expand the window.
- If it **is** in the set, we shrink the window from the left until the duplicate is removed.

This guarantees that the window always contains unique characters.

## Kotlin Code

```kotlin
class Solution {
    fun lengthOfLongestSubstring(s: String): Int {
        var left = 0
        val seen = mutableSetOf<Char>()
        var maxLen = 0

        for (right in s.indices) {
            while (s[right] in seen) {
                seen.remove(s[left])
                left++
            }
            seen.add(s[right])
            maxLen = maxOf(maxLen, right - left + 1)
        }

        return maxLen
    }
}
```

## Complexity Analysis

- **Time Complexity:** O(n)  
  Each character is visited at most twice â€” once by the right pointer, and once by the left pointer. So the total time complexity is linear in the size of the input string.

- **Space Complexity:** O(min(n, m))  
  Where `n` is the length of the input string and `m` is the size of the character set (e.g. 128 for ASCII).  
  We use a set to store at most `m` characters.