# [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="danger" text="Hard" />

Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return **the median**  of the two sorted arrays.

The overall run time complexity should be <code>O(log (m+n))</code>.

**Example 1:** 

```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
```

**Example 2:** 

```
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```

**Constraints:** 

- <code>nums1.length == m</code>
- <code>nums2.length == n</code>
- <code>0 <= m <= 1000</code>
- <code>0 <= n <= 1000</code>
- <code>1 <= m + n <= 2000</code>
- <code>-10^6 <= nums1[i], nums2[i] <= 10^6</code>

## ðŸ’¡ Approach: Binary Search on Partitions

### Intuition

We want the median of the merged arrays without actually merging. Think of a partition that splits the combined sorted array into left and right halves such that:

- All elements in the left half are less than or equal to all elements in the right half
- Left half size equals right half size (for even total) or exceeds by one (for odd total)

Binary search the partition index on the smaller array `nums1` so that the partition boundary across `nums1` and `nums2` meets the above condition.

Define:
- `i` = cut position in `nums1` (0..m)
- `j` = halfLen - i, where `halfLen = (m + n + 1) // 2`

Check the validity of the cut by comparing border elements:
- `nums1Left = nums1[i-1]` if `i > 0` else `-âˆž`
- `nums1Right = nums1[i]` if `i < m` else `+âˆž`
- `nums2Left = nums2[j-1]` if `j > 0` else `-âˆž`
- `nums2Right = nums2[j]` if `j < n` else `+âˆž`

Valid partition when `nums1Left <= nums2Right` and `nums2Left <= nums1Right`.

If partition is invalid:
- If `nums1Left > nums2Right`, move `i` left
- Else move `i` right

Finally, compute the median from the max of left and min of right sides, depending on parity of `m + n`.

### Algorithm

1. Ensure `nums1` is the shorter array; swap if necessary
2. Set `left = 0`, `right = m`, `halfLen = (m + n + 1) // 2`
3. While `left <= right`:
   - `i = (left + right) // 2`, `j = halfLen - i`
   - Adjust `left/right` based on border comparisons
   - When valid, compute median:
     - If total is odd: `max(nums1Left, nums2Left)`
     - Else: `(max(nums1Left, nums2Left) + min(nums1Right, nums2Right)) / 2`

### Key Points

- Binary search on the smaller array only
- Careful with boundaries (use sentinels `Â±âˆž`)
- Works in O(log(min(m, n))) time and O(1) space

## Code

:::: code-group

```typescript [TypeScript]
function findMedianSortedArrays(nums1: number[], nums2: number[]): number {
  let A = nums1, B = nums2;
  if (A.length > B.length) [A, B] = [B, A];
  const m = A.length, n = B.length;
  let left = 0, right = m;
  const halfLen = Math.floor((m + n + 1) / 2);

  while (left <= right) {
    const i = Math.floor((left + right) / 2);
    const j = halfLen - i;

    const Aleft = i > 0 ? A[i - 1] : -Infinity;
    const Aright = i < m ? A[i] : Infinity;
    const Bleft = j > 0 ? B[j - 1] : -Infinity;
    const Bright = j < n ? B[j] : Infinity;

    if (Aleft <= Bright && Bleft <= Aright) {
      const maxLeft = Math.max(Aleft, Bleft);
      if ((m + n) % 2 === 1) return maxLeft;
      const minRight = Math.min(Aright, Bright);
      return (maxLeft + minRight) / 2;
    } else if (Aleft > Bright) {
      right = i - 1;
    } else {
      left = i + 1;
    }
  }
  return 0;
}
```

```kotlin [Kotlin]
fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {
    var A = nums1
    var B = nums2
    if (A.size > B.size) {
        val tmp = A
        A = B
        B = tmp
    }
    val m = A.size
    val n = B.size
    var left = 0
    var right = m
    val halfLen = (m + n + 1) / 2

    while (left <= right) {
        val i = (left + right) / 2
        val j = halfLen - i

        val Aleft = if (i > 0) A[i - 1] else Int.MIN_VALUE
        val Aright = if (i < m) A[i] else Int.MAX_VALUE
        val Bleft = if (j > 0) B[j - 1] else Int.MIN_VALUE
        val Bright = if (j < n) B[j] else Int.MAX_VALUE

        if (Aleft <= Bright && Bleft <= Aright) {
            val maxLeft = maxOf(Aleft, Bleft)
            if ((m + n) % 2 == 1) return maxLeft.toDouble()
            val minRight = minOf(Aright, Bright)
            return (maxLeft + minRight) / 2.0
        } else if (Aleft > Bright) {
            right = i - 1
        } else {
            left = i + 1
        }
    }
    return 0.0
}
```

```java [Java]
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int[] A = nums1, B = nums2;
        if (A.length > B.length) {
            int[] t = A; A = B; B = t;
        }
        int m = A.length, n = B.length;
        int left = 0, right = m;
        int halfLen = (m + n + 1) / 2;

        while (left <= right) {
            int i = (left + right) / 2;
            int j = halfLen - i;

            int Aleft = (i > 0) ? A[i - 1] : Integer.MIN_VALUE;
            int Aright = (i < m) ? A[i] : Integer.MAX_VALUE;
            int Bleft = (j > 0) ? B[j - 1] : Integer.MIN_VALUE;
            int Bright = (j < n) ? B[j] : Integer.MAX_VALUE;

            if (Aleft <= Bright && Bleft <= Aright) {
                int maxLeft = Math.max(Aleft, Bleft);
                if (((m + n) % 2) == 1) return maxLeft;
                int minRight = Math.min(Aright, Bright);
                return (maxLeft + minRight) / 2.0;
            } else if (Aleft > Bright) {
                right = i - 1;
            } else {
                left = i + 1;
            }
        }
        return 0.0;
    }
}
```

```swift [Swift]
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
        let total = nums1.count + nums2.count
        var i = 0
        var j = 0
        var prev = 0
        var curr = 0

        for _ in 0...total / 2 {
            prev = curr
            if i < nums1.count && (j >= nums2.count || nums1[i] <= nums2[j]) {
                curr = nums1[i]
                i += 1
            } else {
                curr = nums2[j]
                j += 1
            }
        }

        if total % 2 == 0 {
            return Double(prev + curr) / 2.0
        } else {
            return Double(curr)
        }
    }
}
```

```python [Python]
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        A, B = nums1, nums2
        if len(A) > len(B):
            A, B = B, A
        m, n = len(A), len(B)
        left, right = 0, m
        halfLen = (m + n + 1) // 2

        while left <= right:
            i = (left + right) // 2
            j = halfLen - i

            Aleft = A[i - 1] if i > 0 else float('-inf')
            Aright = A[i] if i < m else float('inf')
            Bleft = B[j - 1] if j > 0 else float('-inf')
            Bright = B[j] if j < n else float('inf')

            if Aleft <= Bright and Bleft <= Aright:
                maxLeft = max(Aleft, Bleft)
                if (m + n) % 2 == 1:
                    return float(maxLeft)
                minRight = min(Aright, Bright)
                return (maxLeft + minRight) / 2.0
            elif Aleft > Bright:
                right = i - 1
            else:
                left = i + 1

        return 0.0
```

::::
## Complexity

- **Time Complexity:** O(log(min(m, n)))
- **Space Complexity:** O(1)