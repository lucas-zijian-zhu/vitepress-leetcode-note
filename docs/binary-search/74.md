# [74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:

- Each row is sorted in non-decreasing order.
- The first integer of each row is greater than the last integer of the previous row.

Given an integer <code>target</code>, return <code>true</code> if <code>target</code> is in <code>matrix</code> or <code>false</code> otherwise.

You must write a solution in <code>O(log(m * n))</code> time complexity.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" style="width: 322px; height: 242px;">

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" style="width: 322px; height: 242px;">

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
```

**Constraints:** 

- <code>m == matrix.length</code>
- <code>n == matrix[i].length</code>
- <code>1 <= m, n <= 100</code>
- <code>-10^4 <= matrix[i][j], target <= 10^4</code>

## ðŸ’¡ Approach: Binary Search on Flattened Matrix

### Intuition

Since the matrix has two key properties:
1. Each row is sorted in non-decreasing order
2. The first integer of each row is greater than the last integer of the previous row

This means we can treat the entire matrix as a **single sorted array** and apply binary search.

### Algorithm

1. **Flatten the matrix:** Treat the 2D matrix as a 1D array
2. **Convert indices:** 
   - 2D position `(row, col)` â†’ 1D index: `row * n + col`
   - 1D index â†’ 2D position: `row = index / n`, `col = index % n`
3. **Apply binary search** on the flattened array
4. **Compare target** with the element at the calculated 2D position

### Key Points

- Matrix properties allow treating it as a single sorted array
- Index conversion between 1D and 2D coordinates
- Binary search reduces time complexity to O(log(m*n))
- Handle edge cases (empty matrix)

## Code

::: code-group

```kotlin [Kotlin]
fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {
    if (matrix.isEmpty() || matrix[0].isEmpty()) return false
    
    val m = matrix.size
    val n = matrix[0].size
    var left = 0
    var right = m * n - 1
    
    while (left <= right) {
        val mid = left + (right - left) / 2
        val row = mid / n
        val col = mid % n
        
        when {
            matrix[row][col] == target -> return true
            matrix[row][col] < target -> left = mid + 1
            else -> right = mid - 1
        }
    }
    
    return false
}
```

```typescript [TypeScript]
function searchMatrix(matrix: number[][], target: number): boolean {
    if (!matrix.length || !matrix[0].length) return false;
    
    const m = matrix.length;
    const n = matrix[0].length;
    let left = 0;
    let right = m * n - 1;
    
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        const row = Math.floor(mid / n);
        const col = mid % n;
        
        if (matrix[row][col] === target) {
            return true;
        } else if (matrix[row][col] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return false;
}
```

```java [Java]
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        
        int m = matrix.length;
        int n = matrix[0].length;
        int left = 0;
        int right = m * n - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int row = mid / n;
            int col = mid % n;
            
            if (matrix[row][col] == target) {
                return true;
            } else if (matrix[row][col] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return false;
    }
}
```

```python [Python]
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix or not matrix[0]:
            return False
        
        m, n = len(matrix), len(matrix[0])
        left, right = 0, m * n - 1
        
        while left <= right:
            mid = (left + right) // 2
            row, col = divmod(mid, n)
            
            if matrix[row][col] == target:
                return True
            elif matrix[row][col] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return False
```

:::

## Complexity

- **Time Complexity:** O(log(m * n)), binary search on m*n elements
- **Space Complexity:** O(1), constant extra space used