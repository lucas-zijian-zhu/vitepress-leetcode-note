# [154. Find Minimum in Rotated Sorted Array II](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/)<Badge type="danger" text="Hard" />

Suppose an array of length <code>n</code> sorted in ascending order is **rotated** between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:

- <code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.
- <code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.

Notice that **rotating** an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.

Given the sorted rotated array <code>nums</code> that may contain **duplicates**, return the minimum element of this array.

You must write an algorithm that runs in <code>O(log n)</code> time on average.

**Example 1:** 

```
Input: nums = [1,3,5]
Output: 1
```

**Example 2:** 

```
Input: nums = [2,2,2,0,1]
Output: 0
```

**Constraints:** 

- <code>n == nums.length</code>
- <code>1 <= n <= 5000</code>
- <code>-5000 <= nums[i] <= 5000</code>
- <code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times and may contain **duplicates**.

## ðŸ’¡ Approach: Binary Search with Duplicate Handling

### Intuition

Same as [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/): compare <code>nums[mid]</code> with <code>nums[right]</code> to narrow the range. With **duplicates**, when <code>nums[mid] == nums[right]</code> we cannot tell which side has the minimum (e.g. <code>[3,3,1,3]</code> vs <code>[3,1,3,3]</code>). In that case we shrink by <code>right--</code> until we can decide.

**Key Observations:**
1. If <code>nums[mid] > nums[right]</code>: minimum is strictly to the right of <code>mid</code> â†’ <code>left = mid + 1</code>.
2. If <code>nums[mid] < nums[right]</code>: minimum is at <code>mid</code> or left â†’ <code>right = mid</code>.
3. If <code>nums[mid] == nums[right]</code>: cannot tell â†’ <code>right--</code> and continue (worst case O(n)).

### Algorithm

1. Initialize <code>left = 0</code>, <code>right = nums.length - 1</code>.
2. While <code>left < right</code>:
   - <code>mid = left + (right - left) / 2</code>
   - If <code>nums[mid] > nums[right]</code>: <code>left = mid + 1</code>
   - Else if <code>nums[mid] < nums[right]</code>: <code>right = mid</code>
   - Else: <code>right--</code>
3. Return <code>nums[left]</code>.

### Key Points

- Duplicates break the comparison; <code>right--</code> is the standard way to shrink.
- Worst-case time O(n) when many duplicates; average O(log n). Space O(1).

## Code

::: code-group

```typescript [TypeScript]
function findMin(nums: number[]): number {
    let left = 0;
    let right = nums.length - 1;

    while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else if (nums[mid] < nums[right]) {
            right = mid;
        } else {
            right--;
        }
    }
    return nums[left];
}
```

```kotlin [Kotlin]
fun findMin(nums: IntArray): Int {
    var left = 0
    var right = nums.size - 1

    while (left < right) {
        val mid = left + (right - left) / 2
        when {
            nums[mid] > nums[right] -> left = mid + 1
            nums[mid] < nums[right] -> right = mid
            else -> right--
        }
    }
    return nums[left]
}
```

```java [Java]
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else if (nums[mid] < nums[right]) {
                right = mid;
            } else {
                right--;
            }
        }
        return nums[left];
    }
}
```

```swift [Swift]
class Solution {
    func findMin(_ nums: [Int]) -> Int {
        var left = 0
        var right = nums.count - 1

        while left < right {
            let mid = (left + right) / 2
            if nums[mid] > nums[right] {
                left = mid + 1
            } else if nums[mid] < nums[right] {
                right = mid
            } else {
                right -= 1
            }
        }
        return nums[left]
    }
}
```

```python [Python]
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            elif nums[mid] < nums[right]:
                right = mid
            else:
                right -= 1
        return nums[left]
```

:::

## Complexity

- **Time Complexity:** O(log n) on average; O(n) worst case when there are many duplicates.
- **Space Complexity:** O(1).
