# [540. Single Element in a Sorted Array](https://leetcode.com/problems/single-element-in-a-sorted-array/description/)<Badge type="warning" text="Medium" />

You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.

Return the single element that appears only once.

Your solution must run in <code>O(log n)</code> time and <code>O(1)</code> space.

**Example 1:** 

```
Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
```

**Example 2:** 

```
Input: nums = [3,3,7,7,10,11,11]
Output: 10
```

**Constraints:** 

- <code>1 <= nums.length <= 10^5</code>
- <code>0 <= nums[i] <= 10^5</code>
- <code>nums</code> is sorted in non-decreasing order.

## ðŸ’¡ Approach: Binary Search on Pair Indices

### Intuition

Before the single element, pairs occupy indices <code>(0,1), (2,3), (4,5), ...</code> â€” each pair starts at an **even** index. After the single, pairs shift: the first of each pair starts at an **odd** index. We can binary search by always inspecting an even-indexed position and its neighbor.

**Key idea:** Force <code>mid</code> to be even so we look at a pair <code>(mid, mid+1)</code>.
- If <code>nums[mid] == nums[mid+1]</code>: the pair is intact, so the single is to the **right** â†’ <code>left = mid + 2</code>.
- Else: the single is at <code>mid</code> or to the **left** â†’ <code>right = mid</code>.

### Algorithm

1. Initialize <code>left = 0</code>, <code>right = nums.length - 1</code>.
2. While <code>left < right</code>:
   - <code>mid = left + (right - left) / 2</code>
   - If <code>mid</code> is odd, set <code>mid = mid - 1</code> (so <code>mid</code> is even).
   - If <code>nums[mid] == nums[mid + 1]</code>: <code>left = mid + 2</code>.
   - Else: <code>right = mid</code>.
3. Return <code>nums[left]</code>.

### Key Points

- Keeping <code>mid</code> even ensures we always examine a pair boundary.
- O(log n) time, O(1) space.

## Code

::: code-group

```typescript [TypeScript]
function singleNonDuplicate(nums: number[]): number {
    let left = 0;
    let right = nums.length - 1;

    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (mid % 2 === 1) mid--;
        if (nums[mid] === nums[mid + 1]) {
            left = mid + 2;
        } else {
            right = mid;
        }
    }
    return nums[left];
}
```

```kotlin [Kotlin]
fun singleNonDuplicate(nums: IntArray): Int {
    var left = 0
    var right = nums.size - 1

    while (left < right) {
        var mid = left + (right - left) / 2
        if (mid % 2 == 1) mid--
        if (nums[mid] == nums[mid + 1]) {
            left = mid + 2
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

```java [Java]
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (mid % 2 == 1) mid--;
            if (nums[mid] == nums[mid + 1]) {
                left = mid + 2;
            } else {
                right = mid;
            }
        }
        return nums[left];
    }
}
```

```swift [Swift]
class Solution {
    func singleNonDuplicate(_ nums: [Int]) -> Int {
        var left = 0
        var right = nums.count - 1

        while left < right {
            var mid = (left + right) / 2
            if mid % 2 == 1 { mid -= 1 }
            if nums[mid] == nums[mid + 1] {
                left = mid + 2
            } else {
                right = mid
            }
        }
        return nums[left]
    }
}
```

```python [Python]
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if mid % 2 == 1:
                mid -= 1
            if nums[mid] == nums[mid + 1]:
                left = mid + 2
            else:
                right = mid
        return nums[left]
```

:::

## Complexity

- **Time Complexity:** O(log n)
- **Space Complexity:** O(1)
