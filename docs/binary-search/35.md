# [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Easy" />

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with <code>O(log n)</code> runtime complexity.

**Example 1:** 

```
Input: nums = [1,3,5,6], target = 5
Output: 2
```

**Example 2:** 

```
Input: nums = [1,3,5,6], target = 2
Output: 1
```

**Example 3:** 

```
Input: nums = [1,3,5,6], target = 7
Output: 4
```

**Constraints:** 

- <code>1 <= nums.length <= 10^4</code>
- <code>-10^4 <= nums[i] <= 10^4</code>
- <code>nums</code> contains **distinct** values sorted in **ascending** order.
- <code>-10^4 <= target <= 10^4</code>

## ðŸ’¡ Approach: Binary Search

### Intuition

This is a classic binary search problem. Since the array is sorted, we can use binary search to find the target value's position.

**Core Idea:**
1. Use binary search to find the target value in the sorted array
2. If found, return its index
3. If not found, return the insertion position

### Algorithm

1. **Initialize pointers:** `left = 0`, `right = nums.length - 1`
2. **Calculate middle:** `mid = (left + right) / 2`
3. **Compare values:**
   - If `nums[mid] == target`, return `mid`
   - If `nums[mid] < target`, search right half: `left = mid + 1`
   - If `nums[mid] > target`, search left half: `right = mid - 1`
4. **When loop ends:** `left` is the insertion position

### Key Points

- Binary search on sorted array
- When target not found, `left` pointer indicates insertion position
- Handle edge cases (target larger than all elements)
- Avoid integer overflow in mid calculation

## Code

::: code-group

```kotlin [Kotlin]
fun searchInsert(nums: IntArray, target: Int): Int {
    var left = 0
    var right = nums.size - 1
    
    while (left <= right) {
        val mid = left + (right - left) / 2
        
        when {
            nums[mid] == target -> return mid
            nums[mid] < target -> left = mid + 1
            else -> right = mid - 1
        }
    }
    
    return left
}
```

```typescript [TypeScript]
function searchInsert(nums: number[], target: number): number {
    let left = 0;
    let right = nums.length - 1;
    
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return left;
}
```

```java [Java]
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return left;
    }
}
```

```python [Python]
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2
            
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return left
```

:::

## Complexity

- **Time Complexity:** O(log n), binary search time complexity
- **Space Complexity:** O(1), constant extra space used