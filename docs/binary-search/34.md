# [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.

If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.

You must write an algorithm with <code>O(log n)</code> runtime complexity.

**Example 1:** 

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```

**Example 2:** 

```
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
```

**Example 3:** 

```
Input: nums = [], target = 0
Output: [-1,-1]
```

**Constraints:** 

- <code>0 <= nums.length <= 10^5</code>
- <code>-10^9<= nums[i]<= 10^9</code>
- <code>nums</code> is a non-decreasing array.
- <code>-10^9<= target<= 10^9</code>

## ðŸ’¡ Approach: Two Binary Searches (Lower and Upper Bound)

### Intuition

We need the first and last positions of <code>target</code>. In a sorted array, we can run binary search twice:
- One to find the first index where value >= target (lower bound)
- One to find the first index where value > target, then minus one (upper bound)

### Algorithm

1. **Lower bound (first position >= target):**
   - Standard binary search variant moving <code>right</code> when <code>nums[mid] >= target</code>
2. **Upper bound (last position <= target):**
   - Find first index of value > target, then subtract 1
3. **Validate:**
   - If lower bound is out of range or <code>nums[lower] != target</code>, return <code>[-1, -1]</code>
   - Otherwise return <code>[lower, upper]</code>

### Key Points

- Works with duplicates due to bound-style searches
- Overall O(log n) time, O(1) space
- Check bounds to avoid index errors

## Code

::: code-group

```kotlin [Kotlin]
fun searchRange(nums: IntArray, target: Int): IntArray {
    fun lowerBound(): Int {
        var l = 0
        var r = nums.size
        while (l < r) {
            val m = l + (r - l) / 2
            if (nums[m] >= target) r = m else l = m + 1
        }
        return l
    }
    
    fun upperBound(): Int {
        var l = 0
        var r = nums.size
        while (l < r) {
            val m = l + (r - l) / 2
            if (nums[m] > target) r = m else l = m + 1
        }
        return l
    }

    val left = lowerBound()
    if (left == nums.size || (left < nums.size && nums[left] != target)) return intArrayOf(-1, -1)
    val right = upperBound() - 1
    return intArrayOf(left, right)
}
```

```typescript [TypeScript]
function searchRange(nums: number[], target: number): number[] {
    const lowerBound = (): number => {
        let l = 0, r = nums.length;
        while (l < r) {
            const m = l + Math.floor((r - l) / 2);
            if (nums[m] >= target) r = m; else l = m + 1;
        }
        return l;
    };

    const upperBound = (): number => {
        let l = 0, r = nums.length;
        while (l < r) {
            const m = l + Math.floor((r - l) / 2);
            if (nums[m] > target) r = m; else l = m + 1;
        }
        return l;
    };

    const left = lowerBound();
    if (left === nums.length || nums[left] !== target) return [-1, -1];
    const right = upperBound() - 1;
    return [left, right];
}
```

```java [Java]
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = lowerBound(nums, target);
        if (left == nums.length || nums[left] != target) return new int[]{-1, -1};
        int right = upperBound(nums, target) - 1;
        return new int[]{left, right};
    }

    private int lowerBound(int[] nums, int target) {
        int l = 0, r = nums.length;
        while (l < r) {
            int m = l + (r - l) / 2;
            if (nums[m] >= target) r = m; else l = m + 1;
        }
        return l;
    }

    private int upperBound(int[] nums, int target) {
        int l = 0, r = nums.length;
        while (l < r) {
            int m = l + (r - l) / 2;
            if (nums[m] > target) r = m; else l = m + 1;
        }
        return l;
    }
}
```

```python [Python]
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def lower_bound() -> int:
            l, r = 0, len(nums)
            while l < r:
                m = (l + r) // 2
                if nums[m] >= target:
                    r = m
                else:
                    l = m + 1
            return l
        
        def upper_bound() -> int:
            l, r = 0, len(nums)
            while l < r:
                m = (l + r) // 2
                if nums[m] > target:
                    r = m
                else:
                    l = m + 1
            return l
        
        left = lower_bound()
        if left == len(nums) or (left < len(nums) and nums[left] != target):
            return [-1, -1]
        right = upper_bound() - 1
        return [left, right]
```

:::

## Complexity

- **Time Complexity:** O(log n), two binary searches
- **Space Complexity:** O(1), constant extra space