# [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/)<Badge type="warning" text="Medium" />

There is an integer array <code>nums</code> sorted in non-decreasing order (not necessarily with **distinct** values).

Prior to being passed to your function, <code>nums</code> is **possibly rotated** at an unknown pivot index <code>k</code> (<code>1 <= k < nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (**0-indexed**). For example, <code>[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot <code>5</code> and become <code>[4,5,6,6,7,0,1,2,4,4]</code>.

Given the array <code>nums</code> **after** the possible rotation and an integer <code>target</code>, return <code>true</code> if <code>target</code> is in <code>nums</code>, or <code>false</code> if it is not in <code>nums</code>.

You must write an algorithm with <code>O(log n)</code> runtime complexity.

**Example 1:** 

```
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
```

**Example 2:** 

```
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
```

**Constraints:** 

- <code>1 <= nums.length <= 5000</code>
- <code>-10^4 <= nums[i] <= 10^4</code>
- <code>nums</code> is sorted in non-decreasing order and **possibly rotated**.
- <code>-10^4 <= target <= 10^4</code>

## üí° Approach: Binary Search with Duplicate Handling

### Intuition

Same idea as [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/): at least one half is sorted, so we can narrow the search. With **duplicates**, when <code>nums[left] == nums[mid]</code> we cannot tell which half is sorted (e.g. <code>[1,0,1,1,1]</code> vs <code>[1,1,1,0,1]</code>). In that case we shrink by moving <code>left++</code> (or <code>right--</code>) until we can decide.

**Key Observations:**
1. If <code>nums[left] < nums[mid]</code>: left half is sorted; decide by target range.
2. If <code>nums[mid] < nums[right]</code>: right half is sorted; decide by target range.
3. If <code>nums[left] == nums[mid]</code>: cannot tell; do <code>left++</code> and continue (worst case O(n)).

### Algorithm

1. **Initialize:** <code>left = 0</code>, <code>right = nums.length - 1</code>.
2. **While** <code>left <= right</code>:
   - <code>mid = (left + right) / 2</code>. If <code>nums[mid] == target</code>, return <code>true</code>.
   - If <code>nums[left] == nums[mid]</code>: <code>left++</code> and continue (skip duplicate).
   - Else if left half is sorted (<code>nums[left] <= nums[mid]</code>): if target in <code>[nums[left], nums[mid])</code> go left, else right.
   - Else (right half sorted): if target in <code>(nums[mid], nums[right]]</code> go right, else left.
3. Return <code>false</code>.

### Key Points

- Duplicates break the ‚Äúwhich half is sorted‚Äù check; shrinking with <code>left++</code> is the standard fix.
- Worst-case time is O(n) when many duplicates; average remains O(log n).
- Space O(1).

## Code

::: code-group

```typescript [TypeScript]
function search(nums: number[], target: number): boolean {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] === target) return true;

        if (nums[left] === nums[mid]) {
            left++;
            continue;
        }

        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return false;
}
```

```kotlin [Kotlin]
fun search(nums: IntArray, target: Int): Boolean {
    var left = 0
    var right = nums.size - 1

    while (left <= right) {
        val mid = left + (right - left) / 2
        if (nums[mid] == target) return true

        if (nums[left] == nums[mid]) {
            left++
            continue
        }

        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return false
}
```

```java [Java]
class Solution {
    public boolean search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return true;

            if (nums[left] == nums[mid]) {
                left++;
                continue;
            }

            if (nums[left] <= nums[mid]) {
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return false;
    }
}
```

```swift [Swift]
class Solution {
    func search(_ nums: [Int], _ target: Int) -> Bool {
        var left = 0
        var right = nums.count - 1

        while left <= right {
            let mid = (left + right) / 2
            if nums[mid] == target { return true }

            if nums[left] == nums[mid] {
                left += 1
                continue
            }

            if nums[left] <= nums[mid] {
                if nums[left] <= target && target < nums[mid] {
                    right = mid - 1
                } else {
                    left = mid + 1
                }
            } else {
                if nums[mid] < target && target <= nums[right] {
                    left = mid + 1
                } else {
                    right = mid - 1
                }
            }
        }
        return false
    }
}
```

```python [Python]
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return True

            if nums[left] == nums[mid]:
                left += 1
                continue

            if nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1

        return False
```

:::

## Complexity

- **Time Complexity:** O(log n) on average; O(n) worst case when there are many duplicates and we repeatedly do <code>left++</code>.
- **Space Complexity:** O(1).
