# [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

Given the <code>head</code> of a linked list, return *the node where the cycle begins. If there is no cycle, return* <code>null</code>.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail's <code>next</code> pointer is connected to (**0-indexed**). It is <code>-1</code> if there is no cycle. **Note that** <code>pos</code> **is not passed as a parameter**.

**Do not modify** the linked list.

**Example 1:**
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" style="width: 300px; height: 97px;">

```
Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the 2nd node.
```

**Example 2:**
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" style="width: 141px; height: 74px;">

```
Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the 1st node.
```

**Example 3:**
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" style="width: 45px; height: 45px;">

```
Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.
```

**Constraints:**

- The number of the nodes in the list is in the range <code>[0, 10^4]</code>.
- <code>-10^5 <= Node.val <= 10^5</code>
- <code>pos</code> is <code>-1</code> or a **valid index** in the linked-list.

**Follow up:** Can you solve it using <code>O(1)</code> (i.e. constant) memory?

## Approach: Floyd's Cycle Detection (Two Phase) ðŸŒŸ

**Best Solution - O(1) Space**

1. **Phase 1 â€“ Detect cycle:** Use fast and slow pointers. If they meet, there is a cycle.
2. **Phase 2 â€“ Find entrance:** After they meet, put one pointer at <code>head</code>, keep the other at the meeting node. Move both one step at a time. They meet at the cycle entrance.

**Why this works:**  
Let distance from head to cycle start = <code>a</code>, cycle length = <code>b</code>. When slow enters the cycle, fast is already inside. When they meet, slow has moved <code>a + k</code> steps and fast <code>a + k + mb</code> (multiple of <code>b</code>). Since fast = 2Â·slow, we get <code>a + k = mb</code>. So moving one pointer from head by <code>a</code> and the other from the meeting point by <code>a</code> (which is <code>mb - k</code> along the cycle) brings both to the cycle start.

## Code

::: code-group

```typescript [TypeScript]
function detectCycle(head: ListNode | null): ListNode | null {
    let slow = head;
    let fast = head;

    while (fast !== null && fast.next !== null) {
        slow = slow!.next;
        fast = fast.next.next;
        if (slow === fast) {
            let entry: ListNode | null = head;
            while (entry !== slow) {
                entry = entry!.next;
                slow = slow!.next;
            }
            return entry;
        }
    }
    return null;
}
```

```kotlin [Kotlin]
class Solution {
    fun detectCycle(head: ListNode?): ListNode? {
        var slow = head
        var fast = head

        while (fast?.next != null) {
            slow = slow?.next
            fast = fast.next?.next
            if (slow == fast) {
                var entry = head
                while (entry != slow) {
                    entry = entry?.next
                    slow = slow?.next
                }
                return entry
            }
        }
        return null
    }
}
```

```java [Java]
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                ListNode entry = head;
                while (entry != slow) {
                    entry = entry.next;
                    slow = slow.next;
                }
                return entry;
            }
        }
        return null;
    }
}
```

```swift [Swift]
// Definition for singly-linked list.
public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init() { self.val = 0; self.next = nil }
    public init(_ val: Int) { self.val = val; self.next = nil }
    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next }
}

class Solution {
    func detectCycle(_ head: ListNode?) -> ListNode? {
        var slow = head
        var fast = head
        while fast?.next != nil {
            slow = slow?.next
            fast = fast?.next?.next
            if slow === fast {
                var entry = head
                while entry !== slow {
                    entry = entry?.next
                    slow = slow?.next
                }
                return entry
            }
        }
        return nil
    }
}
```

```python [Python]
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                entry = head
                while entry != slow:
                    entry = entry.next
                    slow = slow.next
                return entry
        return None
```

:::
## Complexity

- **Time Complexity:** O(n) â€” Each node visited a constant number of times.
- **Space Complexity:** O(1) â€” Only two pointers used.
