# [82. Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

Given the <code>head</code> of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list **sorted**  as well.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" style="width: 500px; height: 142px;">

```
Input: head = [1,2,3,3,4,4,5]
Output: [1,2,5]
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" style="width: 500px; height: 205px;">

```
Input: head = [1,1,1,2,3]
Output: [2,3]
```

**Constraints:** 

- The number of nodes in the list is in the range <code>[0, 300]</code>.
- <code>-100 <= Node.val <= 100</code>
- The list is guaranteed to be **sorted**  in ascending order.

## Approach

1. Since the list is sorted, duplicates will always appear consecutively.
2. Use a **dummy node** pointing to the head to handle edge cases (e.g., duplicates at the beginning).
3. Maintain two pointers:
   - `prev`: the last node before a group of duplicates.
   - `curr`: the current node being inspected.
4. Traverse the list:
   - If `curr` has duplicates (i.e., `curr.val == curr.next.val`), skip the entire group of duplicates by moving `curr` forward until the value changes.
   - Connect `prev.next` to the node after the duplicates.
   - Otherwise, move `prev` forward normally.
5. Continue until the end of the list.
6. Return `dummy.next` as the new head.

## Code

::: code-group

```typescript [TypeScript]
class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.next = (next === undefined ? null : next);
    }
}

function deleteDuplicates(head: ListNode | null): ListNode | null {
    const dummy = new ListNode(0);
    dummy.next = head;
    let prev: ListNode | null = dummy;
    let curr = head;

    while (curr !== null) {
        // Detect duplicates
        if (curr.next !== null && curr.val === curr.next.val) {
            const duplicateVal = curr.val;
            // Skip all nodes with the same value
            while (curr !== null && curr.val === duplicateVal) {
                curr = curr.next;
            }
            prev!.next = curr;
        } else {
            prev = curr;
            curr = curr.next;
        }
    }

    return dummy.next;
}
```

```kotlin [Kotlin]
class ListNode(var `val`: Int) {
    var next: ListNode? = null
}

class Solution {
    fun deleteDuplicates(head: ListNode?): ListNode? {
        val dummy = ListNode(0)
        dummy.next = head
        var prev: ListNode? = dummy
        var curr = head

        while (curr != null) {
            // Detect duplicates
            if (curr.next != null && curr.`val` == curr.next!!.`val`) {
                val duplicateVal = curr.`val`
                // Skip all nodes with the same value
                while (curr != null && curr.`val` == duplicateVal) {
                    curr = curr.next
                }
                prev?.next = curr
            } else {
                prev = curr
                curr = curr.next
            }
        }

        return dummy.next
    }
}
```

```java [Java]
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        ListNode curr = head;

        while (curr != null) {
            // Detect duplicates
            if (curr.next != null && curr.val == curr.next.val) {
                int duplicateVal = curr.val;
                // Skip all nodes with the same value
                while (curr != null && curr.val == duplicateVal) {
                    curr = curr.next;
                }
                prev.next = curr;
            } else {
                prev = curr;
                curr = curr.next;
            }
        }

        return dummy.next;
    }
}
```

```swift [Swift]
// Definition for singly-linked list.
public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init() { self.val = 0; self.next = nil }
    public init(_ val: Int) { self.val = val; self.next = nil }
    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next }
}

class Solution {
    func deleteDuplicates(_ head: ListNode?) -> ListNode? {
        let dummy = ListNode(0)
        dummy.next = head
        var prev: ListNode? = dummy
        var curr = head
        while curr != nil {
            if let next = curr?.next, curr?.val == next.val {
                let duplicateVal = curr!.val
                while curr != nil && curr?.val == duplicateVal {
                    curr = curr?.next
                }
                prev?.next = curr
            } else {
                prev = curr
                curr = curr?.next
            }
        }
        return dummy.next
    }
}
```

```python [Python]
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        curr = head

        while curr:
            # Detect duplicates
            if curr.next and curr.val == curr.next.val:
                duplicate_val = curr.val
                # Skip all nodes with the same value
                while curr and curr.val == duplicate_val:
                    curr = curr.next
                prev.next = curr
            else:
                prev = curr
                curr = curr.next

        return dummy.next
```

:::
## Complexity

- **Time Complexity:** `O(n)` — each node is visited once.  
- **Space Complexity:** `O(1)` — no extra data structures are used, only pointers.
