# [86. Partition List](https://leetcode.com/problems/partition-list/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes **less than**  <code>x</code> come before nodes **greater than or equal**  to <code>x</code>.

You should **preserve**  the original relative order of the nodes in each of the two partitions.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" style="width: 662px; height: 222px;">

```
Input: head = [1,4,3,2,5,2], x = 3
Output: [1,2,2,4,3,5]
```

**Example 2:** 

```
Input: head = [2,1], x = 2
Output: [1,2]
```

**Constraints:** 

- The number of nodes in the list is in the range <code>[0, 200]</code>.
- <code>-100 <= Node.val <= 100</code>
- <code>-200 <= x <= 200</code>

## Approach

The key insight is to maintain **two separate linked lists**:
1. **Left list**: nodes with values less than `x`
2. **Right list**: nodes with values greater than or equal to `x`

**Algorithm:**
1. Create two dummy heads for the left and right lists
2. Traverse the original list and partition nodes into left and right lists
3. Connect the left list to the right list
4. Set the end of the right list to null to avoid cycles
5. Return the head of the left list

This approach preserves the original relative order within each partition.

## Code

::: code-group

```typescript [TypeScript]
class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.next = (next === undefined ? null : next);
    }
}

function partition(head: ListNode | null, x: number): ListNode | null {
    const leftDummy = new ListNode(0);
    const rightDummy = new ListNode(0);
    let left = leftDummy;
    let right = rightDummy;
    let current = head;

    while (current !== null) {
        if (current.val < x) {
            left.next = current;
            left = left.next!;
        } else {
            right.next = current;
            right = right.next!;
        }
        current = current.next;
    }

    // Connect left list to right list
    left.next = rightDummy.next;
    // Set the end of right list to null
    right.next = null;

    return leftDummy.next;
}
```

```kotlin [Kotlin]
class ListNode(var `val`: Int) {
    var next: ListNode? = null
}

fun partition(head: ListNode?, x: Int): ListNode? {
    val leftDummy = ListNode(0)
    val rightDummy = ListNode(0)
    var left = leftDummy
    var right = rightDummy
    var current = head

    while (current != null) {
        if (current.`val` < x) {
            left.next = current
            left = left.next!!
        } else {
            right.next = current
            right = right.next!!
        }
        current = current.next
    }

    // Connect left list to right list
    left.next = rightDummy.next
    // Set the end of right list to null
    right.next = null

    return leftDummy.next
}
```

```java [Java]
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode leftDummy = new ListNode(0);
        ListNode rightDummy = new ListNode(0);
        ListNode left = leftDummy;
        ListNode right = rightDummy;
        ListNode current = head;

        while (current != null) {
            if (current.val < x) {
                left.next = current;
                left = left.next;
            } else {
                right.next = current;
                right = right.next;
            }
            current = current.next;
        }

        // Connect left list to right list
        left.next = rightDummy.next;
        // Set the end of right list to null
        right.next = null;

        return leftDummy.next;
    }
}
```

```swift [Swift]
// Definition for singly-linked list.
public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init() { self.val = 0; self.next = nil }
    public init(_ val: Int) { self.val = val; self.next = nil }
    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next }
}

class Solution {
    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {
        let leftDummy = ListNode(0)
        let rightDummy = ListNode(0)
        var left = leftDummy
        var right = rightDummy
        var current = head
        while let node = current {
            if node.val < x {
                left.next = node
                left = left.next!
            } else {
                right.next = node
                right = right.next!
            }
            current = node.next
        }
        left.next = rightDummy.next
        right.next = nil
        return leftDummy.next
    }
}
```

```python [Python]
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        left_dummy = ListNode(0)
        right_dummy = ListNode(0)
        left = left_dummy
        right = right_dummy
        current = head

        while current:
            if current.val < x:
                left.next = current
                left = left.next
            else:
                right.next = current
                right = right.next
            current = current.next

        # Connect left list to right list
        left.next = right_dummy.next
        # Set the end of right list to None
        right.next = None

        return left_dummy.next
```

:::
## Complexity Analysis

- **Time Complexity:** O(n), where n is the number of nodes in the linked list. We traverse the list once.
- **Space Complexity:** O(1), we only use a constant amount of extra space for the dummy nodes and pointers.