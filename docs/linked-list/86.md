# [86. Partition List](https://leetcode.com/problems/partition-list/description/?envType=study-plan-v2&envId=top-interview-150)

Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes **less than**  <code>x</code> come before nodes **greater than or equal**  to <code>x</code>.

You should **preserve**  the original relative order of the nodes in each of the two partitions.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" style="width: 662px; height: 222px;">

```
Input: head = [1,4,3,2,5,2], x = 3
Output: [1,2,2,4,3,5]
```

**Example 2:** 

```
Input: head = [2,1], x = 2
Output: [1,2]
```

**Constraints:** 

- The number of nodes in the list is in the range <code>[0, 200]</code>.
- <code>-100 <= Node.val <= 100</code>
- <code>-200 <= x <= 200</code>

## Approach

The key insight is to maintain **two separate linked lists**:
1. **Left list**: nodes with values less than `x`
2. **Right list**: nodes with values greater than or equal to `x`

**Algorithm:**
1. Create two dummy heads for the left and right lists
2. Traverse the original list and partition nodes into left and right lists
3. Connect the left list to the right list
4. Set the end of the right list to null to avoid cycles
5. Return the head of the left list

This approach preserves the original relative order within each partition.

## Kotlin Implementation

```kotlin
class ListNode(var `val`: Int) {
    var next: ListNode? = null
}

fun partition(head: ListNode?, x: Int): ListNode? {
    val leftDummy = ListNode(0)
    val rightDummy = ListNode(0)
    var left = leftDummy
    var right = rightDummy
    var current = head

    while (current != null) {
        if (current.`val` < x) {
            left.next = current
            left = left.next!!
        } else {
            right.next = current
            right = right.next!!
        }
        current = current.next
    }

    // Connect left list to right list
    left.next = rightDummy.next
    // Set the end of right list to null
    right.next = null

    return leftDummy.next
}
```

## Complexity Analysis

- **Time Complexity:** O(n), where n is the number of nodes in the linked list. We traverse the list once.
- **Space Complexity:** O(1), we only use a constant amount of extra space for the dummy nodes and pointers.