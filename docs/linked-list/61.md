# [61. Rotate List](https://leetcode.com/problems/rotate-list/description/?envType=study-plan-v2&envId=top-interview-150)

Given the <code>head</code> of a linkedlist, rotate the list to the right by <code>k</code> places.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" style="width: 450px; height: 191px;">

```
Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" style="width: 305px; height: 350px;">

```
Input: head = [0,1,2], k = 4
Output: [2,0,1]
```

**Constraints:** 

- The number of nodes in the list is in the range <code>[0, 500]</code>.
- <code>-100 <= Node.val <= 100</code>
- <code>0 <= k <= 2 * 10^9</code>

## Approach

1. **Handle edge cases**: If the list is empty or has only one node, return it as is.
2. **Calculate effective rotation**: Since rotating by the list length results in the same list, we only need to rotate by `k % length`.
3. **Find the new tail**: The new tail will be at position `length - k - 1` from the beginning.
4. **Perform rotation**:
   - Find the current tail and make it point to the original head
   - Set the new head to be the node after the new tail
   - Set the new tail's next to null

## Code

::: code-group

```kotlin [Kotlin]
class ListNode(var `val`: Int) {
    var next: ListNode? = null
}

fun rotateRight(head: ListNode?, k: Int): ListNode? {
    if (head == null || head.next == null) return head
    
    // Calculate the length of the list
    var length = 1
    var tail = head
    while (tail?.next != null) {
        tail = tail.next
        length++
    }
    
    // Calculate effective rotation
    val effectiveK = k % length
    if (effectiveK == 0) return head
    
    // Find the new tail (length - effectiveK - 1 steps from head)
    var newTail = head
    repeat(length - effectiveK - 1) {
        newTail = newTail?.next
    }
    
    // Perform rotation
    val newHead = newTail?.next
    newTail?.next = null
    tail?.next = head
    
    return newHead
}
```

```typescript [TypeScript]
class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.next = (next === undefined ? null : next);
    }
}

function rotateRight(head: ListNode | null, k: number): ListNode | null {
    if (!head || !head.next) return head;
    
    // Calculate the length of the list
    let length = 1;
    let tail = head;
    while (tail.next) {
        tail = tail.next;
        length++;
    }
    
    // Calculate effective rotation
    const effectiveK = k % length;
    if (effectiveK === 0) return head;
    
    // Find the new tail (length - effectiveK - 1 steps from head)
    let newTail = head;
    for (let i = 0; i < length - effectiveK - 1; i++) {
        newTail = newTail!.next;
    }
    
    // Perform rotation
    const newHead = newTail!.next;
    newTail!.next = null;
    tail.next = head;
    
    return newHead;
}
```

```java [Java]
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null) return head;
        
        // Calculate the length of the list
        int length = 1;
        ListNode tail = head;
        while (tail.next != null) {
            tail = tail.next;
            length++;
        }
        
        // Calculate effective rotation
        int effectiveK = k % length;
        if (effectiveK == 0) return head;
        
        // Find the new tail (length - effectiveK - 1 steps from head)
        ListNode newTail = head;
        for (int i = 0; i < length - effectiveK - 1; i++) {
            newTail = newTail.next;
        }
        
        // Perform rotation
        ListNode newHead = newTail.next;
        newTail.next = null;
        tail.next = head;
        
        return newHead;
    }
}
```

```python [Python]
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # Calculate the length of the list
        length = 1
        tail = head
        while tail.next:
            tail = tail.next
            length += 1
        
        # Calculate effective rotation
        effective_k = k % length
        if effective_k == 0:
            return head
        
        # Find the new tail (length - effective_k - 1 steps from head)
        new_tail = head
        for _ in range(length - effective_k - 1):
            new_tail = new_tail.next
        
        # Perform rotation
        new_head = new_tail.next
        new_tail.next = None
        tail.next = head
        
        return new_head
```

:::

## Complexity Analysis

- **Time Complexity:** O(n), where n is the length of the linked list. We traverse the list twice: once to find the length and once to find the new tail.
- **Space Complexity:** O(1), we only use a constant amount of extra space.
