# [61. Rotate List](https://leetcode.com/problems/rotate-list/description/?envType=study-plan-v2&envId=top-interview-150)

Given the <code>head</code> of a linkedlist, rotate the list to the right by <code>k</code> places.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" style="width: 450px; height: 191px;">

```
Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" style="width: 305px; height: 350px;">

```
Input: head = [0,1,2], k = 4
Output: [2,0,1]
```

**Constraints:** 

- The number of nodes in the list is in the range <code>[0, 500]</code>.
- <code>-100 <= Node.val <= 100</code>
- <code>0 <= k <= 2 * 10^9</code>

## Approach

1. **Handle edge cases**: If the list is empty or has only one node, return it as is.
2. **Calculate effective rotation**: Since rotating by the list length results in the same list, we only need to rotate by `k % length`.
3. **Find the new tail**: The new tail will be at position `length - k - 1` from the beginning.
4. **Perform rotation**:
   - Find the current tail and make it point to the original head
   - Set the new head to be the node after the new tail
   - Set the new tail's next to null

## Kotlin Implementation

```kotlin
class ListNode(var `val`: Int) {
    var next: ListNode? = null
}

fun rotateRight(head: ListNode?, k: Int): ListNode? {
    if (head == null || head.next == null) return head
    
    // Calculate the length of the list
    var length = 1
    var tail = head
    while (tail?.next != null) {
        tail = tail.next
        length++
    }
    
    // Calculate effective rotation
    val effectiveK = k % length
    if (effectiveK == 0) return head
    
    // Find the new tail (length - effectiveK - 1 steps from head)
    var newTail = head
    repeat(length - effectiveK - 1) {
        newTail = newTail?.next
    }
    
    // Perform rotation
    val newHead = newTail?.next
    newTail?.next = null
    tail?.next = head
    
    return newHead
}
```

## Complexity Analysis

- **Time Complexity:** O(n), where n is the length of the linked list. We traverse the list twice: once to find the length and once to find the new tail.
- **Space Complexity:** O(1), we only use a constant amount of extra space.
