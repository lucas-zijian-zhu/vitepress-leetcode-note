# [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-interview-150)

Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the<code>next</code>pointer. Internally, <code>pos</code>is used to denote the index of the node thattail's<code>next</code>pointer is connected to.**Note that<code>pos</code>is not passed as a parameter** .

Return<code>true</code> if there is a cycle in the linked list. Otherwise, return <code>false</code>.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" style="width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;">

```
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" style="width: 141px; height: 74px;">

```
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
```

**Example 3:** 
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" style="width: 45px; height: 45px;">

```
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
```

**Constraints:** 

- The number of the nodes in the list is in the range <code>[0, 10^4]</code>.
- <code>-10^5 <= Node.val <= 10^5</code>
- <code>pos</code> is <code>-1</code> or a **valid index**  in the linked-list.

**Follow up:**  Can you solve it using <code>O(1)</code> (i.e. constant) memory?

## Approach 1: Two Pointers (Floyd's Cycle Detection) ðŸŒŸ

**Best Solution - O(1) Space**

Use the **fast and slow pointer** technique (also known as **Floyd's Cycle Detection** or **Tortoise and Hare**):

1. Initialize two pointers: `slow` and `fast`, both starting at the head.
2. Move `slow` one step at a time and `fast` two steps at a time.
3. If there's a cycle, `fast` will eventually catch up to `slow` (they will meet).
4. If `fast` reaches `null`, there's no cycle.

**Why this works:** 
- If there's a cycle, the fast pointer will enter the cycle first and start "lapping" the slow pointer.
- Since fast moves twice as fast, the distance between them decreases by 1 in each iteration.
- Eventually, they must meet inside the cycle.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun hasCycle(head: ListNode?): Boolean {
        var slow = head
        var fast = head
        
        while (fast?.next != null) {
            slow = slow?.next        // Move 1 step
            fast = fast.next?.next   // Move 2 steps
            
            if (slow == fast) {
                return true          // Pointers met - cycle detected
            }
        }
        
        return false                 // Fast reached end - no cycle
    }
}
```

```typescript [TypeScript]
function hasCycle(head: ListNode | null): boolean {
    let slow = head;
    let fast = head;
    
    while (fast !== null && fast.next !== null) {
        slow = slow.next;            // Move 1 step
        fast = fast.next.next;       // Move 2 steps
        
        if (slow === fast) {
            return true;             // Pointers met - cycle detected
        }
    }
    
    return false;                    // Fast reached end - no cycle
}
```

```java [Java]
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;        // Move 1 step
            fast = fast.next.next;   // Move 2 steps
            
            if (slow == fast) {
                return true;         // Pointers met - cycle detected
            }
        }
        
        return false;                // Fast reached end - no cycle
    }
}
```

```python [Python]
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = head
        fast = head
        
        while fast and fast.next:
            slow = slow.next         # Move 1 step
            fast = fast.next.next    # Move 2 steps
            
            if slow == fast:
                return True          # Pointers met - cycle detected
        
        return False                 # Fast reached end - no cycle
```

:::

## Complexity

- **Time Complexity:** O(n) â†’ In the worst case, we visit each node once
- **Space Complexity:** O(1) â†’ Only two pointers used

---

## Approach 2: HashSet

1. Traverse the linked list and store each node in a HashSet.  
2. If a node is already in the HashSet â†’ the list has a cycle.  
3. If traversal finishes without repeats â†’ no cycle.

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun hasCycle(head: ListNode?): Boolean {
        val seen = HashSet<ListNode>()
        var node = head
        while (node != null) {
            if (!seen.add(node)) {
                return true
            }
            node = node.next
        }
        return false
    }
}
```

```typescript [TypeScript]
class Solution {
    hasCycle(head: ListNode | null): boolean {
        const seen = new Set<ListNode>();
        let node = head;
        while (node !== null) {
            if (seen.has(node)) {
                return true;
            }
            seen.add(node);
            node = node.next;
        }
        return false;
    }
}
```

```java [Java]
class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<>();
        ListNode node = head;
        while (node != null) {
            if (!seen.add(node)) {
                return true;
            }
            node = node.next;
        }
        return false;
    }
}
```

```python [Python]
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        seen = set()
        node = head
        while node:
            if node in seen:
                return True
            seen.add(node)
            node = node.next
        return False
```

:::

## Complexity

- **Time Complexity:** O(n) â†’ Traverse each node at most once  
- **Space Complexity:** O(n) â†’ Store up to n nodes in the HashSet