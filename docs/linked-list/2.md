# [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-interview-150)

You are given two **non-empty**  linked lists representing two non-negative integers. The digits are stored in **reverse order** , and each of their nodes contains a single digit. Add the two numbers and return the sumas a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" style="width: 483px; height: 342px;">

```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
```

**Example 2:** 

```
Input: l1 = [0], l2 = [0]
Output: [0]
```

**Example 3:** 

```
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
```

**Constraints:** 

- The number of nodes in each linked list is in the range <code>[1, 100]</code>.
- <code>0 <= Node.val <= 9</code>
- It is guaranteed that the list represents a number that does not have leading zeros.

## Approach

1. Create a dummy head node to simplify list operations.  
2. Use pointers `p` and `q` to traverse the two linked lists, and maintain a `carry` variable for overflow.  
3. At each step:
   - Sum the corresponding nodes and the `carry`.
   - Update the current node value as `sum % 10`.
   - Update `carry = sum / 10`.
4. Move the pointers forward.  
5. After traversal, if `carry > 0`, append a new node with `carry`.  

## Kotlin Implementation

```kotlin
class ListNode(var `val`: Int) {
    var next: ListNode? = null
}

fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {
    val dummyHead = ListNode(0)
    var p = l1
    var q = l2
    var current = dummyHead
    var carry = 0

    while (p != null || q != null) {
        val x = p?.`val` ?: 0
        val y = q?.`val` ?: 0
        val sum = carry + x + y
        carry = sum / 10
        current.next = ListNode(sum % 10)
        current = current.next!!

        p = p?.next
        q = q?.next
    }

    if (carry > 0) {
        current.next = ListNode(carry)
    }

    return dummyHead.next
}
```


## Complexity Analysis

- **Time Complexity:** O(max(m, n)) — traverse both linked lists once.
- **Space Complexity:** O(max(m, n)) — new linked list for the result.
