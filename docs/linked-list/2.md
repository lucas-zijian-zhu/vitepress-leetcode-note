# [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-interview-150)

You are given two **non-empty**  linked lists representing two non-negative integers. The digits are stored in **reverse order** , and each of their nodes contains a single digit. Add the two numbers and return the sumas a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" style="width: 483px; height: 342px;">

```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
```

**Example 2:** 

```
Input: l1 = [0], l2 = [0]
Output: [0]
```

**Example 3:** 

```
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
```

**Constraints:** 

- The number of nodes in each linked list is in the range <code>[1, 100]</code>.
- <code>0 <= Node.val <= 9</code>
- It is guaranteed that the list represents a number that does not have leading zeros.

## Approach

1. Create a dummy head node to simplify list operations.  
2. Use pointers `p` and `q` to traverse the two linked lists, and maintain a `carry` variable for overflow.  
3. At each step:
   - Sum the corresponding nodes and the `carry`.
   - Update the current node value as `sum % 10`.
   - Update `carry = sum / 10`.
4. Move the pointers forward.  
5. After traversal, if `carry > 0`, append a new node with `carry`.  

## Code

::: code-group

```kotlin [Kotlin]
class ListNode(var `val`: Int) {
    var next: ListNode? = null
}

fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {
    val dummyHead = ListNode(0)
    var p = l1
    var q = l2
    var current = dummyHead
    var carry = 0

    while (p != null || q != null) {
        val x = p?.`val` ?: 0
        val y = q?.`val` ?: 0
        val sum = carry + x + y
        carry = sum / 10
        current.next = ListNode(sum % 10)
        current = current.next!!

        p = p?.next
        q = q?.next
    }

    if (carry > 0) {
        current.next = ListNode(carry)
    }

    return dummyHead.next
}
```

```typescript [TypeScript]
class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.next = (next === undefined ? null : next);
    }
}

function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    const dummyHead = new ListNode(0);
    let p = l1;
    let q = l2;
    let current = dummyHead;
    let carry = 0;

    while (p !== null || q !== null) {
        const x = p?.val ?? 0;
        const y = q?.val ?? 0;
        const sum = carry + x + y;
        carry = Math.floor(sum / 10);
        current.next = new ListNode(sum % 10);
        current = current.next!;

        p = p?.next ?? null;
        q = q?.next ?? null;
    }

    if (carry > 0) {
        current.next = new ListNode(carry);
    }

    return dummyHead.next;
}
```

```java [Java]
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode p = l1, q = l2, current = dummyHead;
        int carry = 0;

        while (p != null || q != null) {
            int x = (p != null) ? p.val : 0;
            int y = (q != null) ? q.val : 0;
            int sum = carry + x + y;
            carry = sum / 10;
            current.next = new ListNode(sum % 10);
            current = current.next;

            if (p != null) p = p.next;
            if (q != null) q = q.next;
        }

        if (carry > 0) {
            current.next = new ListNode(carry);
        }

        return dummyHead.next;
    }
}
```

```python [Python]
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy_head = ListNode(0)
        p, q, current = l1, l2, dummy_head
        carry = 0

        while p or q:
            x = p.val if p else 0
            y = q.val if q else 0
            sum_val = carry + x + y
            carry = sum_val // 10
            current.next = ListNode(sum_val % 10)
            current = current.next

            p = p.next if p else None
            q = q.next if q else None

        if carry > 0:
            current.next = ListNode(carry)

        return dummy_head.next
```

:::

## Complexity Analysis

- **Time Complexity:** O(max(m, n)) — traverse both linked lists once.
- **Space Complexity:** O(max(m, n)) — new linked list for the result.
