# [148. Sort List](https://leetcode.com/problems/sort-list/description/?envType=study-plan-v2&envId=top-interview-150)

Given the <code>head</code> of a linked list, return the list after sorting it in **ascending order** .

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" style="width: 450px; height: 194px;">

```
Input: head = [4,2,1,3]
Output: [1,2,3,4]
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" style="width: 550px; height: 184px;">

```
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
```

**Example 3:** 

```
Input: head = []
Output: []
```

**Constraints:** 

- The number of nodes in the list is in the range <code>[0, 5 * 10^4]</code>.
- <code>-10^5 <= Node.val <= 10^5</code>

**Follow up:**  Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?

## ðŸ’¡ Approach: Merge Sort (Bottom-up)

### Intuition

This is a classic **merge sort** problem for linked lists. Since we need O(n log n) time and O(1) space, we use **bottom-up merge sort** instead of top-down recursion to avoid the O(log n) recursion stack space.

**Key Steps:**
1. **Split** the list into sublists of increasing sizes (1, 2, 4, 8, ...)
2. **Merge** adjacent sublists in pairs
3. **Repeat** until the entire list is sorted

### Algorithm

1. **Start with sublists of size 1** (each node is already sorted)
2. **Double the size** in each iteration
3. **Merge pairs** of sorted sublists of current size
4. **Continue** until size >= total length

### Key Points

- Use bottom-up approach to avoid recursion stack
- Merge two sorted linked lists efficiently
- Handle odd lengths and edge cases
- Track the end of merged portion to continue processing

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun sortList(head: ListNode?): ListNode? {
        if (head?.next == null) return head
        
        // Count total length
        var length = 0
        var node = head
        while (node != null) {
            length++
            node = node.next
        }
        
        val dummy = ListNode(0).apply { next = head }
        
        var size = 1
        while (size < length) {
            var prev = dummy
            var current = dummy.next
            
            while (current != null) {
                val left = current
                val right = split(left, size)
                current = split(right, size)
                prev.next = merge(left, right)
                
                // Move prev to the end of merged portion
                while (prev.next != null) {
                    prev = prev.next!!
                }
            }
            
            size *= 2
        }
        
        return dummy.next
    }
    
    private fun split(head: ListNode?, n: Int): ListNode? {
        if (head == null) return null
        
        var count = 1
        var current = head
        while (count < n && current?.next != null) {
            current = current.next
            count++
        }
        
        val next = current?.next
        current?.next = null
        return next
    }
    
    private fun merge(left: ListNode?, right: ListNode?): ListNode? {
        val dummy = ListNode(0)
        var tail = dummy
        
        var l = left
        var r = right
        
        while (l != null && r != null) {
            if (l.`val` <= r.`val`) {
                tail.next = l
                l = l.next
            } else {
                tail.next = r
                r = r.next
            }
            tail = tail.next!!
        }
        
        tail.next = l ?: r
        return dummy.next
    }
}
```

```typescript [TypeScript]
function sortList(head: ListNode | null): ListNode | null {
    if (!head || !head.next) return head;
    
    // Count total length
    let length = 0;
    let node = head;
    while (node) {
        length++;
        node = node.next;
    }
    
    const dummy = new ListNode(0);
    dummy.next = head;
    
    let size = 1;
    while (size < length) {
        let prev = dummy;
        let current = dummy.next;
        
        while (current) {
            const left = current;
            const right = split(left, size);
            current = split(right, size);
            prev.next = merge(left, right);
            
            // Move prev to the end of merged portion
            while (prev.next) {
                prev = prev.next;
            }
        }
        
        size *= 2;
    }
    
    return dummy.next;
}

function split(head: ListNode | null, n: number): ListNode | null {
    if (!head) return null;
    
    let count = 1;
    let current = head;
    while (count < n && current.next) {
        current = current.next;
        count++;
    }
    
    const next = current.next;
    current.next = null;
    return next;
}

function merge(left: ListNode | null, right: ListNode | null): ListNode | null {
    const dummy = new ListNode(0);
    let tail = dummy;
    
    let l = left;
    let r = right;
    
    while (l && r) {
        if (l.val <= r.val) {
            tail.next = l;
            l = l.next;
        } else {
            tail.next = r;
            r = r.next;
        }
        tail = tail.next!;
    }
    
    tail.next = l || r;
    return dummy.next;
}
```

```java [Java]
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        
        // Count total length
        int length = 0;
        ListNode node = head;
        while (node != null) {
            length++;
            node = node.next;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        for (int size = 1; size < length; size *= 2) {
            ListNode prev = dummy;
            ListNode current = dummy.next;
            
            while (current != null) {
                ListNode left = current;
                ListNode right = split(left, size);
                current = split(right, size);
                prev.next = merge(left, right);
                
                // Move prev to the end of merged portion
                while (prev.next != null) {
                    prev = prev.next;
                }
            }
        }
        
        return dummy.next;
    }
    
    private ListNode split(ListNode head, int n) {
        if (head == null) return null;
        
        int count = 1;
        ListNode current = head;
        while (count < n && current.next != null) {
            current = current.next;
            count++;
        }
        
        ListNode next = current.next;
        current.next = null;
        return next;
    }
    
    private ListNode merge(ListNode left, ListNode right) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        
        while (left != null && right != null) {
            if (left.val <= right.val) {
                tail.next = left;
                left = left.next;
            } else {
                tail.next = right;
                right = right.next;
            }
            tail = tail.next;
        }
        
        tail.next = (left != null) ? left : right;
        return dummy.next;
    }
}
```

```python [Python]
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # Count total length
        length = 0
        node = head
        while node:
            length += 1
            node = node.next
        
        dummy = ListNode(0)
        dummy.next = head
        
        size = 1
        while size < length:
            prev = dummy
            current = dummy.next
            
            while current:
                left = current
                right = self._split(left, size)
                current = self._split(right, size)
                prev.next = self._merge(left, right)
                
                # Move prev to the end of merged portion
                while prev.next:
                    prev = prev.next
            
            size *= 2
        
        return dummy.next
    
    def _split(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        if not head:
            return None
        
        count = 1
        current = head
        while count < n and current.next:
            current = current.next
            count += 1
        
        next_head = current.next
        current.next = None
        return next_head
    
    def _merge(self, left: Optional[ListNode], right: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        tail = dummy
        
        while left and right:
            if left.val <= right.val:
                tail.next = left
                left = left.next
            else:
                tail.next = right
                right = right.next
            tail = tail.next
        
        tail.next = left or right
        return dummy.next
```

:::

## Complexity

- **Time Complexity:** O(n log n) - Merge sort divides the list in half each iteration and merges in linear time
- **Space Complexity:** O(1) - We use bottom-up approach to avoid recursion stack, only using constant extra space