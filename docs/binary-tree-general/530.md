# [530. Minimum Absolute Difference in BST](https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Easy" />

Given the <code>root</code> of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" style="width: 292px; height: 301px;">

```
Input: root = [4,2,6,1,3]
Output: 1
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" style="width: 282px; height: 301px;">

```
Input: root = [1,0,48,null,null,12,49]
Output: 1
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[2, 10^4]</code>.
- <code>0 <= Node.val <= 10^5</code>

**Note:**  This question is the same as 783: <a href="https://leetcode.com/problems/minimum-distance-between-bst-nodes/" target="_blank">https://leetcode.com/problems/minimum-distance-between-bst-nodes/</a>

## ðŸ’¡ Approach: Inorder Traversal

### Intuition

Since this is a **Binary Search Tree (BST)**, an inorder traversal will give us the nodes in sorted order. The minimum absolute difference will be between two consecutive nodes in the sorted order.

### Algorithm

1. **Perform inorder traversal** to get nodes in sorted order
2. **Keep track of the previous node** during traversal
3. **Calculate the difference** between current and previous node
4. **Update minimum difference** if current difference is smaller
5. **Return the minimum difference**

### Key Points

- Use inorder traversal for BST to get sorted order
- Track previous node during traversal
- Compare consecutive nodes only
- Handle single node case

## Code

::: code-group

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

class Solution {
    private var minDiff = Int.MAX_VALUE
    private var prev: TreeNode? = null
    
    fun getMinimumDifference(root: TreeNode?): Int {
        inorder(root)
        return minDiff
    }
    
    private fun inorder(node: TreeNode?) {
        if (node == null) return
        
        inorder(node.left)
        
        prev?.let {
            minDiff = minOf(minDiff, node.`val` - it.`val`)
        }
        prev = node
        
        inorder(node.right)
    }
}
```

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

class Solution {
    private minDiff: number = Number.MAX_SAFE_INTEGER;
    private prev: TreeNode | null = null;
    
    getMinimumDifference(root: TreeNode | null): number {
        this.inorder(root);
        return this.minDiff;
    }
    
    private inorder(node: TreeNode | null): void {
        if (node === null) return;
        
        this.inorder(node.left);
        
        if (this.prev !== null) {
            this.minDiff = Math.min(this.minDiff, node.val - this.prev.val);
        }
        this.prev = node;
        
        this.inorder(node.right);
    }
}
```

```java [Java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private int minDiff = Integer.MAX_VALUE;
    private TreeNode prev = null;
    
    public int getMinimumDifference(TreeNode root) {
        inorder(root);
        return minDiff;
    }
    
    private void inorder(TreeNode node) {
        if (node == null) return;
        
        inorder(node.left);
        
        if (prev != null) {
            minDiff = Math.min(minDiff, node.val - prev.val);
        }
        prev = node;
        
        inorder(node.right);
    }
}
```

```swift [Swift]
// Definition for a binary tree node.
public class TreeNode {
    public var val: Int
    public var left: TreeNode?
    public var right: TreeNode?
    public init() { self.val = 0; self.left = nil; self.right = nil }
    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }
    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
        self.val = val
        self.left = left
        self.right = right
    }
}

class Solution {
    func getMinimumDifference(_ root: TreeNode?) -> Int {
        var previous: Int?
        var answer = Int.max

        func inorder(_ node: TreeNode?) {
            guard let node = node else { return }
            inorder(node.left)
            if let prev = previous {
                answer = min(answer, node.val - prev)
            }
            previous = node.val
            inorder(node.right)
        }

        inorder(root)
        return answer
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        self.min_diff = float('inf')
        self.prev = None
        
        def inorder(node):
            if not node:
                return
            
            inorder(node.left)
            
            if self.prev is not None:
                self.min_diff = min(self.min_diff, node.val - self.prev.val)
            self.prev = node
            
            inorder(node.right)
        
        inorder(root)
        return self.min_diff
```

:::

## Complexity

- **Time Complexity:** O(n), where n is the number of nodes. We visit each node exactly once.
- **Space Complexity:** O(h), where h is the height of the tree (recursion stack space).