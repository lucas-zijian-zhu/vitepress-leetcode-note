# [117. Populating Next Right Pointers in Each Node II](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

Given a binary tree

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.

Initially, all next pointers are set to <code>NULL</code>.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" style="width: 500px; height: 171px;">

```
Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

**Example 2:** 

```
Input: root = []
Output: []
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[0, 6000]</code>.
- <code>-100 <= Node.val <= 100</code>

**Follow-up:** 

- You may only use constant extra space.
- The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.

## ðŸ’¡ Approach: Level-by-Level with Previous Node

### Intuition

This is similar to LeetCode 116, but the tree is not necessarily complete. We need to connect each node to its next right node at the same level. The key insight is to use the already established next pointers to traverse the current level while building the next level.

### Algorithm

1. **Use a dummy head** to simplify the logic for the first node in each level
2. **Traverse level by level**:
   - Start from the root
   - For each level, use a `prev` pointer to track the previous node
   - Connect each node to the next node in the same level
3. **Handle missing children**: Skip null children and only process actual nodes
4. **Move to next level**: Use the next pointers to move to the next level

### Key Points

- Use `dummy.next` to get the first node of the next level
- Use `prev` to track the previous node for connecting
- Reset `dummy.next` and `prev` for each new level

## Code

::: code-group

```kotlin [Kotlin]
class Node(var `val`: Int) {
    var left: Node? = null
    var right: Node? = null
    var next: Node? = null
}

class Solution {
    fun connect(root: Node?): Node? {
        if (root == null) return null
        
        var current = root
        
        while (current != null) {
            val dummy = Node(0) // Dummy head for the next level
            var prev = dummy
            
            // Process current level
            while (current != null) {
                if (current.left != null) {
                    prev.next = current.left
                    prev = prev.next!!
                }
                if (current.right != null) {
                    prev.next = current.right
                    prev = prev.next!!
                }
                current = current.next
            }
            
            // Move to next level
            current = dummy.next
        }
        
        return root
    }
}
```

```typescript [TypeScript]
class Node {
    val: number;
    left: Node | null;
    right: Node | null;
    next: Node | null;
    constructor(val?: number, left?: Node | null, right?: Node | null, next?: Node | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
        this.next = (next === undefined ? null : next);
    }
}

class Solution {
    connect(root: Node | null): Node | null {
        if (root === null) return null;
        
        let current: Node | null = root;
        
        while (current !== null) {
            const dummy = new Node(0); // Dummy head for the next level
            let prev: Node | null = dummy;
            
            // Process current level
            while (current !== null) {
                if (current.left !== null) {
                    prev.next = current.left;
                    prev = prev.next!;
                }
                if (current.right !== null) {
                    prev.next = current.right;
                    prev = prev.next!;
                }
                current = current.next;
            }
            
            // Move to next level
            current = dummy.next;
        }
        
        return root;
    }
}
```

```java [Java]
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
}

class Solution {
    public Node connect(Node root) {
        if (root == null) return null;
        
        Node current = root;
        
        while (current != null) {
            Node dummy = new Node(0); // Dummy head for the next level
            Node prev = dummy;
            
            // Process current level
            while (current != null) {
                if (current.left != null) {
                    prev.next = current.left;
                    prev = prev.next;
                }
                if (current.right != null) {
                    prev.next = current.right;
                    prev = prev.next;
                }
                current = current.next;
            }
            
            // Move to next level
            current = dummy.next;
        }
        
        return root;
    }
}
```

```swift [Swift]
// Definition for a Node.
public class Node {
    public var val: Int
    public var left: Node?
    public var right: Node?
    public var next: Node?
    public init(_ val: Int) {
        self.val = val
        self.left = nil
        self.right = nil
        self.next = nil
    }
}

class Solution {
    func connect(_ root: Node?) -> Node? {
        guard let root = root else { return nil }
        var queue: [Node] = [root]

        while !queue.isEmpty {
            var previous: Node?
            for _ in 0..<queue.count {
                let node = queue.removeFirst()
                if let prev = previous {
                    prev.next = node
                }
                previous = node
                if let left = node.left {
                    queue.append(left)
                }
                if let right = node.right {
                    queue.append(right)
                }
            }
            previous?.next = nil
        }

        return root
    }
}
```

```python [Python]
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if root is None:
            return None
        
        current = root
        
        while current is not None:
            dummy = Node(0)  # Dummy head for the next level
            prev = dummy
            
            # Process current level
            while current is not None:
                if current.left is not None:
                    prev.next = current.left
                    prev = prev.next
                if current.right is not None:
                    prev.next = current.right
                    prev = prev.next
                current = current.next
            
            # Move to next level
            current = dummy.next
        
        return root
```

:::

## Complexity

- **Time Complexity:** O(n), where n is the number of nodes. We visit each node exactly once.
- **Space Complexity:** O(1), using only constant extra space (the dummy node and prev pointer).
