# [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return the binary tree.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" style="width: 277px; height: 302px;">

```
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
```

**Example 2:** 

```
Input: inorder = [-1], postorder = [-1]
Output: [-1]
```

**Constraints:** 

- <code>1 <= inorder.length <= 3000</code>
- <code>postorder.length == inorder.length</code>
- <code>-3000 <= inorder[i], postorder[i] <= 3000</code>
- <code>inorder</code> and <code>postorder</code> consist of **unique**  values.
- Each value of <code>postorder</code> also appears in <code>inorder</code>.
- <code>inorder</code> is **guaranteed**  to be the inorder traversal of the tree.
- <code>postorder</code> is **guaranteed**  to be the postorder traversal of the tree.

## ðŸ’¡ Approach: Recursive with Hash Map

### Intuition

The key insight is that:
1. **Inorder traversal**: Left â†’ Root â†’ Right (root divides left and right subtrees)
2. **Postorder traversal**: Left â†’ Right â†’ Root (last element is always the root)

We can use this property to recursively build the tree:
1. The last element in postorder is the root
2. Find the root's position in inorder to determine left and right subtrees
3. Recursively build right and left subtrees (note the order!)

### Algorithm

1. **Create a hash map** to store the index of each value in inorder array for O(1) lookup
2. **Define recursive function** `buildTree(inStart, inEnd, postStart, postEnd)`:
   - `inStart`, `inEnd`: current subtree range in inorder
   - `postStart`, `postEnd`: current subtree range in postorder
3. **Base case**: If `inStart > inEnd` or `postStart > postEnd`, return null
4. **Create root** from `postorder[postEnd]` (last element)
5. **Find root position** in inorder using hash map
6. **Calculate subtree sizes**:
   - Left subtree size = `rootIndex - inStart`
   - Right subtree size = `inEnd - rootIndex`
7. **Recursively build**:
   - Right subtree: `buildTree(rootIndex + 1, inEnd, postStart + leftSize, postEnd - 1)`
   - Left subtree: `buildTree(inStart, rootIndex - 1, postStart, postStart + leftSize - 1)`

## Code

::: code-group

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

class Solution {
    private lateinit var inorder: IntArray
    private lateinit var postorder: IntArray
    private lateinit var inorderMap: MutableMap<Int, Int>

    fun buildTree(inorder: IntArray, postorder: IntArray): TreeNode? {
        this.inorder = inorder
        this.postorder = postorder
        this.inorderMap = mutableMapOf()
        
        // Build hash map for O(1) lookup
        for (i in inorder.indices) {
            inorderMap[inorder[i]] = i
        }
        
        return buildTree(0, inorder.size - 1, 0, postorder.size - 1)
    }
    
    private fun buildTree(inStart: Int, inEnd: Int, postStart: Int, postEnd: Int): TreeNode? {
        if (inStart > inEnd || postStart > postEnd) return null
        
        // Create root from postorder (last element)
        val rootValue = postorder[postEnd]
        val root = TreeNode(rootValue)
        
        // Find root position in inorder
        val rootIndex = inorderMap[rootValue]!!
        
        // Calculate left subtree size
        val leftSize = rootIndex - inStart
        
        // Build right and left subtrees
        root.right = buildTree(rootIndex + 1, inEnd, postStart + leftSize, postEnd - 1)
        root.left = buildTree(inStart, rootIndex - 1, postStart, postStart + leftSize - 1)
        
        return root
    }
}
```

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

class Solution {
    private inorder: number[];
    private postorder: number[];
    private inorderMap: Map<number, number>;

    constructor() {
        this.inorder = [];
        this.postorder = [];
        this.inorderMap = new Map();
    }

    buildTree(inorder: number[], postorder: number[]): TreeNode | null {
        this.inorder = inorder;
        this.postorder = postorder;
        this.inorderMap = new Map();
        
        // Build hash map for O(1) lookup
        for (let i = 0; i < inorder.length; i++) {
            this.inorderMap.set(inorder[i], i);
        }
        
        return this.buildTreeRecursive(0, inorder.length - 1, 0, postorder.length - 1);
    }
    
    private buildTreeRecursive(inStart: number, inEnd: number, postStart: number, postEnd: number): TreeNode | null {
        if (inStart > inEnd || postStart > postEnd) return null;
        
        // Create root from postorder (last element)
        const rootValue = this.postorder[postEnd];
        const root = new TreeNode(rootValue);
        
        // Find root position in inorder
        const rootIndex = this.inorderMap.get(rootValue)!;
        
        // Calculate left subtree size
        const leftSize = rootIndex - inStart;
        
        // Build right and left subtrees
        root.right = this.buildTreeRecursive(rootIndex + 1, inEnd, postStart + leftSize, postEnd - 1);
        root.left = this.buildTreeRecursive(inStart, rootIndex - 1, postStart, postStart + leftSize - 1);
        
        return root;
    }
}
```

```java [Java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private int[] inorder;
    private int[] postorder;
    private Map<Integer, Integer> inorderMap;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.inorder = inorder;
        this.postorder = postorder;
        this.inorderMap = new HashMap<>();
        
        // Build hash map for O(1) lookup
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        
        return buildTreeRecursive(0, inorder.length - 1, 0, postorder.length - 1);
    }
    
    private TreeNode buildTreeRecursive(int inStart, int inEnd, int postStart, int postEnd) {
        if (inStart > inEnd || postStart > postEnd) return null;
        
        // Create root from postorder (last element)
        int rootValue = postorder[postEnd];
        TreeNode root = new TreeNode(rootValue);
        
        // Find root position in inorder
        int rootIndex = inorderMap.get(rootValue);
        
        // Calculate left subtree size
        int leftSize = rootIndex - inStart;
        
        // Build right and left subtrees
        root.right = buildTreeRecursive(rootIndex + 1, inEnd, postStart + leftSize, postEnd - 1);
        root.left = buildTreeRecursive(inStart, rootIndex - 1, postStart, postStart + leftSize - 1);
        
        return root;
    }
}
```

```swift [Swift]
// Definition for a binary tree node.
public class TreeNode {
    public var val: Int
    public var left: TreeNode?
    public var right: TreeNode?
    public init() { self.val = 0; self.left = nil; self.right = nil }
    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }
    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
        self.val = val
        self.left = left
        self.right = right
    }
}

class Solution {
    func buildTree(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {
        var indexMap: [Int: Int] = [:]
        for (index, value) in inorder.enumerated() {
            indexMap[value] = index
        }

        var postIndex = postorder.count - 1

        func helper(_ left: Int, _ right: Int) -> TreeNode? {
            if left > right {
                return nil
            }
            let rootVal = postorder[postIndex]
            postIndex -= 1
            let node = TreeNode(rootVal)
            if let inorderIndex = indexMap[rootVal] {
                node.right = helper(inorderIndex + 1, right)
                node.left = helper(left, inorderIndex - 1)
            }
            return node
        }

        return helper(0, inorder.count - 1)
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        self.inorder = inorder
        self.postorder = postorder
        self.inorder_map = {}
        
        # Build hash map for O(1) lookup
        for i, val in enumerate(inorder):
            self.inorder_map[val] = i
        
        return self._build_tree(0, len(inorder) - 1, 0, len(postorder) - 1)
    
    def _build_tree(self, in_start: int, in_end: int, post_start: int, post_end: int) -> Optional[TreeNode]:
        if in_start > in_end or post_start > post_end:
            return None
        
        # Create root from postorder (last element)
        root_value = self.postorder[post_end]
        root = TreeNode(root_value)
        
        # Find root position in inorder
        root_index = self.inorder_map[root_value]
        
        # Calculate left subtree size
        left_size = root_index - in_start
        
        # Build right and left subtrees
        root.right = self._build_tree(root_index + 1, in_end, post_start + left_size, post_end - 1)
        root.left = self._build_tree(in_start, root_index - 1, post_start, post_start + left_size - 1)
        
        return root
```

:::

## Complexity

- **Time Complexity:** O(n), where n is the number of nodes. We visit each node exactly once.
- **Space Complexity:** O(n), for the hash map and recursion stack. In the worst case (skewed tree), the recursion stack can be O(n).