# [101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-interview-150)

Given the <code>root</code> of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" style="width: 354px; height: 291px;">

```
Input: root = [1,2,2,3,4,4,3]
Output: true
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" style="width: 308px; height: 258px;">

```
Input: root = [1,2,2,null,3,null,3]
Output: false
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[1, 1000]</code>.
- <code>-100 <= Node.val <= 100</code>

**Follow up:**  Could you solve it both recursively and iteratively?

## ðŸ’¡ Approach: Recursive (DFS)

### Intuition

A tree is symmetric if the left subtree is a mirror reflection of the right subtree. We can solve this recursively by comparing the left and right subtrees.

### Algorithm

1. **Base case**: If both nodes are `null`, they are symmetric.
2. **Base case**: If one node is `null` and the other is not, they are not symmetric.
3. **Base case**: If the values are different, they are not symmetric.
4. **Recursive case**: Check if the left subtree of the left node is symmetric to the right subtree of the right node, and vice versa.

## Code

::: code-group

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

class Solution {
    fun isSymmetric(root: TreeNode?): Boolean {
        return isMirror(root, root)
    }
    
    private fun isMirror(t1: TreeNode?, t2: TreeNode?): Boolean {
        if (t1 == null && t2 == null) return true
        if (t1 == null || t2 == null) return false
        return (t1.`val` == t2.`val`) && 
               isMirror(t1.right, t2.left) && 
               isMirror(t1.left, t2.right)
    }
}
```

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

class Solution {
    isSymmetric(root: TreeNode | null): boolean {
        return this.isMirror(root, root);
    }
    
    private isMirror(t1: TreeNode | null, t2: TreeNode | null): boolean {
        if (t1 === null && t2 === null) return true;
        if (t1 === null || t2 === null) return false;
        return (t1.val === t2.val) && 
               this.isMirror(t1.right, t2.left) && 
               this.isMirror(t1.left, t2.right);
    }
}
```

```java [Java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public boolean isSymmetric(TreeNode root) {
        return isMirror(root, root);
    }
    
    private boolean isMirror(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) return true;
        if (t1 == null || t2 == null) return false;
        return (t1.val == t2.val) && 
               isMirror(t1.right, t2.left) && 
               isMirror(t1.left, t2.right);
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.is_mirror(root, root)
    
    def is_mirror(self, t1: Optional[TreeNode], t2: Optional[TreeNode]) -> bool:
        if t1 is None and t2 is None:
            return True
        if t1 is None or t2 is None:
            return False
        return (t1.val == t2.val) and \
               self.is_mirror(t1.right, t2.left) and \
               self.is_mirror(t1.left, t2.right)
```

:::

## Complexity

- **Time Complexity:** O(n), where n is the number of nodes in the tree. We visit each node once.
- **Space Complexity:** O(h), where h is the height of the tree. The space is used by the recursion stack.