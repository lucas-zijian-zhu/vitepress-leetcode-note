# [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Easy" />

Given the <code>root</code> of a binary tree, return its maximum depth.

A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" style="width: 400px; height: 277px;">

```
Input: root = [3,9,20,null,null,15,7]
Output: 3
```

**Example 2:** 

```
Input: root = [1,null,2]
Output: 2
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[0, 10^4]</code>.
- <code>-100 <= Node.val <= 100</code>

## ðŸ’¡ Approach: Recursive Depth-First Search (DFS)

### Intuition

The maximum depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. This problem can be naturally solved using recursion.

### Recursive Logic

- If the current node is `null`, return `0` (base case).
- Otherwise:
  - Recursively compute the maximum depth of the left subtree.
  - Recursively compute the maximum depth of the right subtree.
  - Return `1 + max(leftDepth, rightDepth)`.

## Code

::: code-group

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

fun maxDepth(root: TreeNode?): Int {
    if (root == null) return 0
    val leftDepth = maxDepth(root.left)
    val rightDepth = maxDepth(root.right)
    return 1 + maxOf(leftDepth, rightDepth)
}
```

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

function maxDepth(root: TreeNode | null): number {
    if (root === null) return 0;
    const leftDepth = maxDepth(root.left);
    const rightDepth = maxDepth(root.right);
    return 1 + Math.max(leftDepth, rightDepth);
}
```

```java [Java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        return 1 + Math.max(leftDepth, rightDepth);
    }
}
```

```swift [Swift]
// Definition for a binary tree node.
public class TreeNode {
    public var val: Int
    public var left: TreeNode?
    public var right: TreeNode?
    public init() { self.val = 0; self.left = nil; self.right = nil }
    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }
    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
        self.val = val
        self.left = left
        self.right = right
    }
}

class Solution {
    func maxDepth(_ root: TreeNode?) -> Int {
        guard let node = root else { return 0 }
        return 1 + max(maxDepth(node.left), maxDepth(node.right))
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        return 1 + max(left_depth, right_depth)
```

:::

## Complexity

**Time Complexity:** O(n) where n is the number of nodes in the tree.

**Space Complexity:** O(h), where h is the height of the tree (due to recursion stack).