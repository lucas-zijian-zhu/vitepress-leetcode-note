# [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given the <code>root</code> of a binary tree, determine if it is a valid binary search tree (BST).

A **valid BST**  is defined as follows:

- The left subtree of a node contains only nodes with keys **strictly less than** the node's key.
- The right subtree of a node contains only nodes with keys **strictly greater than** the node's key.
- Both the left and right subtrees must also be binary search trees.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" style="width: 302px; height: 182px;">

```
Input: root = [2,1,3]
Output: true
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" style="width: 422px; height: 292px;">

```
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[1, 10^4]</code>.
- <code>-2^31 <= Node.val <= 2^31 - 1</code>

## ðŸ’¡ Approach: Inorder Traversal with Previous Value

### Intuition

For a valid BST, an **inorder traversal** produces a strictly increasing sequence. We can perform inorder traversal and check if each value is greater than the previous value.

### Algorithm

1. **Perform inorder traversal** (left â†’ root â†’ right)
2. **Track the previous node's value** during traversal
3. **Check if current value > previous value**
4. **If any violation is found**, return false
5. **If traversal completes without violation**, return true

### Key Points

- Inorder traversal of BST must be strictly increasing
- Use previous value to compare with current
- Handle edge case of first node (no previous)
- Can use either recursive or iterative approach

## Code

::: code-group

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

class Solution {
    private var prev: Int? = null
    
    fun isValidBST(root: TreeNode?): Boolean {
        if (root == null) return true
        
        // Check left subtree
        if (!isValidBST(root.left)) return false
        
        // Check current node
        if (prev != null && root.`val` <= prev!!) return false
        prev = root.`val`
        
        // Check right subtree
        return isValidBST(root.right)
    }
}
```

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

class Solution {
    private prev: number | null = null;
    
    isValidBST(root: TreeNode | null): boolean {
        if (root === null) return true;
        
        // Check left subtree
        if (!this.isValidBST(root.left)) return false;
        
        // Check current node
        if (this.prev !== null && root.val <= this.prev) return false;
        this.prev = root.val;
        
        // Check right subtree
        return this.isValidBST(root.right);
    }
}
```

```java [Java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private Integer prev = null;
    
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        
        // Check left subtree
        if (!isValidBST(root.left)) return false;
        
        // Check current node
        if (prev != null && root.val <= prev) return false;
        prev = root.val;
        
        // Check right subtree
        return isValidBST(root.right);
    }
}
```

```swift [Swift]
// Definition for a binary tree node.
public class TreeNode {
    public var val: Int
    public var left: TreeNode?
    public var right: TreeNode?
    public init() { self.val = 0; self.left = nil; self.right = nil }
    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }
    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
        self.val = val
        self.left = left
        self.right = right
    }
}

class Solution {
    func isValidBST(_ root: TreeNode?) -> Bool {
        return validate(root, lower: Int.min, upper: Int.max)
    }

    private func validate(_ node: TreeNode?, lower: Int, upper: Int) -> Bool {
        guard let node = node else { return true }
        if node.val <= lower || node.val >= upper {
            return false
        }
        return validate(node.left, lower: lower, upper: node.val) &&
            validate(node.right, lower: node.val, upper: upper)
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        self.prev = None
        
        def inorder(node):
            if not node:
                return True
            
            # Check left subtree
            if not inorder(node.left):
                return False
            
            # Check current node
            if self.prev is not None and node.val <= self.prev:
                return False
            self.prev = node.val
            
            # Check right subtree
            return inorder(node.right)
        
        return inorder(root)
```

:::

## Complexity

- **Time Complexity:** O(n), where n is the number of nodes. We visit each node exactly once.
- **Space Complexity:** O(h), where h is the height of the tree (recursion stack space).