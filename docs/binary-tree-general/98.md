# [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given the <code>root</code> of a binary tree, determine if it is a valid binary search tree (BST).

A **valid BST**  is defined as follows:

- The left subtree of a node contains only nodes with keys **strictly less than** the node's key.
- The right subtree of a node contains only nodes with keys **strictly greater than** the node's key.
- Both the left and right subtrees must also be binary search trees.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" style="width: 302px; height: 182px;">

```
Input: root = [2,1,3]
Output: true
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" style="width: 422px; height: 292px;">

```
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[1, 10^4]</code>.
- <code>-2^31 <= Node.val <= 2^31 - 1</code>

## ðŸ’¡ Approach 1: Inorder Traversal with Previous Value

### Intuition

For a valid BST, an **inorder traversal** produces a strictly increasing sequence. We can perform inorder traversal and check if each value is greater than the previous value.

### Algorithm

1. **Perform inorder traversal** (left â†’ root â†’ right)
2. **Track the previous node's value** during traversal
3. **Check if current value > previous value**
4. **If any violation is found**, return false
5. **If traversal completes without violation**, return true

### Key Points

- Inorder traversal of BST must be strictly increasing
- Use previous value to compare with current
- Handle edge case of first node (no previous)
- Can use either recursive or iterative approach

---

## ðŸ’¡ Approach 2: Interval Constraint

### Intuition

A valid BST is equivalent to: every node's value must lie in some **open interval (low, high)**. The root has interval \((-\infty, +\infty)\); the left subtree uses `(low, root.val)` and the right subtree uses `(root.val, high)`. Pass the current bounds down the recursion.

### Algorithm

Define a helper **validate(node, low, high)** that returns whether the subtree at `node` has all values in the open interval (low, high). Use `null` for unbounded (no lower/upper limit).

1. Call `validate(root, null, null)` at the root.
2. Inside **validate:** if the current node is `null`, return `true`.
3. If `node.val <= low` or `node.val >= high`, return `false`.
4. Recurse left: `validate(node.left, low, node.val)`; recurse right: `validate(node.right, node.val, high)`.
5. Return `true` only if both subtrees are valid.

### Key Points

- Does not rely on inorder; just check "current value in range," which is intuitive.
- Use open intervals to avoid duplicates (problem requires strictly less / greater).
- Use `null` or Â±Infinity for unbounded; with `null` you avoid 32-bit overflow at boundaries.

## Code

### Approach 1: Inorder (Previous Value)

::: code-group

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

class Solution {
    private prev: number | null = null;
    
    isValidBST(root: TreeNode | null): boolean {
        if (root === null) return true;
        
        // Check left subtree
        if (!this.isValidBST(root.left)) return false;
        
        // Check current node
        if (this.prev !== null && root.val <= this.prev) return false;
        this.prev = root.val;
        
        // Check right subtree
        return this.isValidBST(root.right);
    }
}
```

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

class Solution {
    private var prev: Int? = null
    
    fun isValidBST(root: TreeNode?): Boolean {
        if (root == null) return true
        
        // Check left subtree
        if (!isValidBST(root.left)) return false
        
        // Check current node
        if (prev != null && root.`val` <= prev!!) return false
        prev = root.`val`
        
        // Check right subtree
        return isValidBST(root.right)
    }
}
```

```java [Java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private Integer prev = null;
    
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        
        // Check left subtree
        if (!isValidBST(root.left)) return false;
        
        // Check current node
        if (prev != null && root.val <= prev) return false;
        prev = root.val;
        
        // Check right subtree
        return isValidBST(root.right);
    }
}
```

```swift [Swift]
// Definition for a binary tree node.
public class TreeNode {
    public var val: Int
    public var left: TreeNode?
    public var right: TreeNode?
    public init() { self.val = 0; self.left = nil; self.right = nil }
    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }
    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
        self.val = val
        self.left = left
        self.right = right
    }
}

class Solution {
    private var prev: Int?

    func isValidBST(_ root: TreeNode?) -> Bool {
        prev = nil
        return inorder(root)
    }

    private func inorder(_ node: TreeNode?) -> Bool {
        guard let node = node else { return true }
        if !inorder(node.left) { return false }
        if let p = prev, node.val <= p { return false }
        prev = node.val
        return inorder(node.right)
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        self.prev = None
        
        def inorder(node):
            if not node:
                return True
            
            # Check left subtree
            if not inorder(node.left):
                return False
            
            # Check current node
            if self.prev is not None and node.val <= self.prev:
                return False
            self.prev = node.val
            
            # Check right subtree
            return inorder(node.right)
        
        return inorder(root)
```

:::

### Approach 2: Interval Constraint

::: code-group

```typescript [TypeScript]
function isValidBST(root: TreeNode | null): boolean {
    function validate(
        node: TreeNode | null,
        low: number | null,
        high: number | null
    ): boolean {
        if (!node) return true;
        if (low !== null && node.val <= low) return false;
        if (high !== null && node.val >= high) return false;
        return (
            validate(node.left, low, node.val) &&
            validate(node.right, node.val, high)
        );
    }
    return validate(root, null, null);
}
```

```kotlin [Kotlin]
class Solution {
    fun isValidBST(root: TreeNode?): Boolean = validate(root, null, null)

    private fun validate(
        node: TreeNode?,
        low: Int?,
        high: Int?
    ): Boolean {
        if (node == null) return true
        if (low != null && node.`val` <= low) return false
        if (high != null && node.`val` >= high) return false
        return validate(node.left, low, node.`val`) &&
            validate(node.right, node.`val`, high)
    }
}
```

```java [Java]
class Solution {
    public boolean isValidBST(TreeNode root) {
        return validate(root, null, null);
    }

    private boolean validate(TreeNode node, Integer low, Integer high) {
        if (node == null) return true;
        if (low != null && node.val <= low) return false;
        if (high != null && node.val >= high) return false;
        return validate(node.left, low, node.val) &&
            validate(node.right, node.val, high);
    }
}
```

```swift [Swift]
class Solution {
    func isValidBST(_ root: TreeNode?) -> Bool {
        return validate(root, lower: nil, upper: nil)
    }

    private func validate(
        _ node: TreeNode?,
        lower: Int?,
        upper: Int?
    ) -> Bool {
        guard let node = node else { return true }
        if let l = lower, node.val <= l { return false }
        if let u = upper, node.val >= u { return false }
        return validate(node.left, lower: lower, upper: node.val) &&
            validate(node.right, lower: node.val, upper: upper)
    }
}
```

```python [Python]
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def validate(
            node: Optional[TreeNode],
            low: Optional[int],
            high: Optional[int],
        ) -> bool:
            if not node:
                return True
            if low is not None and node.val <= low:
                return False
            if high is not None and node.val >= high:
                return False
            return validate(node.left, low, node.val) and validate(
                node.right, node.val, high
            )

        return validate(root, None, None)
```

:::

## Complexity

- **Time Complexity:** O(n), where n is the number of nodes. We visit each node exactly once.
- **Space Complexity:** O(h), where h is the height of the tree (recursion stack space).