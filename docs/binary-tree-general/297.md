# [297. Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Hard" />

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

**Clarification:**  The input/output format is the same as <a href="https://support.leetcode.com/hc/en-us/articles/32442719377939-How-to-create-test-cases-on-LeetCode#h_01J5EGREAW3NAEJ14XC07GRW1A" target="_blank">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" style="width: 442px; height: 324px;">

```
Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
```

**Example 2:** 

```
Input: root = []
Output: []
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[0, 10^4]</code>.
- <code>-1000 <= Node.val <= 1000</code>

## ðŸš€ Approach: Preorder Traversal with Null Markers

### Intuition

We can use **preorder traversal** to serialize the tree. The key insight is to include **null markers** to preserve the tree structure during deserialization.

**Key Points:**
1. **Preorder traversal** visits root â†’ left â†’ right
2. **Include null markers** for missing children to maintain structure
3. **Use a delimiter** (like comma) to separate values
4. **Deserialize by rebuilding** the tree using the same preorder logic

### Algorithm

1. **Serialize**: Use preorder traversal, append "null" for missing nodes
2. **Deserialize**: Parse the string and rebuild tree using preorder logic
3. **Handle edge cases**: Empty tree, single node, etc.

---

## Code

::: code-group

```kotlin [Kotlin]
/**
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */

class Codec {
    // Encodes a tree to a single string.
    fun serialize(root: TreeNode?): String {
        val result = mutableListOf<String>()
        serializeHelper(root, result)
        return result.joinToString(",")
    }
    
    private fun serializeHelper(node: TreeNode?, result: MutableList<String>) {
        if (node == null) {
            result.add("null")
            return
        }
        
        result.add(node.`val`.toString())
        serializeHelper(node.left, result)
        serializeHelper(node.right, result)
    }

    // Decodes your encoded data to tree.
    fun deserialize(data: String): TreeNode? {
        val values = data.split(",").toMutableList()
        return deserializeHelper(values)
    }
    
    private fun deserializeHelper(values: MutableList<String>): TreeNode? {
        if (values.isEmpty()) return null
        
        val value = values.removeAt(0)
        if (value == "null") return null
        
        val node = TreeNode(value.toInt())
        node.left = deserializeHelper(values)
        node.right = deserializeHelper(values)
        
        return node
    }
}
```

```typescript [TypeScript]
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

class Codec {
    // Encodes a tree to a single string.
    serialize(root: TreeNode | null): string {
        const result: string[] = [];
        this.serializeHelper(root, result);
        return result.join(',');
    }
    
    private serializeHelper(node: TreeNode | null, result: string[]): void {
        if (node === null) {
            result.push('null');
            return;
        }
        
        result.push(node.val.toString());
        this.serializeHelper(node.left, result);
        this.serializeHelper(node.right, result);
    }

    // Decodes your encoded data to tree.
    deserialize(data: string): TreeNode | null {
        const values = data.split(',');
        let index = 0;
        
        return this.deserializeHelper(values);
        
        function deserializeHelper(values: string[]): TreeNode | null {
            if (index >= values.length) return null;
            
            const value = values[index++];
            if (value === 'null') return null;
            
            const node = new TreeNode(parseInt(value));
            node.left = deserializeHelper(values);
            node.right = deserializeHelper(values);
            
            return node;
        }
    }
}
```

```java [Java]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder result = new StringBuilder();
        serializeHelper(root, result);
        return result.toString();
    }
    
    private void serializeHelper(TreeNode node, StringBuilder result) {
        if (node == null) {
            result.append("null,");
            return;
        }
        
        result.append(node.val).append(",");
        serializeHelper(node.left, result);
        serializeHelper(node.right, result);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] values = data.split(",");
        int[] index = {0};
        return deserializeHelper(values, index);
    }
    
    private TreeNode deserializeHelper(String[] values, int[] index) {
        if (index[0] >= values.length || values[index[0]].equals("null")) {
            index[0]++;
            return null;
        }
        
        TreeNode node = new TreeNode(Integer.parseInt(values[index[0]++]));
        node.left = deserializeHelper(values, index);
        node.right = deserializeHelper(values, index);
        
        return node;
    }
}
```

```swift [Swift]
// Definition for a binary tree node.
public class TreeNode {
    public var val: Int
    public var left: TreeNode?
    public var right: TreeNode?
    public init() { self.val = 0; self.left = nil; self.right = nil }
    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }
    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
        self.val = val
        self.left = left
        self.right = right
    }
}

class Codec {
    func serialize(_ root: TreeNode?) -> String {
        var tokens: [String] = []

        func dfs(_ node: TreeNode?) {
            guard let node = node else {
                tokens.append("null")
                return
            }
            tokens.append(String(node.val))
            dfs(node.left)
            dfs(node.right)
        }

        dfs(root)
        return tokens.joined(separator: ",")
    }

    func deserialize(_ data: String) -> TreeNode? {
        var values = data.split(separator: ",").map(String.init)
        var index = 0

        func build() -> TreeNode? {
            if index >= values.count {
                return nil
            }
            let value = values[index]
            index += 1
            if value == "null" {
                return nil
            }
            guard let number = Int(value) else { return nil }
            let node = TreeNode(number)
            node.left = build()
            node.right = build()
            return node
        }

        return build()
    }
}
```

```python [Python]
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        result = []
        self._serialize_helper(root, result)
        return ','.join(result)
    
    def _serialize_helper(self, node, result):
        if node is None:
            result.append('null')
            return
        
        result.append(str(node.val))
        self._serialize_helper(node.left, result)
        self._serialize_helper(node.right, result)

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        values = data.split(',')
        return self._deserialize_helper(values)
    
    def _deserialize_helper(self, values):
        if not values:
            return None
        
        value = values.pop(0)
        if value == 'null':
            return None
        
        node = TreeNode(int(value))
        node.left = self._deserialize_helper(values)
        node.right = self._deserialize_helper(values)
        
        return node
```

:::

## Complexity Analysis

- **Time Complexity:** O(n) where n is the number of nodes
  - **Serialize:** O(n) - Visit each node once
  - **Deserialize:** O(n) - Process each value once
- **Space Complexity:** O(n) 
  - **Serialize:** O(n) - Recursion stack + result string
  - **Deserialize:** O(n) - Recursion stack + values array