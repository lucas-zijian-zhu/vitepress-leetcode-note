# [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): "The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow **a node to be a descendant of itself**)."

**Example 1:** 

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

![236-1](./assets/236-1.png)

**Example 2:** 

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
```

![236-2](./assets/236-2.png)

**Example 3:** 

```
Input: root = [1,2], p = 1, q = 2
Output: 1
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[2, 10^5]</code>.
- <code>-10^9 <= Node.val <= 10^9</code>
- All <code>Node.val</code> are **unique**.
- <code>p != q</code>
- <code>p</code> and <code>q</code> will exist in the tree.


## ðŸ’¡ Approach: Post-order Traversal

### Intuition

The key insight is to use **post-order traversal** (left âž right âž root) to find the LCA. At each node, we check if it's the LCA by examining the results from its left and right subtrees.

**Key Insight:**
- If both left and right subtrees return non-null nodes, the current node is the LCA
- If only one subtree returns a non-null node, that node (or its ancestor) is the LCA
- If the current node is `p` or `q`, return it immediately

### Algorithm

1. **Base cases:**
   - If current node is `null`, return `null`
   - If current node is `p` or `q`, return the current node
2. **Recursively search** in left and right subtrees
3. **Check results:**
   - If both left and right return non-null â†’ current node is the LCA
   - If only one is non-null â†’ return that one
   - If both are null â†’ return `null`

### Key Points

- Post-order traversal ensures we check children before parent
- Time complexity: O(n) where n is the number of nodes
- Space complexity: O(h) where h is the height of the tree (recursion stack)

## Code

::: code-group

```typescript [TypeScript]
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
class Solution {
    lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {
        if (root === null || root === p || root === q) return root;

        const left = this.lowestCommonAncestor(root.left, p, q);
        const right = this.lowestCommonAncestor(root.right, p, q);

        if (left !== null && right !== null) {
            return root;
        } else if (left !== null) {
            return left;
        } else {
            return right;
        }
    }
}
```

```kotlin [Kotlin]
/**
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int = 0) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {
        if (root == null || root == p || root == q) return root

        val left = lowestCommonAncestor(root.left, p, q)
        val right = lowestCommonAncestor(root.right, p, q)

        return when {
            left != null && right != null -> root
            left != null -> left
            else -> right
        }
    }
}
```

```java [Java]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else {
            return right;
        }
    }
}
```

```swift [Swift]
// Definition for a binary tree node.
public class TreeNode {
    public var val: Int
    public var left: TreeNode?
    public var right: TreeNode?
    public init() { self.val = 0; self.left = nil; self.right = nil }
    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }
    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
        self.val = val
        self.left = left
        self.right = right
    }
}

class Solution {
    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {
        guard let root = root else { return nil }
        if root === p || root === q {
            return root
        }

        let left = lowestCommonAncestor(root.left, p, q)
        let right = lowestCommonAncestor(root.right, p, q)

        if left != nil && right != nil {
            return root
        }
        return left ?? right
    }
}
```

```python [Python]
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root is None or root == p or root == q:
            return root

        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        if left is not None and right is not None:
            return root
        elif left is not None:
            return left
        else:
            return right
```

:::
## Complexity

- **Time Complexity:** O(n), where n is the number of nodes in the tree. We visit each node at most once.
- **Space Complexity:** O(h), where h is the height of the tree. This is the space used by the recursion stack. In the worst case (skewed tree), h = n, so space complexity is O(n).