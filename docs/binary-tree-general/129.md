# [129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.

Each root-to-leaf path in the tree represents a number.

- For example, the root-to-leaf path <code>1 -> 2 -> 3</code> represents the number <code>123</code>.

Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a **32-bit**  integer.

A **leaf**  node is a node with no children.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" style="width: 212px; height: 182px;">

```
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path <code>1->2</code> represents the number <code>12</code>.
The root-to-leaf path <code>1->3</code> represents the number <code>13</code>.
Therefore, sum = 12 + 13 = <code>25</code>.
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" style="width: 292px; height: 302px;">

```
Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path <code>4->9->5</code> represents the number 495.
The root-to-leaf path <code>4->9->1</code> represents the number 491.
The root-to-leaf path <code>4->0</code> represents the number 40.
Therefore, sum = 495 + 491 + 40 = <code>1026</code>.
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[1, 1000]</code>.
- <code>0 <= Node.val <= 9</code>
- The depth of the tree will not exceed <code>10</code>.

## ðŸ’¡ Approach

Use **DFS (Depth-First Search)**  to track the number formed along each path.

At each node:

1. Multiply the current accumulated number by 10 and add the nodeâ€™s value.
2. If itâ€™s a **leaf node**, return the accumulated number.
3. Otherwise, recurse on the left and right subtrees.
4. Sum all values returned from the left and right subtrees to get the total.


---

## Code

::: code-group

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

class Solution {
    fun sumNumbers(root: TreeNode?): Int {
        return dfs(root, 0)
    }

    private fun dfs(node: TreeNode?, currentSum: Int): Int {
        if (node == null) return 0

        val newSum = currentSum * 10 + node.`val`

        if (node.left == null && node.right == null) {
            return newSum
        }

        return dfs(node.left, newSum) + dfs(node.right, newSum)
    }
}
```

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

class Solution {
    sumNumbers(root: TreeNode | null): number {
        return this.dfs(root, 0);
    }

    private dfs(node: TreeNode | null, currentSum: number): number {
        if (node === null) return 0;

        const newSum = currentSum * 10 + node.val;

        if (node.left === null && node.right === null) {
            return newSum;
        }

        return this.dfs(node.left, newSum) + this.dfs(node.right, newSum);
    }
}
```

```java [Java]
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public int sumNumbers(TreeNode root) {
        return dfs(root, 0);
    }

    private int dfs(TreeNode node, int currentSum) {
        if (node == null) return 0;

        int newSum = currentSum * 10 + node.val;

        if (node.left == null && node.right == null) {
            return newSum;
        }

        return dfs(node.left, newSum) + dfs(node.right, newSum);
    }
}
```

```swift [Swift]
// Definition for a binary tree node.
public class TreeNode {
    public var val: Int
    public var left: TreeNode?
    public var right: TreeNode?
    public init() { self.val = 0; self.left = nil; self.right = nil }
    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }
    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
        self.val = val
        self.left = left
        self.right = right
    }
}

class Solution {
    func sumNumbers(_ root: TreeNode?) -> Int {
        return dfs(root, 0)
    }

    private func dfs(_ node: TreeNode?, _ current: Int) -> Int {
        guard let node = node else { return 0 }
        let next = current * 10 + node.val
        if node.left == nil && node.right == nil {
            return next
        }
        return dfs(node.left, next) + dfs(node.right, next)
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        return self.dfs(root, 0)

    def dfs(self, node: Optional[TreeNode], current_sum: int) -> int:
        if node is None:
            return 0

        new_sum = current_sum * 10 + node.val

        if node.left is None and node.right is None:
            return new_sum

        return self.dfs(node.left, new_sum) + self.dfs(node.right, new_sum)
```

:::

## Complexity

Time Complexity: O(n), where n is the number of nodes in the tree.

Space Complexity: O(h), where h is the height of the tree (due to recursion stack).