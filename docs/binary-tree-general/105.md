# [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-interview-150)

Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return the binary tree.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" style="width: 277px; height: 302px;">

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**Example 2:** 

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

**Constraints:** 

- <code>1 <= preorder.length <= 3000</code>
- <code>inorder.length == preorder.length</code>
- <code>-3000 <= preorder[i], inorder[i] <= 3000</code>
- <code>preorder</code> and <code>inorder</code> consist of **unique**  values.
- Each value of <code>inorder</code> also appears in <code>preorder</code>.
- <code>preorder</code> is **guaranteed**  to be the preorder traversal of the tree.
- <code>inorder</code> is **guaranteed**  to be the inorder traversal of the tree.

## ðŸ’¡ Approach: Recursive with Hash Map

### Intuition

The key insight is that:
1. **Preorder traversal**: Root â†’ Left â†’ Right (first element is always the root)
2. **Inorder traversal**: Left â†’ Root â†’ Right (root divides left and right subtrees)

We can use this property to recursively build the tree:
1. The first element in preorder is the root
2. Find the root's position in inorder to determine left and right subtrees
3. Recursively build left and right subtrees

### Algorithm

1. **Create a hash map** to store the index of each value in inorder array for O(1) lookup
2. **Define recursive function** `buildTree(preStart, inStart, inEnd)`:
   - `preStart`: current root index in preorder
   - `inStart`, `inEnd`: current subtree range in inorder
3. **Base case**: If `inStart > inEnd`, return null
4. **Create root** from `preorder[preStart]`
5. **Find root position** in inorder using hash map
6. **Calculate left subtree size** = `rootIndex - inStart`
7. **Recursively build**:
   - Left subtree: `buildTree(preStart + 1, inStart, rootIndex - 1)`
   - Right subtree: `buildTree(preStart + leftSize + 1, rootIndex + 1, inEnd)`

## Code

::: code-group

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

class Solution {
    private lateinit var preorder: IntArray
    private lateinit var inorder: IntArray
    private lateinit var inorderMap: MutableMap<Int, Int>
    private var preIndex = 0

    fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? {
        this.preorder = preorder
        this.inorder = inorder
        this.inorderMap = mutableMapOf()
        
        // Build hash map for O(1) lookup
        for (i in inorder.indices) {
            inorderMap[inorder[i]] = i
        }
        
        return buildTree(0, inorder.size - 1)
    }
    
    private fun buildTree(inStart: Int, inEnd: Int): TreeNode? {
        if (inStart > inEnd) return null
        
        // Create root from preorder
        val rootValue = preorder[preIndex++]
        val root = TreeNode(rootValue)
        
        // Find root position in inorder
        val rootIndex = inorderMap[rootValue]!!
        
        // Build left and right subtrees
        root.left = buildTree(inStart, rootIndex - 1)
        root.right = buildTree(rootIndex + 1, inEnd)
        
        return root
    }
}
```

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

class Solution {
    private preorder: number[];
    private inorder: number[];
    private inorderMap: Map<number, number>;
    private preIndex: number;

    constructor() {
        this.preorder = [];
        this.inorder = [];
        this.inorderMap = new Map();
        this.preIndex = 0;
    }

    buildTree(preorder: number[], inorder: number[]): TreeNode | null {
        this.preorder = preorder;
        this.inorder = inorder;
        this.inorderMap = new Map();
        this.preIndex = 0;
        
        // Build hash map for O(1) lookup
        for (let i = 0; i < inorder.length; i++) {
            this.inorderMap.set(inorder[i], i);
        }
        
        return this.buildTreeRecursive(0, inorder.length - 1);
    }
    
    private buildTreeRecursive(inStart: number, inEnd: number): TreeNode | null {
        if (inStart > inEnd) return null;
        
        // Create root from preorder
        const rootValue = this.preorder[this.preIndex++];
        const root = new TreeNode(rootValue);
        
        // Find root position in inorder
        const rootIndex = this.inorderMap.get(rootValue)!;
        
        // Build left and right subtrees
        root.left = this.buildTreeRecursive(inStart, rootIndex - 1);
        root.right = this.buildTreeRecursive(rootIndex + 1, inEnd);
        
        return root;
    }
}
```

```java [Java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private int[] preorder;
    private int[] inorder;
    private Map<Integer, Integer> inorderMap;
    private int preIndex;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        this.inorder = inorder;
        this.inorderMap = new HashMap<>();
        this.preIndex = 0;
        
        // Build hash map for O(1) lookup
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        
        return buildTreeRecursive(0, inorder.length - 1);
    }
    
    private TreeNode buildTreeRecursive(int inStart, int inEnd) {
        if (inStart > inEnd) return null;
        
        // Create root from preorder
        int rootValue = preorder[preIndex++];
        TreeNode root = new TreeNode(rootValue);
        
        // Find root position in inorder
        int rootIndex = inorderMap.get(rootValue);
        
        // Build left and right subtrees
        root.left = buildTreeRecursive(inStart, rootIndex - 1);
        root.right = buildTreeRecursive(rootIndex + 1, inEnd);
        
        return root;
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        self.preorder = preorder
        self.inorder = inorder
        self.inorder_map = {}
        self.pre_index = 0
        
        # Build hash map for O(1) lookup
        for i, val in enumerate(inorder):
            self.inorder_map[val] = i
        
        return self._build_tree(0, len(inorder) - 1)
    
    def _build_tree(self, in_start: int, in_end: int) -> Optional[TreeNode]:
        if in_start > in_end:
            return None
        
        # Create root from preorder
        root_value = self.preorder[self.pre_index]
        self.pre_index += 1
        root = TreeNode(root_value)
        
        # Find root position in inorder
        root_index = self.inorder_map[root_value]
        
        # Build left and right subtrees
        root.left = self._build_tree(in_start, root_index - 1)
        root.right = self._build_tree(root_index + 1, in_end)
        
        return root
```

:::

## Complexity

- **Time Complexity:** O(n), where n is the number of nodes. We visit each node exactly once.
- **Space Complexity:** O(n), for the hash map and recursion stack. In the worst case (skewed tree), the recursion stack can be O(n).