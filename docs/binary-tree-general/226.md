# [226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150)

Given the <code>root</code> of a binary tree, invert the tree, and return its root.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" style="width: 500px; height: 165px;">

```
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" style="width: 500px; height: 120px;">

```
Input: root = [2,1,3]
Output: [2,3,1]
```

**Example 3:** 

```
Input: root = []
Output: []
```

**Constraints:** 

- The number of nodes in the tree is in the range <code>[0, 100]</code>.
- <code>-100 <= Node.val <= 100</code>

## ðŸ’¡ Approach: Recursive (DFS)

### Intuition

To invert a binary tree, we need to swap the left and right children of every node. This can be done recursively by:

1. **Base case**: If the node is `null`, return `null`
2. **Recursive case**: 
   - Swap the left and right children
   - Recursively invert the left subtree
   - Recursively invert the right subtree
   - Return the current node

### Algorithm

1. **Base case**: If `root` is `null`, return `null`
2. **Swap children**: Swap the left and right children of the current node
3. **Recursive calls**: Recursively invert the left and right subtrees
4. **Return**: Return the current node

## Code

::: code-group

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

class Solution {
    fun invertTree(root: TreeNode?): TreeNode? {
        if (root == null) return null
        
        // Swap left and right children
        val temp = root.left
        root.left = root.right
        root.right = temp
        
        // Recursively invert subtrees
        invertTree(root.left)
        invertTree(root.right)
        
        return root
    }
}
```

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

class Solution {
    invertTree(root: TreeNode | null): TreeNode | null {
        if (root === null) return null;
        
        // Swap left and right children
        const temp = root.left;
        root.left = root.right;
        root.right = temp;
        
        // Recursively invert subtrees
        this.invertTree(root.left);
        this.invertTree(root.right);
        
        return root;
    }
}
```

```java [Java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        
        // Swap left and right children
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        
        // Recursively invert subtrees
        invertTree(root.left);
        invertTree(root.right);
        
        return root;
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root is None:
            return None
        
        # Swap left and right children
        root.left, root.right = root.right, root.left
        
        # Recursively invert subtrees
        self.invertTree(root.left)
        self.invertTree(root.right)
        
        return root
```

:::

## Complexity

- **Time Complexity:** O(n), where n is the number of nodes in the tree. We visit each node exactly once.
- **Space Complexity:** O(h), where h is the height of the tree. The space is used by the recursion stack. In the worst case (skewed tree), the height is O(n).