# [909. Snakes and Ladders](https://leetcode.com/problems/snakes-and-ladders/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

You are given an <code>n x n</code> integer matrix <code>board</code> where the cells are labeled from <code>1</code> to <code>n^2</code> in a <a href="https://en.wikipedia.org/wiki/Boustrophedon" target="_blank">**Boustrophedon style** </a> starting from the bottom left of the board (i.e. <code>board[n - 1][0]</code>) and alternating direction each row.

You start on square <code>1</code> of the board. In each move, starting from square <code>curr</code>, do the following:

- Choose a destination square <code>next</code> with a label in the range <code>[curr + 1, min(curr + 6, n^2)]</code>.

- This choice simulates the result of a standard **6-sided die roll** : i.e., there are always at most 6 destinations, regardless of the size of the board.

- If <code>next</code> has a snake or ladder, you **must**  move to the destination of that snake or ladder. Otherwise, you move to <code>next</code>.
- The game ends when you reach the square <code>n^2</code>.

A board square on row <code>r</code> and column <code>c</code> has a snake or ladder if <code>board[r][c] != -1</code>. The destination of that snake or ladder is <code>board[r][c]</code>. Squares <code>1</code> and <code>n^2</code> are not the starting points of any snake or ladder.

Note that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do **not**  follow the subsequent snake or ladder.

- For example, suppose the board is <code>[[-1,4],[-1,3]]</code>, and on the first move, your destination square is <code>2</code>. You follow the ladder to square <code>3</code>, but do **not**  follow the subsequent ladder to <code>4</code>.

Return the least number of dice rolls required to reach the square <code>n^2</code>. If it is not possible to reach the square, return <code>-1</code>.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" style="width: 500px; height: 394px;">

```
Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
Output: 4
Explanation: 
In the beginning, you start at square 1 (at row 5, column 0).
You decide to move to square 2 and must take the ladder to square 15.
You then decide to move to square 17 and must take the snake to square 13.
You then decide to move to square 14 and must take the ladder to square 35.
You then decide to move to square 36, ending the game.
This is the lowest possible number of moves to reach the last square, so return 4.
```

**Example 2:** 

```
Input: board = [[-1,-1],[-1,3]]
Output: 1
```

**Constraints:** 

- <code>n == board.length == board[i].length</code>
- <code>2 <= n <= 20</code>
- <code>board[i][j]</code> is either <code>-1</code> or in the range <code>[1, n^2]</code>.
- The squares labeled <code>1</code> and <code>n^2</code> are not the starting points of any snake or ladder.

## ðŸš€ Approach: BFS (Shortest Path)

### Intuition

This is a **shortest path problem** in a graph where:
- Each square is a **node**
- Each die roll creates up to 6 **edges** to reachable squares
- Snakes and ladders are **shortcuts** to other nodes

We can use **BFS** to find the minimum number of moves since BFS naturally finds the shortest path in an unweighted graph.

**Key Challenges:**
1. **Boustrophedon layout** - Need to convert square number to (row, col) coordinates
2. **Snakes and ladders** - Need to follow them to destination
3. **Shortest path** - BFS guarantees minimum moves

### Algorithm

1. **Convert square number to coordinates** - Handle the zigzag layout
2. **BFS from square 1** - Use queue to explore all reachable squares
3. **For each square** - Try all 6 die rolls (1-6)
4. **Follow snakes/ladders** - Jump to destination if present
5. **Track visited squares** - Avoid revisiting
6. **Return steps** when reaching nÂ²

---

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun snakesAndLadders(board: Array<IntArray>): Int {
        val n = board.size
        val target = n * n
        
        val visited = BooleanArray(target + 1)
        val queue = ArrayDeque<Pair<Int, Int>>() // (position, steps)
        queue.offer(Pair(1, 0))
        visited[1] = true
        
        while (queue.isNotEmpty()) {
            val (curr, steps) = queue.poll()
            
            if (curr == target) return steps
            
            // Try all 6 die rolls
            for (i in 1..6) {
                var next = curr + i
                if (next > target) break
                
                // Get board coordinates
                val (row, col) = getCoordinates(next, n)
                
                // Follow snake or ladder if present
                if (board[row][col] != -1) {
                    next = board[row][col]
                }
                
                if (!visited[next]) {
                    visited[next] = true
                    queue.offer(Pair(next, steps + 1))
                }
            }
        }
        
        return -1
    }
    
    private fun getCoordinates(square: Int, n: Int): Pair<Int, Int> {
        val row = (square - 1) / n
        val col = (square - 1) % n
        
        val actualRow = n - 1 - row
        val actualCol = if (row % 2 == 0) col else n - 1 - col
        
        return Pair(actualRow, actualCol)
    }
}
```

```typescript [TypeScript]
function snakesAndLadders(board: number[][]): number {
    const n = board.length;
    const target = n * n;
    
    const visited = new Array(target + 1).fill(false);
    const queue: [number, number][] = [[1, 0]]; // [position, steps]
    visited[1] = true;
    
    while (queue.length > 0) {
        const [curr, steps] = queue.shift()!;
        
        if (curr === target) return steps;
        
        // Try all 6 die rolls
        for (let i = 1; i <= 6; i++) {
            let next = curr + i;
            if (next > target) break;
            
            // Get board coordinates
            const [row, col] = getCoordinates(next, n);
            
            // Follow snake or ladder if present
            if (board[row][col] !== -1) {
                next = board[row][col];
            }
            
            if (!visited[next]) {
                visited[next] = true;
                queue.push([next, steps + 1]);
            }
        }
    }
    
    return -1;
}

function getCoordinates(square: number, n: number): [number, number] {
    const row = Math.floor((square - 1) / n);
    const col = (square - 1) % n;
    
    const actualRow = n - 1 - row;
    const actualCol = row % 2 === 0 ? col : n - 1 - col;
    
    return [actualRow, actualCol];
}
```

```java [Java]
class Solution {
    public int snakesAndLadders(int[][] board) {
        int n = board.length;
        int target = n * n;
        
        boolean[] visited = new boolean[target + 1];
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{1, 0}); // {position, steps}
        visited[1] = true;
        
        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int curr = current[0];
            int steps = current[1];
            
            if (curr == target) return steps;
            
            // Try all 6 die rolls
            for (int i = 1; i <= 6; i++) {
                int next = curr + i;
                if (next > target) break;
                
                // Get board coordinates
                int[] coords = getCoordinates(next, n);
                int row = coords[0];
                int col = coords[1];
                
                // Follow snake or ladder if present
                if (board[row][col] != -1) {
                    next = board[row][col];
                }
                
                if (!visited[next]) {
                    visited[next] = true;
                    queue.offer(new int[]{next, steps + 1});
                }
            }
        }
        
        return -1;
    }
    
    private int[] getCoordinates(int square, int n) {
        int row = (square - 1) / n;
        int col = (square - 1) % n;
        
        int actualRow = n - 1 - row;
        int actualCol = (row % 2 == 0) ? col : n - 1 - col;
        
        return new int[]{actualRow, actualCol};
    }
}
```

```swift [Swift]
class Solution {
    func snakesAndLadders(_ board: [[Int]]) -> Int {
        let n = board.count
        let target = n * n

        func coordinates(_ square: Int) -> (Int, Int) {
            let row = (square - 1) / n
            let col = (square - 1) % n
            let actualRow = n - 1 - row
            let actualCol = row % 2 == 0 ? col : n - 1 - col
            return (actualRow, actualCol)
        }

        var visited = Set<Int>([1])
        var queue: [(Int, Int)] = [(1, 0)]

        while !queue.isEmpty {
            let (curr, steps) = queue.removeFirst()
            if curr == target {
                return steps
            }
            for i in 1...6 {
                var next = curr + i
                if next > target {
                    break
                }
                let (row, col) = coordinates(next)
                if board[row][col] != -1 {
                    next = board[row][col]
                }
                if !visited.contains(next) {
                    visited.insert(next)
                    queue.append((next, steps + 1))
                }
            }
        }

        return -1
    }
}
```

```python [Python]
class Solution:

:::

## Complexity Analysis

**Notation:**
- **n** = Board dimension (n Ã— n board)
- **V** = Number of squares = nÂ²
- **E** = Number of edges â‰ˆ 6V (each square can connect to 6 others)

- **Time Complexity:** O(nÂ²) = O(V)
  - Each square is visited at most once
  - For each square, we try up to 6 die rolls
  - Total: O(V Ã— 6) = O(V) = O(nÂ²)
- **Space Complexity:** O(nÂ²) = O(V)
  - Visited array: O(V)
  - Queue: O(V) in worst case