# [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return the <code>k^th</code> smallest value (**1-indexed** ) of all the values of the nodes in the tree.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" style="width: 212px; height: 301px;">

```
Input: root = [3,1,4,null,2], k = 1
Output: 1
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" style="width: 382px; height: 302px;">

```
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
```

**Constraints:** 

- The number of nodes in the tree is <code>n</code>.
- <code>1 <= k <= n <= 10^4</code>
- <code>0 <= Node.val <= 10^4</code>

**Follow up:**  If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?

## ðŸ’¡ Approach: Inorder Traversal

### Intuition

Since this is a **Binary Search Tree (BST)**, an inorder traversal will visit the nodes in ascending order (smallest to largest). We can perform inorder traversal and return the kth node we visit.

### Algorithm

1. **Perform inorder traversal** (left â†’ root â†’ right)
2. **Keep a counter** to track how many nodes we've visited
3. **When counter equals k**, we've found the kth smallest element
4. **Return the value** of that node

### Key Points

- Inorder traversal of BST gives sorted order
- Use counter to track visited nodes
- Stop traversal once kth element is found
- Can optimize by stopping early

## Code

::: code-group

```kotlin [Kotlin]
class TreeNode(var `val`: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

class Solution {
    private var count = 0
    private var result = 0
    
    fun kthSmallest(root: TreeNode?, k: Int): Int {
        count = k
        inorder(root)
        return result
    }
    
    private fun inorder(node: TreeNode?) {
        if (node == null) return
        
        inorder(node.left)
        
        count--
        if (count == 0) {
            result = node.`val`
            return
        }
        
        inorder(node.right)
    }
}
```

```typescript [TypeScript]
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

class Solution {
    private count: number = 0;
    private result: number = 0;
    
    kthSmallest(root: TreeNode | null, k: number): number {
        this.count = k;
        this.inorder(root);
        return this.result;
    }
    
    private inorder(node: TreeNode | null): void {
        if (node === null) return;
        
        this.inorder(node.left);
        
        this.count--;
        if (this.count === 0) {
            this.result = node.val;
            return;
        }
        
        this.inorder(node.right);
    }
}
```

```java [Java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private int count = 0;
    private int result = 0;
    
    public int kthSmallest(TreeNode root, int k) {
        count = k;
        inorder(root);
        return result;
    }
    
    private void inorder(TreeNode node) {
        if (node == null) return;
        
        inorder(node.left);
        
        count--;
        if (count == 0) {
            result = node.val;
            return;
        }
        
        inorder(node.right);
    }
}
```

```python [Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.count = k
        self.result = 0
        
        def inorder(node):
            if not node:
                return
            
            inorder(node.left)
            
            self.count -= 1
            if self.count == 0:
                self.result = node.val
                return
            
            inorder(node.right)
        
        inorder(root)
        return self.result
```

:::

## Complexity

- **Time Complexity:** O(h + k), where h is the height of the tree. In the worst case, we might need to visit k nodes.
- **Space Complexity:** O(h), where h is the height of the tree (recursion stack space).