# [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-interview-150)

Given an integer array <code>nums</code>, return the length of the longest **strictly increasing ** <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:rs:" data-state="closed" class="">**subsequence** </button>.

**Example 1:** 

```
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```

**Example 2:** 

```
Input: nums = [0,1,0,3,2,3]
Output: 4
```

**Example 3:** 

```
Input: nums = [7,7,7,7,7,7,7]
Output: 1
```

**Constraints:** 

- <code>1 <= nums.length <= 2500</code>
- <code>-10^4 <= nums[i] <= 10^4</code>

<b>Follow up:</b>Can you come up with an algorithm that runs in<code>O(n log(n))</code> time complexity?

## üí° Approach: Greedy + Binary Search (`O(n log n)`)

### Intuition  
Maintain an auxiliary array **`tails`** where  
`tails[k]` = the **smallest possible tail value** of any increasing subsequence of length `k + 1`.  
While scanning `nums`, for every element `x`:

1. Use binary search in `tails` to find the first index `idx` where `tails[idx] ‚â• x`.  
2. If `idx == tails.size`, append `x` (we found a longer LIS);  
   otherwise replace `tails[idx] = x` (keep the tail as small as possible).

The **length of `tails`** after processing all numbers is exactly the LIS length.

---

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun lengthOfLIS(nums: IntArray): Int {
        val tails = IntArray(nums.size)           // tails[0..len-1] is valid
        var len = 0                               // current LIS length

        for (x in nums) {
            // binary search for first tails[idx] >= x
            var l = 0
            var r = len                           // [l, r)
            while (l < r) {
                val m = (l + r) ushr 1
                if (tails[m] >= x) r = m
                else l = m + 1
            }
            tails[l] = x                          // overwrite or append
            if (l == len) len++                   // found a longer subsequence
        }
        return len
    }
}
```

```typescript [TypeScript]
function lengthOfLIS(nums: number[]): number {
    const tails: number[] = new Array(nums.length);
    let len = 0;

    for (const x of nums) {
        // Binary search for first tails[idx] >= x
        let l = 0;
        let r = len;
        while (l < r) {
            const m = Math.floor((l + r) / 2);
            if (tails[m] >= x) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        tails[l] = x; // Overwrite or append
        if (l === len) len++; // Found a longer subsequence
    }
    
    return len;
}
```

```java [Java]
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        int len = 0;

        for (int x : nums) {
            // Binary search for first tails[idx] >= x
            int l = 0, r = len;
            while (l < r) {
                int m = (l + r) / 2;
                if (tails[m] >= x) {
                    r = m;
                } else {
                    l = m + 1;
                }
            }
            tails[l] = x; // Overwrite or append
            if (l == len) len++; // Found a longer subsequence
        }
        
        return len;
    }
}
```

```python [Python]
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        tails = [0] * len(nums)
        length = 0

        for x in nums:
            # Binary search for first tails[idx] >= x
            l, r = 0, length
            while l < r:
                m = (l + r) // 2
                if tails[m] >= x:
                    r = m
                else:
                    l = m + 1
            tails[l] = x  # Overwrite or append
            if l == length:
                length += 1  # Found a longer subsequence
        
        return length
```

:::

### ‚è±Ô∏è Time and Space Complexity

| Complexity Type | Big-O        | Reasoning |
|-----------------|--------------|-----------|
| **Time**        | `O(n log n)` | For each of the `n` elements we perform a binary search (`log n`) inside the `tails` array. |
| **Space**       | `O(n)`       | The auxiliary array `tails` stores at most `n` integers. |
