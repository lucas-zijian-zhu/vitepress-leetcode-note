# [433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/?envType=study-plan-v2&envId=top-interview-150) <Badge type="warning" text="Medium" />

A gene string can be represented by an 8-character long string, with choices from <code>'A'</code>, <code>'C'</code>, <code>'G'</code>, and <code>'T'</code>.

Suppose we need to investigate a mutation from a gene string <code>startGene</code> to a gene string <code>endGene</code> where one mutation is defined as one single character changed in the gene string.

- For example, <code>"AACCGGTT" --> "AACCGGTA"</code> is one mutation.

There is also a gene bank <code>bank</code> that records all the valid gene mutations. A gene must be in <code>bank</code> to make it a valid gene string.

Given the two gene strings <code>startGene</code> and <code>endGene</code> and the gene bank <code>bank</code>, return the minimum number of mutations needed to mutate from <code>startGene</code> to <code>endGene</code>. If there is no such a mutation, return <code>-1</code>.

Note that the starting point is assumed to be valid, so it might not be included in the bank.

**Example 1:** 

```
Input: startGene = "AACCGGTT", endGene = "AACCGGTA", bank = ["AACCGGTA"]
Output: 1
```

**Example 2:** 

```
Input: startGene = "AACCGGTT", endGene = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
Output: 2
```

**Constraints:** 

- <code>0 <= bank.length <= 10</code>
- <code>startGene.length == endGene.length == bank[i].length == 8</code>
- <code>startGene</code>, <code>endGene</code>, and <code>bank[i]</code> consist of only the characters <code>['A', 'C', 'G', 'T']</code>.

## ðŸ’¡ Approach: BFS (Breadth-First Search)

### Intuition

This is a classic **shortest path** problem in an implicit graph. We can model this as:
- Each valid gene string is a node
- An edge exists between two nodes if they differ by exactly one character
- We want to find the shortest path from `startGene` to `endGene`

Since we need the **minimum number of mutations** (shortest path), **BFS** is the optimal choice because:
- BFS explores nodes level by level, ensuring the first time we reach `endGene`, we've found the shortest path
- We avoid unnecessary longer paths by marking visited nodes

### Algorithm

1. **Check edge cases**: If `startGene == endGene`, return 0
2. **Build the gene bank set** for O(1) lookup
3. **Use BFS** with a queue to explore all possible mutations
4. **For each current gene**, try changing each position to each valid character (A, C, G, T)
5. **If the new gene** is valid (in bank) and not visited, add it to queue
6. **When we reach endGene**, return the number of mutations
7. **If queue is empty** without finding endGene, return -1

### Key Points

- Use BFS for shortest path guarantee
- Only consider genes in the bank (valid genes)
- Avoid revisiting the same gene (cycle detection)
- Generate all possible 1-character mutations efficiently

## Code

::: code-group

```typescript [TypeScript]
function minMutation(startGene: string, endGene: string, bank: string[]): number {
    if (startGene === endGene) return 0;
    
    const bankSet = new Set(bank);
    if (!bankSet.has(endGene)) return -1;
    
    const queue: string[] = [startGene];
    const visited = new Set<string>([startGene]);
    const directions = ['A', 'C', 'G', 'T'];
    let mutations = 0;
    
    while (queue.length > 0) {
        const size = queue.length;
        
        for (let i = 0; i < size; i++) {
            const current = queue.shift()!;
            
            if (current === endGene) {
                return mutations;
            }
            
            // Try all possible mutations
            const chars = current.split('');
            for (let j = 0; j < chars.length; j++) {
                const originalChar = chars[j];
                
                for (const direction of directions) {
                    if (direction !== originalChar) {
                        chars[j] = direction;
                        const mutated = chars.join('');
                        
                        if (bankSet.has(mutated) && !visited.has(mutated)) {
                            visited.add(mutated);
                            queue.push(mutated);
                        }
                    }
                }
                
                chars[j] = originalChar; // Reset
            }
        }
        
        mutations++;
    }
    
    return -1;
}
```

```kotlin [Kotlin]
class Solution {
    fun minMutation(startGene: String, endGene: String, bank: Array<String>): Int {
        if (startGene == endGene) return 0
        
        val bankSet = bank.toSet()
        if (endGene !in bankSet) return -1
        
        val queue = ArrayDeque<String>()
        val visited = mutableSetOf<String>()
        val directions = charArrayOf('A', 'C', 'G', 'T')
        
        queue.offer(startGene)
        visited.add(startGene)
        var mutations = 0
        
        while (queue.isNotEmpty()) {
            val size = queue.size
            
            for (i in 0 until size) {
                val current = queue.poll()
                
                if (current == endGene) {
                    return mutations
                }
                
                // Try all possible mutations (change each position)
                val chars = current.toCharArray()
                for (j in chars.indices) {
                    val originalChar = chars[j]
                    
                    for (direction in directions) {
                        if (direction != originalChar) {
                            chars[j] = direction
                            val mutated = String(chars)
                            
                            if (mutated in bankSet && mutated !in visited) {
                                visited.add(mutated)
                                queue.offer(mutated)
                            }
                        }
                    }
                    
                    chars[j] = originalChar // Reset for next iteration
                }
            }
            
            mutations++
        }
        
        return -1
    }
}
```

```java [Java]
class Solution {
    public int minMutation(String startGene, String endGene, String[] bank) {
        if (startGene.equals(endGene)) return 0;
        
        Set<String> bankSet = new HashSet<>(Arrays.asList(bank));
        if (!bankSet.contains(endGene)) return -1;
        
        Queue<String> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        char[] directions = {'A', 'C', 'G', 'T'};
        
        queue.offer(startGene);
        visited.add(startGene);
        int mutations = 0;
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            
            for (int i = 0; i < size; i++) {
                String current = queue.poll();
                
                if (current.equals(endGene)) {
                    return mutations;
                }
                
                // Try all possible mutations
                char[] chars = current.toCharArray();
                for (int j = 0; j < chars.length; j++) {
                    char originalChar = chars[j];
                    
                    for (char direction : directions) {
                        if (direction != originalChar) {
                            chars[j] = direction;
                            String mutated = new String(chars);
                            
                            if (bankSet.contains(mutated) && !visited.contains(mutated)) {
                                visited.add(mutated);
                                queue.offer(mutated);
                            }
                        }
                    }
                    
                    chars[j] = originalChar; // Reset
                }
            }
            
            mutations++;
        }
        
        return -1;
    }
}
```

```swift [Swift]
class Solution {
    func minMutation(_ startGene: String, _ endGene: String, _ bank: [String]) -> Int {
        var bankSet = Set(bank)
        if !bankSet.contains(endGene) {
            return -1
        }

        let genes: [Character] = ["A", "C", "G", "T"]
        var queue: [(String, Int)] = [(startGene, 0)]

        while !queue.isEmpty {
            let (gene, steps) = queue.removeFirst()
            if gene == endGene {
                return steps
            }

            var chars = Array(gene)
            for i in 0..<chars.count {
                let original = chars[i]
                for g in genes where g != original {
                    chars[i] = g
                    let nextGene = String(chars)
                    if bankSet.contains(nextGene) {
                        bankSet.remove(nextGene)
                        queue.append((nextGene, steps + 1))
                    }
                }
                chars[i] = original
            }
        }

        return -1
    }
}
```

```python [Python]
class Solution:
    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        if startGene == endGene:
            return 0
        
        bank_set = set(bank)
        if endGene not in bank_set:
            return -1
        
        queue = deque([startGene])
        visited = {startGene}
        directions = ['A', 'C', 'G', 'T']
        mutations = 0
        
        while queue:
            size = len(queue)
            
            for _ in range(size):
                current = queue.popleft()
                
                if current == endGene:
                    return mutations
                
                # Try all possible mutations
                chars = list(current)
                for i in range(len(chars)):
                    original_char = chars[i]
                    
                    for direction in directions:
                        if direction != original_char:
                            chars[i] = direction
                            mutated = ''.join(chars)
                            
                            if mutated in bank_set and mutated not in visited:
                                visited.add(mutated)
                                queue.append(mutated)
                    
                    chars[i] = original_char  # Reset
        
            mutations += 1
        
        return -1
```

:::
## Complexity

- **Time Complexity:** O(B Ã— 8 Ã— 4) = O(B), where B is the size of the bank. We visit each valid gene at most once, and for each gene we check 8 positions Ã— 4 possible characters.
- **Space Complexity:** O(B) for the bank set, queue, and visited set.