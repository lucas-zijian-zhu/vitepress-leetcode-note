# [200. Number of Islands](https://leetcode.com/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>'1'</code>s (land) and <code>'0'</code>s (water), return the number of islands.

An **island**  is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:** 

```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

**Example 2:** 

```
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

**Constraints:** 

- <code>m == grid.length</code>
- <code>n == grid[i].length</code>
- <code>1 <= m, n <= 300</code>
- <code>grid[i][j]</code> is <code>'0'</code> or <code>'1'</code>.

## ðŸ’¡ Approach: BFS with Stack (Iterative)

### Intuition

We can use **BFS with a stack** to explore each island. When we find a '1', we increment the island count and then use BFS to mark all connected '1's as visited (by changing them to '0'). This approach avoids potential stack overflow issues that might occur with deep recursion.

### Algorithm

1. **Iterate through each cell** in the grid
2. **When we find a '1'**, increment island count
3. **Use BFS with stack** to mark all connected '1's as visited (change to '0')
4. **BFS explores** all 4 directions (up, down, left, right)
5. **Return the total count** of islands

### Key Points

- Use BFS with explicit stack to avoid recursion stack overflow
- Mark visited cells by changing '1' to '0'
- Check boundaries before exploring neighbors
- Use coordinate encoding (i * column + j) for efficient storage
- Count each new '1' as a new island

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun numIslands(grid: Array<CharArray>): Int {
        if (grid.isEmpty()) return 0
        
        val rows = grid.size
        val cols = grid[0].size
        var count = 0
        val stack = mutableListOf<Int>()
        val directions = arrayOf(intArrayOf(1, 0), intArrayOf(0, 1), intArrayOf(-1, 0), intArrayOf(0, -1))
        
        for (i in 0 until rows) {
            for (j in 0 until cols) {
                if (grid[i][j] == '1') {
                    count++
                    stack.add(i * cols + j)
                    
                    while (stack.isNotEmpty()) {
                        val dot = stack.removeAt(0)
                        val r = dot / cols
                        val c = dot % cols
                        
                        for (direction in directions) {
                            val nr = r + direction[0]
                            val nc = c + direction[1]
                            
                            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == '1') {
                                grid[nr][nc] = '0'
                                stack.add(nr * cols + nc)
                            }
                        }
                    }
                }
            }
        }
        
        return count
    }
}
```

```typescript [TypeScript]
function numIslands(grid: string[][]): number {
    if (grid.length === 0) return 0;
    
    let count = 0;
    const row = grid.length, column = grid[0].length;
    const stack: number[] = [];
    const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];
    
    for (let i = 0; i < row; i++) {
        for (let j = 0; j < column; j++) {
            if (grid[i][j] === '1') {
                count++;
                stack.push(i * column + j);
                
                while (stack.length) {
                    const dot = stack.shift()!;
                    const r = Math.floor(dot / column);
                    const c = dot % column;
                    
                    for (let direction of directions) {
                        const nr = r + direction[0];
                        const nc = c + direction[1];
                        
                        if ((nr >= 0 && nr < row) && (nc >= 0 && nc < column) && (grid[nr][nc] === '1')) {
                            grid[nr][nc] = '0';
                            stack.push(nr * column + nc);
                        }
                    }
                }
            }
        }
    }
    
    return count;
}
```

```java [Java]
class Solution {
    public int numIslands(char[][] grid) {
        if (grid.length == 0) return 0;
        
        int rows = grid.length;
        int cols = grid[0].length;
        int count = 0;
        Queue<Integer> queue = new LinkedList<>();
        int[][] directions = {â€‹{1, 0}, {0, 1}, {-1, 0}, {0, -1}â€‹};
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    queue.offer(i * cols + j);
                    
                    while (!queue.isEmpty()) {
                        int dot = queue.poll();
                        int r = dot / cols;
                        int c = dot % cols;
                        
                        for (int[] direction : directions) {
                            int nr = r + direction[0];
                            int nc = c + direction[1];
                            
                            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == '1') {
                                grid[nr][nc] = '0';
                                queue.offer(nr * cols + nc);
                            }
                        }
                    }
                }
            }
        }
        
        return count;
    }
}
```

```swift [Swift]
class Solution {
    func numIslands(_ grid: [[Character]]) -> Int {
        var grid = grid
        let rows = grid.count
        guard rows > 0 else { return 0 }
        let cols = grid[0].count
        var count = 0

        func dfs(_ r: Int, _ c: Int) {
            if r < 0 || c < 0 || r >= rows || c >= cols {
                return
            }
            if grid[r][c] != "1" {
                return
            }
            grid[r][c] = "0"
            dfs(r + 1, c)
            dfs(r - 1, c)
            dfs(r, c + 1)
            dfs(r, c - 1)
        }

        for r in 0..<rows {
            for c in 0..<cols {
                if grid[r][c] == "1" {
                    count += 1
                    dfs(r, c)
                }
            }
        }

        return count
    }
}
```

```python [Python]
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        
        rows, cols = len(grid), len(grid[0])
        count = 0
        stack = []
        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == '1':
                    count += 1
                    stack.append(i * cols + j)
                    
                    while stack:
                        dot = stack.pop(0)
                        r = dot // cols
                        c = dot % cols
                        
                        for direction in directions:
                            nr = r + direction[0]
                            nc = c + direction[1]
                            
                            if (0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1'):
                                grid[nr][nc] = '0'
                                stack.append(nr * cols + nc)
        
        return count
```

:::

## Complexity

- **Time Complexity:** O(m Ã— n), where m is the number of rows and n is the number of columns. We visit each cell once.
- **Space Complexity:** O(m Ã— n) in the worst case for the queue/stack (if the entire grid is filled with land). This approach avoids potential stack overflow issues that could occur with deep recursion.