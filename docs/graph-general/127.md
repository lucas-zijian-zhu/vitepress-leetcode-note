# [127. Word Ladder](https://leetcode.com/problems/word-ladder/description/?envType=study-plan-v2&envId=top-interview-150)

A **transformation sequence**  from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -> s<sub>1</sub> -> s<sub>2</sub> -> ... -> s<sub>k</sub></code> such that:

- Every adjacent pair of words differs by a single letter.
- Every <code>s<sub>i</sub></code> for <code>1 <= i <= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.
- <code>s<sub>k</sub> == endWord</code>

Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return the **number of words**  in the **shortest transformation sequence**  from <code>beginWord</code> to <code>endWord</code>, or <code>0</code> if no such sequence exists.

**Example 1:** 

```
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.
```

**Example 2:** 

```
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
Output: 0
Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.
```

**Constraints:** 

- <code>1 <= beginWord.length <= 10</code>
- <code>endWord.length == beginWord.length</code>
- <code>1 <= wordList.length <= 5000</code>
- <code>wordList[i].length == beginWord.length</code>
- <code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.
- <code>beginWord != endWord</code>
- All the words in <code>wordList</code> are **unique** .

## ðŸ’¡ Approach: BFS (Breadth-First Search)

### Intuition

This is a classic **shortest path** problem in an implicit graph. We can model this as:
- Each word is a node
- An edge exists between two words if they differ by exactly one character
- We want to find the shortest transformation sequence from `beginWord` to `endWord`

Since we need the **minimum number of words** (shortest path), **BFS** is the optimal choice because:
- BFS explores nodes level by level, ensuring the first time we reach `endWord`, we've found the shortest path
- We avoid unnecessary longer paths by marking visited words

### Algorithm

1. **Check edge cases**: If `beginWord == endWord`, return 0. If `endWord` not in wordList, return 0
2. **Build the word set** for O(1) lookup
3. **Use BFS** with a queue to explore all possible transformations
4. **For each current word**, try changing each position to each possible character (a-z)
5. **If the new word** is valid (in wordList) and not visited, add it to queue
6. **When we reach endWord**, return the number of words in the sequence
7. **If queue is empty** without finding endWord, return 0

### Key Points

- Use BFS for shortest path guarantee
- Only consider words in the wordList (valid words)
- Avoid revisiting the same word (cycle detection)
- Generate all possible 1-character changes efficiently
- Return the **length** of the transformation sequence, not the number of steps

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {
        if (endWord !in wordList) return 0
        if (beginWord == endWord) return 1
        
        val wordSet = wordList.toSet()
        val queue = ArrayDeque<String>()
        val visited = mutableSetOf<String>()
        
        queue.offer(beginWord)
        visited.add(beginWord)
        var length = 1
        
        while (queue.isNotEmpty()) {
            val size = queue.size
            
            for (i in 0 until size) {
                val current = queue.poll()
                
                if (current == endWord) {
                    return length
                }
                
                // Try all possible single character changes
                val chars = current.toCharArray()
                for (j in chars.indices) {
                    val originalChar = chars[j]
                    
                    for (c in 'a'..'z') {
                        if (c != originalChar) {
                            chars[j] = c
                            val newWord = String(chars)
                            
                            if (newWord in wordSet && newWord !in visited) {
                                visited.add(newWord)
                                queue.offer(newWord)
                            }
                        }
                    }
                    
                    chars[j] = originalChar // Reset for next iteration
                }
            }
            
            length++
        }
        
        return 0
    }
}
```

```typescript [TypeScript]
function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {
    if (!wordList.includes(endWord)) return 0;
    if (beginWord === endWord) return 1;
    
    const wordSet = new Set(wordList);
    const queue: string[] = [beginWord];
    const visited = new Set<string>([beginWord]);
    let length = 1;
    
    while (queue.length > 0) {
        const size = queue.length;
        
        for (let i = 0; i < size; i++) {
            const current = queue.shift()!;
            
            if (current === endWord) {
                return length;
            }
            
            // Try all possible single character changes
            const chars = current.split('');
            for (let j = 0; j < chars.length; j++) {
                const originalChar = chars[j];
                
                for (let c = 97; c <= 122; c++) {
                    const char = String.fromCharCode(c);
                    if (char !== originalChar) {
                        chars[j] = char;
                        const newWord = chars.join('');
                        
                        if (wordSet.has(newWord) && !visited.has(newWord)) {
                            visited.add(newWord);
                            queue.push(newWord);
                        }
                    }
                }
                
                chars[j] = originalChar; // Reset
            }
        }
        
        length++;
    }
    
    return 0;
}
```

```java [Java]
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord)) return 0;
        if (beginWord.equals(endWord)) return 1;
        
        Set<String> wordSet = new HashSet<>(wordList);
        Queue<String> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        
        queue.offer(beginWord);
        visited.add(beginWord);
        int length = 1;
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            
            for (int i = 0; i < size; i++) {
                String current = queue.poll();
                
                if (current.equals(endWord)) {
                    return length;
                }
                
                // Try all possible single character changes
                char[] chars = current.toCharArray();
                for (int j = 0; j < chars.length; j++) {
                    char originalChar = chars[j];
                    
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (c != originalChar) {
                            chars[j] = c;
                            String newWord = new String(chars);
                            
                            if (wordSet.contains(newWord) && !visited.contains(newWord)) {
                                visited.add(newWord);
                                queue.offer(newWord);
                            }
                        }
                    }
                    
                    chars[j] = originalChar; // Reset
                }
            }
            
            length++;
        }
        
        return 0;
    }
}
```

```python [Python]
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList:
            return 0
        if beginWord == endWord:
            return 1
        
        word_set = set(wordList)
        queue = deque([beginWord])
        visited = {beginWord}
        length = 1
        
        while queue:
            size = len(queue)
            
            for _ in range(size):
                current = queue.popleft()
                
                if current == endWord:
                    return length
                
                # Try all possible single character changes
                chars = list(current)
                for i in range(len(chars)):
                    original_char = chars[i]
                    
                    for c in 'abcdefghijklmnopqrstuvwxyz':
                        if c != original_char:
                            chars[i] = c
                            new_word = ''.join(chars)
                            
                            if new_word in word_set and new_word not in visited:
                                visited.add(new_word)
                                queue.append(new_word)
                    
                    chars[i] = original_char  # Reset
        
            length += 1
        
        return 0
```

:::

## Complexity

- **Time Complexity:** O(MÂ² Ã— N), where M is the length of each word and N is the number of words in the wordList. For each word, we try all M positions and for each position, we try all 26 characters, and each string operation takes O(M) time.
- **Space Complexity:** O(M Ã— N) for the word set, queue, and visited set.