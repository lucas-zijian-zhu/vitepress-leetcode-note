# [210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you **must**  take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.

- For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.

Return the ordering of courses you should take to finish all courses. If there are many valid answers, return **any**  of them. If it is impossible to finish all courses, return **an empty array** .

**Example 1:**

```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
```

**Example 2:**

```
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
```

**Example 3:**

```
Input: numCourses = 1, prerequisites = []
Output: [0]
```

**Constraints:**

- <code>1 <= numCourses <= 2000</code>
- <code>0 <= prerequisites.length <= numCourses * (numCourses - 1)</code>
- <code>prerequisites[i].length == 2</code>
- <code>0 <= a<sub>i</sub>, b<sub>i</sub> < numCourses</code>
- <code>a<sub>i</sub> != b<sub>i</sub></code>
- All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are **distinct** .

## ðŸš€ Approach: Topological Sort with BFS (Kahn's Algorithm)

### Intuition

This is a **topological sorting** problem. We need to find a valid ordering of courses such that all prerequisites are satisfied. This is equivalent to finding a topological ordering of a directed graph where:
- Each course is a node
- Each prerequisite `[a, b]` creates a directed edge from `b` to `a` (b must be taken before a)

If there's a cycle in the graph, no valid topological ordering exists.

### Algorithm

1. **Build the graph** and calculate in-degrees for each node
2. **Use BFS (Kahn's Algorithm)** to process nodes with zero in-degree
3. **Add processed nodes to result** and reduce in-degrees of their neighbors
4. **If we can process all nodes**, return the topological order; otherwise, return empty array

**Key Insight:** The order in which nodes are processed gives us a valid topological ordering.

---

## Code

::: code-group

```typescript [TypeScript]
function findOrder(numCourses: number, prerequisites: number[][]): number[] {
    // Build adjacency list and calculate in-degrees
    const graph = new Map<number, number[]>();
    const inDegree = new Array(numCourses).fill(0);
    
    for (const [course, prereq] of prerequisites) {
        if (!graph.has(prereq)) {
            graph.set(prereq, []);
        }
        graph.get(prereq)!.push(course);
        inDegree[course]++;
    }
    
    // BFS with queue for topological sort
    const queue: number[] = [];
    for (let i = 0; i < numCourses; i++) {
        if (inDegree[i] === 0) {
            queue.push(i);
        }
    }
    
    const result: number[] = [];
    while (queue.length > 0) {
        const current = queue.shift()!;
        result.push(current);
        
        // Process neighbors
        const neighbors = graph.get(current) || [];
        for (const neighbor of neighbors) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] === 0) {
                queue.push(neighbor);
            }
        }
    }
    
    return result.length === numCourses ? result : [];
}
```

```kotlin [Kotlin]
class Solution {
    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {
        // Build adjacency list and calculate in-degrees
        val graph = mutableMapOf<Int, MutableList<Int>>()
        val inDegree = IntArray(numCourses)
        
        for ((course, prereq) in prerequisites) {
            graph.getOrPut(prereq) { mutableListOf() }.add(course)
            inDegree[course]++
        }
        
        // BFS with queue for topological sort
        val queue = ArrayDeque<Int>()
        for (i in 0 until numCourses) {
            if (inDegree[i] == 0) {
                queue.offer(i)
            }
        }
        
        val result = mutableListOf<Int>()
        while (queue.isNotEmpty()) {
            val current = queue.poll()
            result.add(current)
            
            // Process neighbors
            graph[current]?.forEach { neighbor ->
                inDegree[neighbor]--
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor)
                }
            }
        }
        
        return if (result.size == numCourses) result.toIntArray() else intArrayOf()
    }
}
```

```java [Java]
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // Build adjacency list and calculate in-degrees
        List<List<Integer>> graph = new ArrayList<>();
        int[] inDegree = new int[numCourses];
        
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int[] prereq : prerequisites) {
            int course = prereq[0];
            int prereqCourse = prereq[1];
            graph.get(prereqCourse).add(course);
            inDegree[course]++;
        }
        
        // BFS with queue for topological sort
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        List<Integer> result = new ArrayList<>();
        while (!queue.isEmpty()) {
            int current = queue.poll();
            result.add(current);
            
            // Process neighbors
            for (int neighbor : graph.get(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        if (result.size() == numCourses) {
            return result.stream().mapToInt(Integer::intValue).toArray();
        } else {
            return new int[0];
        }
    }
}
```

```swift [Swift]
class Solution {
    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {
        var graph = Array(repeating: [Int](), count: numCourses)
        var indegree = Array(repeating: 0, count: numCourses)

        for pair in prerequisites {
            let course = pair[0]
            let prereq = pair[1]
            graph[prereq].append(course)
            indegree[course] += 1
        }

        var queue: [Int] = []
        for i in 0..<numCourses where indegree[i] == 0 {
            queue.append(i)
        }

        var order: [Int] = []
        while !queue.isEmpty {
            let course = queue.removeFirst()
            order.append(course)
            for next in graph[course] {
                indegree[next] -= 1
                if indegree[next] == 0 {
                    queue.append(next)
                }
            }
        }

        return order.count == numCourses ? order : []
    }
}
```

```python [Python]
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # Build adjacency list and calculate in-degrees
        graph = [[] for _ in range(numCourses)]
        in_degree = [0] * numCourses
        
        for course, prereq in prerequisites:
            graph[prereq].append(course)
            in_degree[course] += 1
        
        # BFS with queue for topological sort
        queue = deque()
        for i in range(numCourses):
            if in_degree[i] == 0:
                queue.append(i)
        
        result = []
        while queue:
            current = queue.popleft()
            result.append(current)
            
            # Process neighbors
            for neighbor in graph[current]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return result if len(result) == numCourses else []
```

:::
## Complexity

- **Time Complexity:** O(V + E), where V is the number of courses and E is the number of prerequisites
- **Space Complexity:** O(V + E) for storing the graph, in-degree array, and result
