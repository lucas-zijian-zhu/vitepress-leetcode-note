# [133. Clone Graph](https://leetcode.com/problems/clone-graph/description/?envType=study-plan-v2&envId=top-interview-150)

Given a reference of a node in a **<a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph" target="_blank">connected</a>**  undirected graph.

Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank">**deep copy** </a> (clone) of the graph.

Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.

```
class Node {
    public int val;
    public List<Node> neighbors;
}
```

**Test case format:** 

For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.

<b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.

The given node will always be the first node with <code>val = 1</code>. You must return the **copy of the given node**  as a reference to the cloned graph.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" style="width: 454px; height: 500px;">

```
Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
```

**Example 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/07/graph.png" style="width: 163px; height: 148px;">

```
Input: adjList = [[]]
Output: [[]]
Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
```

**Example 3:** 

```
Input: adjList = []
Output: []
Explanation: This an empty graph, it does not have any nodes.
```

**Constraints:** 

- The number of nodes in the graph is in the range <code>[0, 100]</code>.
- <code>1 <= Node.val <= 100</code>
- <code>Node.val</code> is unique for each node.
- There are no repeated edges and no self-loops in the graph.
- The Graph is connected and all nodes can be visited starting from the given node.

## ðŸ’¡ Approach: DFS with HashMap

### Intuition

To clone a graph, we need to create a copy of each node and maintain the same neighbor relationships. The key challenge is handling cycles in the graph. We use a **HashMap** to track visited nodes and their clones.

### Algorithm

1. **Use HashMap** to store mapping from original node to cloned node
2. **Use DFS** to traverse the graph
3. **For each node**:
   - If already cloned, return the clone from HashMap
   - Otherwise, create a new clone
   - Recursively clone all neighbors
   - Add neighbors to the cloned node

### Key Points

- Use HashMap to avoid infinite loops (handle cycles)
- DFS or BFS both work
- Deep copy means copying structure and values
- Handle null input edge case

## Code

::: code-group

```kotlin [Kotlin]
class Node(var `val`: Int) {
    var neighbors: ArrayList<Node?> = ArrayList()
}

class Solution {
    private val visited = HashMap<Node, Node>()
    
    fun cloneGraph(node: Node?): Node? {
        if (node == null) return null
        
        // If node already cloned, return the clone
        if (visited.containsKey(node)) {
            return visited[node]
        }
        
        // Create a clone for the current node
        val cloneNode = Node(node.`val`)
        visited[node] = cloneNode
        
        // Clone all neighbors
        for (neighbor in node.neighbors) {
            cloneNode.neighbors.add(cloneGraph(neighbor))
        }
        
        return cloneNode
    }
}
```

```typescript [TypeScript]
class Node {
    val: number;
    neighbors: Node[];
    constructor(val?: number, neighbors?: Node[]) {
        this.val = (val === undefined ? 0 : val);
        this.neighbors = (neighbors === undefined ? [] : neighbors);
    }
}

function cloneGraph(node: Node | null): Node | null {
    if (node === null) return null;
    
    const visited = new Map<Node, Node>();
    
    function dfs(node: Node): Node {
        // If node already cloned, return the clone
        if (visited.has(node)) {
            return visited.get(node)!;
        }
        
        // Create a clone for the current node
        const cloneNode = new Node(node.val);
        visited.set(node, cloneNode);
        
        // Clone all neighbors
        for (const neighbor of node.neighbors) {
            cloneNode.neighbors.push(dfs(neighbor));
        }
        
        return cloneNode;
    }
    
    return dfs(node);
}
```

```java [Java]
class Node {
    public int val;
    public List<Node> neighbors;
    
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}

class Solution {
    private HashMap<Node, Node> visited = new HashMap<>();
    
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        
        // If node already cloned, return the clone
        if (visited.containsKey(node)) {
            return visited.get(node);
        }
        
        // Create a clone for the current node
        Node cloneNode = new Node(node.val);
        visited.put(node, cloneNode);
        
        // Clone all neighbors
        for (Node neighbor : node.neighbors) {
            cloneNode.neighbors.add(cloneGraph(neighbor));
        }
        
        return cloneNode;
    }
}
```

```python [Python]
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

class Solution:
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return None
        
        visited = {}
        
        def dfs(node):
            # If node already cloned, return the clone
            if node in visited:
                return visited[node]
            
            # Create a clone for the current node
            clone_node = Node(node.val)
            visited[node] = clone_node
            
            # Clone all neighbors
            for neighbor in node.neighbors:
                clone_node.neighbors.append(dfs(neighbor))
            
            return clone_node
        
        return dfs(node)
```

:::

## Complexity

- **Time Complexity:** O(n + m), where n is the number of nodes and m is the number of edges. We visit each node and edge once.
- **Space Complexity:** O(n) for the HashMap to store all cloned nodes and O(h) for the recursion stack where h is the depth of the graph.