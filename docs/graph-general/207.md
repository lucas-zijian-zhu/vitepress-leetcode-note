# [207. Course Schedule](https://leetcode.com/problems/course-schedule/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you **must**  take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.

- For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.

Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.

**Example 1:**

```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
```

**Example 2:**

```
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
```

**Constraints:**

- <code>1 <= numCourses <= 2000</code>
- <code>0 <= prerequisites.length <= 5000</code>
- <code>prerequisites[i].length == 2</code>
- <code>0 <= a<sub>i</sub>, b<sub>i</sub> < numCourses</code>
- All the pairs prerequisites[i] are **unique** .

## ðŸš€ Approach: Topological Sort with BFS (Kahn's Algorithm)

### Intuition

This is a classic **cycle detection in a directed graph** problem. We can model the courses and prerequisites as a directed graph where:
- Each course is a node
- Each prerequisite `[a, b]` creates a directed edge from `b` to `a` (b must be taken before a)

The problem asks if we can find a valid topological ordering, which is possible if and only if the graph is a **DAG (Directed Acyclic Graph)**.

### Algorithm

1. **Build the graph** and calculate in-degrees for each node
2. **Use BFS (Kahn's Algorithm)** to process nodes with zero in-degree
3. **For each processed node**, reduce in-degrees of its neighbors
4. **If we can process all nodes**, there's no cycle; otherwise, there's a cycle

**Key Insight:** If there's a cycle in the graph, some nodes will never have their in-degree reduced to 0, so they'll never be processed.

---

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {
        // Build adjacency list and calculate in-degrees
        val graph = mutableMapOf<Int, MutableList<Int>>()
        val inDegree = IntArray(numCourses)
        
        for ((course, prereq) in prerequisites) {
            graph.getOrPut(prereq) { mutableListOf() }.add(course)
            inDegree[course]++
        }
        
        // BFS with queue for topological sort
        val queue = ArrayDeque<Int>()
        for (i in 0 until numCourses) {
            if (inDegree[i] == 0) {
                queue.offer(i)
            }
        }
        
        var processed = 0
        while (queue.isNotEmpty()) {
            val current = queue.poll()
            processed++
            
            // Process neighbors
            graph[current]?.forEach { neighbor ->
                inDegree[neighbor]--
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor)
                }
            }
        }
        
        return processed == numCourses
    }
}
```

```typescript [TypeScript]
function canFinish(numCourses: number, prerequisites: number[][]): boolean {
    // Build adjacency list and calculate in-degrees
    const graph = new Map<number, number[]>();
    const inDegree = new Array(numCourses).fill(0);
    
    for (const [course, prereq] of prerequisites) {
        if (!graph.has(prereq)) {
            graph.set(prereq, []);
        }
        graph.get(prereq)!.push(course);
        inDegree[course]++;
    }
    
    // BFS with queue for topological sort
    const queue: number[] = [];
    for (let i = 0; i < numCourses; i++) {
        if (inDegree[i] === 0) {
            queue.push(i);
        }
    }
    
    let processed = 0;
    while (queue.length > 0) {
        const current = queue.shift()!;
        processed++;
        
        // Process neighbors
        const neighbors = graph.get(current) || [];
        for (const neighbor of neighbors) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] === 0) {
                queue.push(neighbor);
            }
        }
    }
    
    return processed === numCourses;
}
```

```java [Java]
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // Build adjacency list and calculate in-degrees
        List<List<Integer>> graph = new ArrayList<>();
        int[] inDegree = new int[numCourses];
        
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int[] prereq : prerequisites) {
            int course = prereq[0];
            int prereqCourse = prereq[1];
            graph.get(prereqCourse).add(course);
            inDegree[course]++;
        }
        
        // BFS with queue for topological sort
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        int processed = 0;
        while (!queue.isEmpty()) {
            int current = queue.poll();
            processed++;
            
            // Process neighbors
            for (int neighbor : graph.get(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        return processed == numCourses;
    }
}
```

```python [Python]
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # Build adjacency list and calculate in-degrees
        graph = [[] for _ in range(numCourses)]
        in_degree = [0] * numCourses
        
        for course, prereq in prerequisites:
            graph[prereq].append(course)
            in_degree[course] += 1
        
        # BFS with queue for topological sort
        queue = deque()
        for i in range(numCourses):
            if in_degree[i] == 0:
                queue.append(i)
        
        processed = 0
        while queue:
            current = queue.popleft()
            processed += 1
            
            # Process neighbors
            for neighbor in graph[current]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return processed == numCourses
```

:::

## Complexity

- **Time Complexity:** O(V + E), where V is the number of courses and E is the number of prerequisites
- **Space Complexity:** O(V + E) for storing the graph and in-degree array