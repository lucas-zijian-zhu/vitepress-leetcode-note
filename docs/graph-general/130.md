# [130. Surrounded Regions](https://leetcode.com/problems/surrounded-regions/description/?envType=study-plan-v2&envId=top-interview-150)<Badge type="warning" text="Medium" />

You are given an <code>m x n</code> matrix <code>board</code> containing **letters**  <code>'X'</code> and <code>'O'</code>, **capture regions**  that are **surrounded** :

- **Connect** : A cell is connected to adjacent cells horizontally or vertically.
- **Region** : To form a region **connect every**  <code>'O'</code> cell.
- **Surround** : The region is surrounded with <code>'X'</code> cells if you can **connect the region ** with <code>'X'</code> cells and none of the region cells are on the edge of the <code>board</code>.

To capture a **surrounded region** , replace all <code>'O'</code>s with <code>'X'</code>s **in-place**  within the original board. You do not need to return anything.

**Example 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" style="width: 367px; height: 158px;">

```
Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
Explanation: The bottom region is not captured because it is on the edge of the board and cannot be surrounded.
```

**Example 2:** 

```
Input: board = [["X"]]
Output: [["X"]]
```

**Constraints:** 

- <code>m == board.length</code>
- <code>n == board[i].length</code>
- <code>1 <= m, n <= 200</code>
- <code>board[i][j]</code> is <code>'X'</code> or <code>'O'</code>.

## ðŸ’¡ Approach: DFS from Boundaries

### Intuition

The key insight is that **only 'O's connected to the boundary can survive**. All other 'O's are surrounded and should be captured. We can use a two-step approach:

1. **Mark boundary-connected 'O's** as temporary markers (e.g., 'T')
2. **Replace remaining 'O's** with 'X' and restore 'T's to 'O'

### Algorithm

1. **Find boundary 'O's** and mark them as 'T' using DFS
2. **Replace all remaining 'O's** with 'X' (these are surrounded)
3. **Restore all 'T's** back to 'O' (these are boundary-connected)

### Key Points

- Only boundary-connected 'O's survive
- Use temporary marker to distinguish boundary 'O's
- DFS from all boundary positions
- Two-pass approach: mark then replace

## Code

::: code-group

```kotlin [Kotlin]
class Solution {
    fun solve(board: Array<CharArray>): Unit {
        if (board.isEmpty()) return
        
        val rows = board.size
        val cols = board[0].size
        
        // Mark boundary-connected 'O's as 'T'
        for (i in 0 until rows) {
            for (j in 0 until cols) {
                if ((i == 0 || i == rows - 1 || j == 0 || j == cols - 1) && board[i][j] == 'O') {
                    dfs(board, i, j)
                }
            }
        }
        
        // Replace remaining 'O's with 'X' and restore 'T's to 'O'
        for (i in 0 until rows) {
            for (j in 0 until cols) {
                when (board[i][j]) {
                    'O' -> board[i][j] = 'X'
                    'T' -> board[i][j] = 'O'
                }
            }
        }
    }
    
    private fun dfs(board: Array<CharArray>, r: Int, c: Int) {
        val rows = board.size
        val cols = board[0].size
        
        if (r < 0 || r >= rows || c < 0 || c >= cols || board[r][c] != 'O') {
            return
        }
        
        board[r][c] = 'T'
        
        dfs(board, r + 1, c)
        dfs(board, r - 1, c)
        dfs(board, r, c + 1)
        dfs(board, r, c - 1)
    }
}
```

```typescript [TypeScript]
function solve(board: string[][]): void {
    if (board.length === 0) return;
    
    const rows = board.length;
    const cols = board[0].length;
    
    // Mark boundary-connected 'O's as 'T'
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if ((i === 0 || i === rows - 1 || j === 0 || j === cols - 1) && board[i][j] === 'O') {
                dfs(board, i, j);
            }
        }
    }
    
    // Replace remaining 'O's with 'X' and restore 'T's to 'O'
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (board[i][j] === 'O') {
                board[i][j] = 'X';
            } else if (board[i][j] === 'T') {
                board[i][j] = 'O';
            }
        }
    }
}

function dfs(board: string[][], r: number, c: number): void {
    const rows = board.length;
    const cols = board[0].length;
    
    if (r < 0 || r >= rows || c < 0 || c >= cols || board[r][c] !== 'O') {
        return;
    }
    
    board[r][c] = 'T';
    
    dfs(board, r + 1, c);
    dfs(board, r - 1, c);
    dfs(board, r, c + 1);
    dfs(board, r, c - 1);
}
```

```java [Java]
class Solution {
    public void solve(char[][] board) {
        if (board.length == 0) return;
        
        int rows = board.length;
        int cols = board[0].length;
        
        // Mark boundary-connected 'O's as 'T'
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if ((i == 0 || i == rows - 1 || j == 0 || j == cols - 1) && board[i][j] == 'O') {
                    dfs(board, i, j);
                }
            }
        }
        
        // Replace remaining 'O's with 'X' and restore 'T's to 'O'
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                } else if (board[i][j] == 'T') {
                    board[i][j] = 'O';
                }
            }
        }
    }
    
    private void dfs(char[][] board, int r, int c) {
        int rows = board.length;
        int cols = board[0].length;
        
        if (r < 0 || r >= rows || c < 0 || c >= cols || board[r][c] != 'O') {
            return;
        }
        
        board[r][c] = 'T';
        
        dfs(board, r + 1, c);
        dfs(board, r - 1, c);
        dfs(board, r, c + 1);
        dfs(board, r, c - 1);
    }
}
```

```swift [Swift]
class Solution {
    func solve(_ board: inout [[Character]]) {
        let rows = board.count
        guard rows > 0 else { return }
        let cols = board[0].count

        func dfs(_ r: Int, _ c: Int) {
            if r < 0 || c < 0 || r >= rows || c >= cols {
                return
            }
            if board[r][c] != "O" {
                return
            }
            board[r][c] = "E"
            dfs(r + 1, c)
            dfs(r - 1, c)
            dfs(r, c + 1)
            dfs(r, c - 1)
        }

        for r in 0..<rows {
            dfs(r, 0)
            dfs(r, cols - 1)
        }
        for c in 0..<cols {
            dfs(0, c)
            dfs(rows - 1, c)
        }

        for r in 0..<rows {
            for c in 0..<cols {
                if board[r][c] == "O" {
                    board[r][c] = "X"
                } else if board[r][c] == "E" {
                    board[r][c] = "O"
                }
            }
        }
    }
}
```

```python [Python]
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        
        rows, cols = len(board), len(board[0])
        
        # Mark boundary-connected 'O's as 'T'
        for i in range(rows):
            for j in range(cols):
                if ((i == 0 or i == rows - 1 or j == 0 or j == cols - 1) and board[i][j] == 'O'):
                    self.dfs(board, i, j)
        
        # Replace remaining 'O's with 'X' and restore 'T's to 'O'
        for i in range(rows):
            for j in range(cols):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == 'T':
                    board[i][j] = 'O'
    
    def dfs(self, board: List[List[str]], r: int, c: int) -> None:
        rows, cols = len(board), len(board[0])
        
        if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != 'O':
            return
        
        board[r][c] = 'T'
        
        self.dfs(board, r + 1, c)
        self.dfs(board, r - 1, c)
        self.dfs(board, r, c + 1)
        self.dfs(board, r, c - 1)
```

:::

## Complexity

- **Time Complexity:** O(m Ã— n), where m is the number of rows and n is the number of columns. We visit each cell at most once.
- **Space Complexity:** O(m Ã— n) in the worst case for the recursion stack (if the entire boundary is filled with 'O's).

